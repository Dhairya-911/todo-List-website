{"ast":null,"code":"/**\n * anime.js - ESM\n * @version v4.1.2\n * @author Julian Garnier\n * @license MIT\n * @copyright (c) 2025 Julian Garnier\n * @see https://animejs.com\n */\n\n// Global types ///////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Object} DefaultsParams\n * @property {Number|String} [id]\n * @property {PercentageKeyframes|DurationKeyframes} [keyframes]\n * @property {EasingParam} [playbackEase]\n * @property {Number} [playbackRate]\n * @property {Number} [frameRate]\n * @property {Number|Boolean} [loop]\n * @property {Boolean} [reversed]\n * @property {Boolean} [alternate]\n * @property {Boolean|ScrollObserver} [autoplay]\n * @property {Number|FunctionValue} [duration]\n * @property {Number|FunctionValue} [delay]\n * @property {Number} [loopDelay]\n * @property {EasingParam} [ease]\n * @property {'none'|'replace'|'blend'|compositionTypes} [composition]\n * @property {(v: any) => any} [modifier]\n * @property {(tickable: Tickable) => void} [onBegin]\n * @property {(tickable: Tickable) => void} [onBeforeUpdate]\n * @property {(tickable: Tickable) => void} [onUpdate]\n * @property {(tickable: Tickable) => void} [onLoop]\n * @property {(tickable: Tickable) => void} [onPause]\n * @property {(tickable: Tickable) => void} [onComplete]\n * @property {(renderable: Renderable) => void} [onRender]\n */\n\n/** @typedef {JSAnimation|Timeline} Renderable */\n/** @typedef {Timer|Renderable} Tickable */\n/** @typedef {Timer&JSAnimation&Timeline} CallbackArgument */\n/** @typedef {Animatable|Tickable|Draggable|ScrollObserver|TextSplitter|Scope} Revertible */\n\n// Stagger types //////////////////////////////////////////////////////////////\n\n/**\n * @callback StaggerFunction\n * @param {Target} [target]\n * @param {Number} [index]\n * @param {Number} [length]\n * @param {Timeline} [tl]\n * @return {Number|String}\n */\n\n/**\n * @typedef  {Object} StaggerParams\n * @property {Number|String} [start]\n * @property {Number|'first'|'center'|'last'|'random'} [from]\n * @property {Boolean} [reversed]\n * @property {Array.<Number>} [grid]\n * @property {('x'|'y')} [axis]\n * @property {String|StaggerFunction} [use]\n * @property {Number} [total]\n * @property {EasingParam} [ease]\n * @property {TweenModifier} [modifier]\n */\n\n// Eases types ////////////////////////////////////////////////////////////////\n\n/**\n * @callback EasingFunction\n * @param {Number} time\n * @return {Number}\n */\n\n/**\n * @typedef {('linear'|'linear(x1, x2 25%, x3)'|'in'|'out'|'inOut'|'inQuad'|'outQuad'|'inOutQuad'|'inCubic'|'outCubic'|'inOutCubic'|'inQuart'|'outQuart'|'inOutQuart'|'inQuint'|'outQuint'|'inOutQuint'|'inSine'|'outSine'|'inOutSine'|'inCirc'|'outCirc'|'inOutCirc'|'inExpo'|'outExpo'|'inOutExpo'|'inBounce'|'outBounce'|'inOutBounce'|'inBack'|'outBack'|'inOutBack'|'inElastic'|'outElastic'|'inOutElastic'|'irregular'|'cubicBezier'|'steps'|'in(p = 1.675)'|'out(p = 1.675)'|'inOut(p = 1.675)'|'inBack(overshoot = 1.70158)'|'outBack(overshoot = 1.70158)'|'inOutBack(overshoot = 1.70158)'|'inElastic(amplitude = 1, period = .3)'|'outElastic(amplitude = 1, period = .3)'|'inOutElastic(amplitude = 1, period = .3)'|'irregular(length = 10, randomness = 1)'|'cubicBezier(x1, y1, x2, y2)'|'steps(steps = 10)')} EaseStringParamNames\n */\n\n// A hack to get both ease names suggestions AND allow any strings\n// https://github.com/microsoft/TypeScript/issues/29729#issuecomment-460346421\n/** @typedef {(String & {})|EaseStringParamNames|EasingFunction|Spring} EasingParam */\n\n/** @typedef {HTMLElement|SVGElement} DOMTarget */\n/** @typedef {Record<String, any>} JSTarget */\n/** @typedef {DOMTarget|JSTarget} Target */\n/** @typedef {Target|NodeList|String} TargetSelector */\n/** @typedef {DOMTarget|NodeList|String} DOMTargetSelector */\n/** @typedef {Array.<DOMTargetSelector>|DOMTargetSelector} DOMTargetsParam */\n/** @typedef {Array.<DOMTarget>} DOMTargetsArray */\n/** @typedef {Array.<JSTarget>|JSTarget} JSTargetsParam */\n/** @typedef {Array.<JSTarget>} JSTargetsArray */\n/** @typedef {Array.<TargetSelector>|TargetSelector} TargetsParam */\n/** @typedef {Array.<Target>} TargetsArray */\n\n// Callback types ////////////////////////////////////////////////////////////\n\n/**\n * @template T\n * @callback Callback\n * @param {T} self - Returns itself\n * @param {PointerEvent} [e]\n * @return {*}\n */\n\n/**\n * @template {object} T\n * @typedef {Object} TickableCallbacks\n * @property {Callback<T>} [onBegin]\n * @property {Callback<T>} [onBeforeUpdate]\n * @property {Callback<T>} [onUpdate]\n * @property {Callback<T>} [onLoop]\n * @property {Callback<T>} [onPause]\n * @property {Callback<T>} [onComplete]\n */\n\n/**\n * @template {object} T\n * @typedef {Object} RenderableCallbacks\n * @property {Callback<T>} [onRender]\n */\n\n// Timer types ////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Object} TimerOptions\n * @property {Number|String} [id]\n * @property {TweenParamValue} [duration]\n * @property {TweenParamValue} [delay]\n * @property {Number} [loopDelay]\n * @property {Boolean} [reversed]\n * @property {Boolean} [alternate]\n * @property {Boolean|Number} [loop]\n * @property {Boolean|ScrollObserver} [autoplay]\n * @property {Number} [frameRate]\n * @property {Number} [playbackRate]\n */\n\n/**\n\n/**\n * @typedef {TimerOptions & TickableCallbacks<Timer>} TimerParams\n */\n\n// Tween types ////////////////////////////////////////////////////////////////\n\n/**\n * @callback FunctionValue\n * @param {Target} target - The animated target\n * @param {Number} index - The target index\n * @param {Number} length - The total number of animated targets\n * @return {Number|String|TweenObjectValue|Array.<Number|String|TweenObjectValue>}\n */\n\n/**\n * @callback TweenModifier\n * @param {Number} value - The animated value\n * @return {Number|String}\n */\n\n/** @typedef {[Number, Number, Number, Number]} ColorArray */\n\n/**\n * @typedef {Object} Tween\n * @property {Number} id\n * @property {JSAnimation} parent\n * @property {String} property\n * @property {Target} target\n * @property {String|Number} _value\n * @property {Function|null} _func\n * @property {EasingFunction} _ease\n * @property {Array.<Number>} _fromNumbers\n * @property {Array.<Number>} _toNumbers\n * @property {Array.<String>} _strings\n * @property {Number} _fromNumber\n * @property {Number} _toNumber\n * @property {Array.<Number>} _numbers\n * @property {Number} _number\n * @property {String} _unit\n * @property {TweenModifier} _modifier\n * @property {Number} _currentTime\n * @property {Number} _delay\n * @property {Number} _updateDuration\n * @property {Number} _startTime\n * @property {Number} _changeDuration\n * @property {Number} _absoluteStartTime\n * @property {tweenTypes} _tweenType\n * @property {valueTypes} _valueType\n * @property {Number} _composition\n * @property {Number} _isOverlapped\n * @property {Number} _isOverridden\n * @property {Number} _renderTransforms\n * @property {Tween} _prevRep\n * @property {Tween} _nextRep\n * @property {Tween} _prevAdd\n * @property {Tween} _nextAdd\n * @property {Tween} _prev\n * @property {Tween} _next\n */\n\n/**\n * @typedef TweenDecomposedValue\n * @property {Number} t - Type\n * @property {Number} n - Single number value\n * @property {String} u - Value unit\n * @property {String} o - Value operator\n * @property {Array.<Number>} d - Array of Numbers (in case of complex value type)\n * @property {Array.<String>} s - Strings (in case of complex value type)\n */\n\n/** @typedef {{_head: null|Tween, _tail: null|Tween}} TweenPropertySiblings */\n/** @typedef {Record<String, TweenPropertySiblings>} TweenLookups */\n/** @typedef {WeakMap.<Target, TweenLookups>} TweenReplaceLookups */\n/** @typedef {Map.<Target, TweenLookups>} TweenAdditiveLookups */\n\n// Animation types ////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Number|String|FunctionValue} TweenParamValue\n */\n\n/**\n * @typedef {TweenParamValue|[TweenParamValue, TweenParamValue]} TweenPropValue\n */\n\n/**\n * @typedef {(String & {})|'none'|'replace'|'blend'|compositionTypes} TweenComposition\n */\n\n/**\n * @typedef {Object} TweenParamsOptions\n * @property {TweenParamValue} [duration]\n * @property {TweenParamValue} [delay]\n * @property {EasingParam} [ease]\n * @property {TweenModifier} [modifier]\n * @property {TweenComposition} [composition]\n */\n\n/**\n * @typedef {Object} TweenValues\n * @property {TweenParamValue} [from]\n * @property {TweenPropValue} [to]\n * @property {TweenPropValue} [fromTo]\n */\n\n/**\n * @typedef {TweenParamsOptions & TweenValues} TweenKeyValue\n */\n\n/**\n * @typedef {Array.<TweenKeyValue|TweenPropValue>} ArraySyntaxValue\n */\n\n/**\n * @typedef {TweenParamValue|ArraySyntaxValue|TweenKeyValue} TweenOptions\n */\n\n/**\n * @typedef {Partial<{to: TweenParamValue|Array.<TweenParamValue>; from: TweenParamValue|Array.<TweenParamValue>; fromTo: TweenParamValue|Array.<TweenParamValue>;}>} TweenObjectValue\n */\n\n/**\n * @typedef {Object} PercentageKeyframeOptions\n * @property {EasingParam} [ease]\n */\n\n/**\n * @typedef {Record<String, TweenParamValue>} PercentageKeyframeParams\n */\n\n/**\n * @typedef {Record<String, PercentageKeyframeParams & PercentageKeyframeOptions>} PercentageKeyframes\n */\n\n/**\n * @typedef {Array<Record<String, TweenOptions | TweenModifier | boolean> & TweenParamsOptions>} DurationKeyframes\n */\n\n/**\n * @typedef {Object} AnimationOptions\n * @property {PercentageKeyframes|DurationKeyframes} [keyframes]\n * @property {EasingParam} [playbackEase]\n */\n\n// TODO: Currently setting TweenModifier to the intersected Record<> makes the FunctionValue type target param any if only one parameter is set\n/**\n * @typedef {Record<String, TweenOptions | Callback<JSAnimation> | TweenModifier | boolean | PercentageKeyframes | DurationKeyframes | ScrollObserver> & TimerOptions & AnimationOptions & TweenParamsOptions & TickableCallbacks<JSAnimation> & RenderableCallbacks<JSAnimation>} AnimationParams\n */\n\n// Timeline types /////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Object} TimelineOptions\n * @property {DefaultsParams} [defaults]\n * @property {EasingParam} [playbackEase]\n */\n\n/**\n * @typedef {TimerOptions & TimelineOptions & TickableCallbacks<Timeline> & RenderableCallbacks<Timeline>} TimelineParams\n */\n\n// Animatable types ///////////////////////////////////////////////////////////\n\n/**\n * @callback AnimatablePropertySetter\n * @param  {Number|Array.<Number>} to\n * @param  {Number} [duration]\n * @param  {EasingParam} [ease]\n * @return {AnimatableObject}\n */\n\n/**\n * @callback AnimatablePropertyGetter\n * @return {Number|Array.<Number>}\n */\n\n/**\n * @typedef {AnimatablePropertySetter & AnimatablePropertyGetter} AnimatableProperty\n */\n\n/**\n * @typedef {Animatable & Record<String, AnimatableProperty>} AnimatableObject\n */\n\n/**\n * @typedef {Object} AnimatablePropertyParamsOptions\n * @property {String} [unit]\n * @property {TweenParamValue} [duration]\n * @property {EasingParam} [ease]\n * @property {TweenModifier} [modifier]\n * @property {TweenComposition} [composition]\n */\n\n/**\n * @typedef {Record<String, TweenParamValue | EasingParam | TweenModifier | TweenComposition | AnimatablePropertyParamsOptions> & AnimatablePropertyParamsOptions} AnimatableParams\n */\n\n// Scope types ////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Object} ReactRef\n * @property {HTMLElement|SVGElement|null} [current]\n */\n\n/**\n * @typedef {Object} AngularRef\n * @property {HTMLElement|SVGElement} [nativeElement]\n */\n\n/**\n * @typedef {Object} ScopeParams\n * @property {DOMTargetSelector|ReactRef|AngularRef} [root]\n * @property {DefaultsParams} [defaults]\n * @property {Record<String, String>} [mediaQueries]\n */\n\n/**\n * @template T\n * @callback ScopedCallback\n * @param {Scope} scope\n * @return {T}\n */\n\n/**\n * @callback ScopeCleanupCallback\n * @param {Scope} [scope]\n */\n\n/**\n * @callback ScopeConstructorCallback\n * @param {Scope} [scope]\n * @return {ScopeCleanupCallback|void}\n */\n\n/**\n * @callback ScopeMethod\n * @param {...*} args\n * @return {ScopeCleanupCallback|void}\n */\n\n// Draggable types ////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Object} DraggableAxisParam\n * @property {String} [mapTo]\n * @property {TweenModifier} [modifier]\n * @property {TweenComposition} [composition]\n * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [snap]\n */\n\n/**\n * @typedef {Object} DraggableCursorParams\n * @property {String} [onHover]\n * @property {String} [onGrab]\n */\n\n/**\n * @typedef {Object} DraggableParams\n * @property {DOMTargetSelector} [trigger]\n * @property {DOMTargetSelector|Array<Number>|((draggable: Draggable) => DOMTargetSelector|Array<Number>)} [container]\n * @property {Boolean|DraggableAxisParam} [x]\n * @property {Boolean|DraggableAxisParam} [y]\n * @property {TweenModifier} [modifier]\n * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [snap]\n * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [containerPadding]\n * @property {Number|((draggable: Draggable) => Number)} [containerFriction]\n * @property {Number|((draggable: Draggable) => Number)} [releaseContainerFriction]\n * @property {Number|((draggable: Draggable) => Number)} [dragSpeed]\n * @property {Number|((draggable: Draggable) => Number)} [scrollSpeed]\n * @property {Number|((draggable: Draggable) => Number)} [scrollThreshold]\n * @property {Number|((draggable: Draggable) => Number)} [minVelocity]\n * @property {Number|((draggable: Draggable) => Number)} [maxVelocity]\n * @property {Number|((draggable: Draggable) => Number)} [velocityMultiplier]\n * @property {Number} [releaseMass]\n * @property {Number} [releaseStiffness]\n * @property {Number} [releaseDamping]\n * @property {Boolean} [releaseDamping]\n * @property {EasingParam} [releaseEase]\n * @property {Boolean|DraggableCursorParams|((draggable: Draggable) => Boolean|DraggableCursorParams)} [cursor]\n * @property {Callback<Draggable>} [onGrab]\n * @property {Callback<Draggable>} [onDrag]\n * @property {Callback<Draggable>} [onRelease]\n * @property {Callback<Draggable>} [onUpdate]\n * @property {Callback<Draggable>} [onSettle]\n * @property {Callback<Draggable>} [onSnap]\n * @property {Callback<Draggable>} [onResize]\n * @property {Callback<Draggable>} [onAfterResize]\n */\n\n// Text types /////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Object} splitTemplateParams\n * @property {false|String} [class]\n * @property {Boolean|'hidden'|'clip'|'visible'|'scroll'|'auto'} [wrap]\n * @property {Boolean|'top'|'right'|'bottom'|'left'|'center'} [clone]\n */\n\n/**\n * @typedef {Boolean|String} SplitValue\n */\n\n/**\n * @callback SplitFunctionValue\n * @param {Node|HTMLElement} [value]\n * @return String\n */\n\n/**\n * @typedef {Object} TextSplitterParams\n * @property {SplitValue|splitTemplateParams|SplitFunctionValue} [lines]\n * @property {SplitValue|splitTemplateParams|SplitFunctionValue} [words]\n * @property {SplitValue|splitTemplateParams|SplitFunctionValue} [chars]\n * @property {Boolean} [accessible]\n * @property {Boolean} [includeSpaces]\n * @property {Boolean} [debug]\n */\n\n// SVG types //////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {SVGGeometryElement & {\n *   setAttribute(name: 'draw', value: `${number} ${number}`): void;\n *   draw: `${number} ${number}`;\n * }} DrawableSVGGeometry\n */\n\n// Environments\n\n// TODO: Do we need to check if we're running inside a worker ?\nconst isBrowser = typeof window !== 'undefined';\n\n/** @type {Window & {AnimeJS: Array}|null} */\nconst win = isBrowser ? (/** @type {Window & {AnimeJS: Array}} */ /** @type {unknown} */window) : null;\n\n/** @type {Document|null} */\nconst doc = isBrowser ? document : null;\n\n// Enums\n\n/** @enum {Number} */\nconst tweenTypes = {\n  OBJECT: 0,\n  ATTRIBUTE: 1,\n  CSS: 2,\n  TRANSFORM: 3,\n  CSS_VAR: 4\n};\n\n/** @enum {Number} */\nconst valueTypes = {\n  NUMBER: 0,\n  UNIT: 1,\n  COLOR: 2,\n  COMPLEX: 3\n};\n\n/** @enum {Number} */\nconst tickModes = {\n  NONE: 0,\n  AUTO: 1,\n  FORCE: 2\n};\n\n/** @enum {Number} */\nconst compositionTypes = {\n  replace: 0,\n  none: 1,\n  blend: 2\n};\n\n// Cache symbols\n\nconst isRegisteredTargetSymbol = Symbol();\nconst isDomSymbol = Symbol();\nconst isSvgSymbol = Symbol();\nconst transformsSymbol = Symbol();\nconst morphPointsSymbol = Symbol();\nconst proxyTargetSymbol = Symbol();\n\n// Numbers\n\nconst minValue = 1e-11;\nconst maxValue = 1e12;\nconst K = 1e3;\nconst maxFps = 120;\n\n// Strings\n\nconst emptyString = '';\nconst shortTransforms = /*#__PURE__*/(() => {\n  const map = new Map();\n  map.set('x', 'translateX');\n  map.set('y', 'translateY');\n  map.set('z', 'translateZ');\n  return map;\n})();\nconst validTransforms = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skew', 'skewX', 'skewY', 'perspective', 'matrix', 'matrix3d'];\nconst transformsFragmentStrings = /*#__PURE__*/validTransforms.reduce((a, v) => ({\n  ...a,\n  [v]: v + '('\n}), {});\n\n// Functions\n\n/** @return {void} */\nconst noop = () => {};\n\n// Regex\n\nconst hexTestRgx = /(^#([\\da-f]{3}){1,2}$)|(^#([\\da-f]{4}){1,2}$)/i;\nconst rgbExecRgx = /rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/i;\nconst rgbaExecRgx = /rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(-?\\d+|-?\\d*.\\d+)\\s*\\)/i;\nconst hslExecRgx = /hsl\\(\\s*(-?\\d+|-?\\d*.\\d+)\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*\\)/i;\nconst hslaExecRgx = /hsla\\(\\s*(-?\\d+|-?\\d*.\\d+)\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*,\\s*(-?\\d+|-?\\d*.\\d+)\\s*\\)/i;\n// export const digitWithExponentRgx = /[-+]?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?/g;\nconst digitWithExponentRgx = /[-+]?\\d*\\.?\\d+(?:e[-+]?\\d)?/gi;\n// export const unitsExecRgx = /^([-+]?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?)+([a-z]+|%)$/i;\nconst unitsExecRgx = /^([-+]?\\d*\\.?\\d+(?:e[-+]?\\d+)?)([a-z]+|%)$/i;\nconst lowerCaseRgx = /([a-z])([A-Z])/g;\nconst transformsExecRgx = /(\\w+)(\\([^)]+\\)+)/g; // Match inline transforms with cacl() values, returns the value wrapped in ()\nconst relativeValuesExecRgx = /(\\*=|\\+=|-=)/;\n\n/** @type {DefaultsParams} */\nconst defaults = {\n  id: null,\n  keyframes: null,\n  playbackEase: null,\n  playbackRate: 1,\n  frameRate: maxFps,\n  loop: 0,\n  reversed: false,\n  alternate: false,\n  autoplay: true,\n  duration: K,\n  delay: 0,\n  loopDelay: 0,\n  ease: 'out(2)',\n  composition: compositionTypes.replace,\n  modifier: v => v,\n  onBegin: noop,\n  onBeforeUpdate: noop,\n  onUpdate: noop,\n  onLoop: noop,\n  onPause: noop,\n  onComplete: noop,\n  onRender: noop\n};\nconst scope = {\n  /** @type {Scope} */\n  current: null,\n  /** @type {Document|DOMTarget} */\n  root: doc\n};\nconst globals = {\n  /** @type {DefaultsParams} */\n  defaults,\n  /** @type {Number} */\n  precision: 4,\n  /** @type {Number} */\n  timeScale: 1,\n  /** @type {Number} */\n  tickThreshold: 200\n};\nconst globalVersions = {\n  version: '4.1.2',\n  engine: null\n};\nif (isBrowser) {\n  if (!win.AnimeJS) win.AnimeJS = [];\n  win.AnimeJS.push(globalVersions);\n}\n\n// Strings\n\n/**\n * @param  {String} str\n * @return {String}\n */\nconst toLowerCase = str => str.replace(lowerCaseRgx, '$1-$2').toLowerCase();\n\n/**\n * Prioritize this method instead of regex when possible\n * @param  {String} str\n * @param  {String} sub\n * @return {Boolean}\n */\nconst stringStartsWith = (str, sub) => str.indexOf(sub) === 0;\n\n// Time\n// Note: Date.now is used instead of performance.now since it is precise enough for timings calculations, performs slightly faster and works in Node.js environement.\nconst now = Date.now;\n\n// Types checkers\n\nconst isArr = Array.isArray;\n/**@param {any} a @return {a is Record<String, any>} */\nconst isObj = a => a && a.constructor === Object;\n/**@param {any} a @return {a is Number} */\nconst isNum = a => typeof a === 'number' && !isNaN(a);\n/**@param {any} a @return {a is String} */\nconst isStr = a => typeof a === 'string';\n/**@param {any} a @return {a is Function} */\nconst isFnc = a => typeof a === 'function';\n/**@param {any} a @return {a is undefined} */\nconst isUnd = a => typeof a === 'undefined';\n/**@param {any} a @return {a is null | undefined} */\nconst isNil = a => isUnd(a) || a === null;\n/**@param {any} a @return {a is SVGElement} */\nconst isSvg = a => isBrowser && a instanceof SVGElement;\n/**@param {any} a @return {Boolean} */\nconst isHex = a => hexTestRgx.test(a);\n/**@param {any} a @return {Boolean} */\nconst isRgb = a => stringStartsWith(a, 'rgb');\n/**@param {any} a @return {Boolean} */\nconst isHsl = a => stringStartsWith(a, 'hsl');\n/**@param {any} a @return {Boolean} */\nconst isCol = a => isHex(a) || isRgb(a) || isHsl(a);\n/**@param {any} a @return {Boolean} */\nconst isKey = a => !globals.defaults.hasOwnProperty(a);\n\n// Number\n\n/**\n * @param  {Number|String} str\n * @return {Number}\n */\nconst parseNumber = str => isStr(str) ? parseFloat(/** @type {String} */str) : (/** @type {Number} */str);\n\n// Math\n\nconst pow = Math.pow;\nconst sqrt = Math.sqrt;\nconst sin = Math.sin;\nconst cos = Math.cos;\nconst abs = Math.abs;\nconst exp = Math.exp;\nconst ceil = Math.ceil;\nconst floor = Math.floor;\nconst asin = Math.asin;\nconst max = Math.max;\nconst atan2 = Math.atan2;\nconst PI = Math.PI;\nconst _round = Math.round;\n\n/**\n * @param  {Number} v\n * @param  {Number} min\n * @param  {Number} max\n * @return {Number}\n */\nconst clamp = (v, min, max) => v < min ? min : v > max ? max : v;\nconst powCache = {};\n\n/**\n * @param  {Number} v\n * @param  {Number} decimalLength\n * @return {Number}\n */\nconst round = (v, decimalLength) => {\n  if (decimalLength < 0) return v;\n  if (!decimalLength) return _round(v);\n  let p = powCache[decimalLength];\n  if (!p) p = powCache[decimalLength] = 10 ** decimalLength;\n  return _round(v * p) / p;\n};\n\n/**\n * @param  {Number} v\n * @param  {Number|Array<Number>} increment\n * @return {Number}\n */\nconst snap = (v, increment) => isArr(increment) ? increment.reduce((closest, cv) => abs(cv - v) < abs(closest - v) ? cv : closest) : increment ? _round(v / increment) * increment : v;\n\n/**\n * @param  {Number} start\n * @param  {Number} end\n * @param  {Number} progress\n * @return {Number}\n */\nconst interpolate = (start, end, progress) => start + (end - start) * progress;\n\n/**\n * @param  {Number} min\n * @param  {Number} max\n * @param  {Number} [decimalLength]\n * @return {Number}\n */\nconst random = (min, max, decimalLength) => {\n  const m = 10 ** (decimalLength || 0);\n  return floor((Math.random() * (max - min + 1 / m) + min) * m) / m;\n};\n\n/**\n * Adapted from https://bost.ocks.org/mike/shuffle/\n * @param  {Array} items\n * @return {Array}\n */\nconst shuffle = items => {\n  let m = items.length,\n    t,\n    i;\n  while (m) {\n    i = random(0, --m);\n    t = items[m];\n    items[m] = items[i];\n    items[i] = t;\n  }\n  return items;\n};\n\n/**\n * @param  {Number} v\n * @return {Number}\n */\nconst clampInfinity = v => v === Infinity ? maxValue : v === -Infinity ? -1e12 : v;\n\n/**\n * @param  {Number} v\n * @return {Number}\n */\nconst normalizeTime = v => v <= minValue ? minValue : clampInfinity(round(v, 11));\n\n// Arrays\n\n/**\n * @template T\n * @param {T[]} a\n * @return {T[]}\n */\nconst cloneArray = a => isArr(a) ? [...a] : a;\n\n// Objects\n\n/**\n * @template T\n * @template U\n * @param {T} o1\n * @param {U} o2\n * @return {T & U}\n */\nconst mergeObjects = (o1, o2) => {\n  const merged = /** @type {T & U} */{\n    ...o1\n  };\n  for (let p in o2) {\n    const o1p = /** @type {T & U} */o1[p];\n    merged[p] = isUnd(o1p) ? /** @type {T & U} */o2[p] : o1p;\n  }\n  return merged;\n};\n\n// Linked lists\n\n/**\n * @param {Object} parent\n * @param {Function} callback\n * @param {Boolean} [reverse]\n * @param {String} [prevProp]\n * @param {String} [nextProp]\n * @return {void}\n */\nconst forEachChildren = (parent, callback, reverse, prevProp = '_prev', nextProp = '_next') => {\n  let next = parent._head;\n  let adjustedNextProp = nextProp;\n  if (reverse) {\n    next = parent._tail;\n    adjustedNextProp = prevProp;\n  }\n  while (next) {\n    const currentNext = next[adjustedNextProp];\n    callback(next);\n    next = currentNext;\n  }\n};\n\n/**\n * @param  {Object} parent\n * @param  {Object} child\n * @param  {String} [prevProp]\n * @param  {String} [nextProp]\n * @return {void}\n */\nconst removeChild = (parent, child, prevProp = '_prev', nextProp = '_next') => {\n  const prev = child[prevProp];\n  const next = child[nextProp];\n  prev ? prev[nextProp] = next : parent._head = next;\n  next ? next[prevProp] = prev : parent._tail = prev;\n  child[prevProp] = null;\n  child[nextProp] = null;\n};\n\n/**\n * @param  {Object} parent\n * @param  {Object} child\n * @param  {Function} [sortMethod]\n * @param  {String} prevProp\n * @param  {String} nextProp\n * @return {void}\n */\nconst addChild = (parent, child, sortMethod, prevProp = '_prev', nextProp = '_next') => {\n  let prev = parent._tail;\n  while (prev && sortMethod && sortMethod(prev, child)) prev = prev[prevProp];\n  const next = prev ? prev[nextProp] : parent._head;\n  prev ? prev[nextProp] = child : parent._head = child;\n  next ? next[prevProp] = child : parent._tail = child;\n  child[prevProp] = prev;\n  child[nextProp] = next;\n};\n\n/**\n * @param  {(...args: any[]) => Tickable | ((...args: any[]) => void)} constructor\n * @return {(...args: any[]) => Tickable | ((...args: any[]) => void)}\n */\nconst createRefreshable = constructor => {\n  /** @type {Tickable} */\n  let tracked;\n  return (...args) => {\n    let currentIteration, currentIterationProgress, reversed, alternate;\n    if (tracked) {\n      currentIteration = tracked.currentIteration;\n      currentIterationProgress = tracked.iterationProgress;\n      reversed = tracked.reversed;\n      alternate = tracked._alternate;\n      tracked.revert();\n    }\n    const cleanup = constructor(...args);\n    if (cleanup && !isFnc(cleanup) && cleanup.revert) tracked = cleanup;\n    if (!isUnd(currentIterationProgress)) {\n      /** @type {Tickable} */tracked.currentIteration = currentIteration;\n      /** @type {Tickable} */\n      tracked.iterationProgress = (alternate ? !(currentIteration % 2) ? reversed : !reversed : reversed) ? 1 - currentIterationProgress : currentIterationProgress;\n    }\n    return cleanup || noop;\n  };\n};\n\n/*\n * Base class to control framerate and playback rate.\n * Inherited by Engine, Timer, Animation and Timeline.\n */\nclass Clock {\n  /** @param {Number} [initTime] */\n  constructor(initTime = 0) {\n    /** @type {Number} */\n    this.deltaTime = 0;\n    /** @type {Number} */\n    this._currentTime = initTime;\n    /** @type {Number} */\n    this._elapsedTime = initTime;\n    /** @type {Number} */\n    this._startTime = initTime;\n    /** @type {Number} */\n    this._lastTime = initTime;\n    /** @type {Number} */\n    this._scheduledTime = 0;\n    /** @type {Number} */\n    this._frameDuration = round(K / maxFps, 0);\n    /** @type {Number} */\n    this._fps = maxFps;\n    /** @type {Number} */\n    this._speed = 1;\n    /** @type {Boolean} */\n    this._hasChildren = false;\n    /** @type {Tickable|Tween} */\n    this._head = null;\n    /** @type {Tickable|Tween} */\n    this._tail = null;\n  }\n  get fps() {\n    return this._fps;\n  }\n  set fps(frameRate) {\n    const previousFrameDuration = this._frameDuration;\n    const fr = +frameRate;\n    const fps = fr < minValue ? minValue : fr;\n    const frameDuration = round(K / fps, 0);\n    this._fps = fps;\n    this._frameDuration = frameDuration;\n    this._scheduledTime += frameDuration - previousFrameDuration;\n  }\n  get speed() {\n    return this._speed;\n  }\n  set speed(playbackRate) {\n    const pbr = +playbackRate;\n    this._speed = pbr < minValue ? minValue : pbr;\n  }\n\n  /**\n   * @param  {Number} time\n   * @return {tickModes}\n   */\n  requestTick(time) {\n    const scheduledTime = this._scheduledTime;\n    const elapsedTime = this._elapsedTime;\n    this._elapsedTime += time - elapsedTime;\n    // If the elapsed time is lower than the scheduled time\n    // this means not enough time has passed to hit one frameDuration\n    // so skip that frame\n    if (elapsedTime < scheduledTime) return tickModes.NONE;\n    const frameDuration = this._frameDuration;\n    const frameDelta = elapsedTime - scheduledTime;\n    // Ensures that _scheduledTime progresses in steps of at least 1 frameDuration.\n    // Skips ahead if the actual elapsed time is higher.\n    this._scheduledTime += frameDelta < frameDuration ? frameDuration : frameDelta;\n    return tickModes.AUTO;\n  }\n\n  /**\n   * @param  {Number} time\n   * @return {Number}\n   */\n  computeDeltaTime(time) {\n    const delta = time - this._lastTime;\n    this.deltaTime = delta;\n    this._lastTime = time;\n    return delta;\n  }\n}\n\n/**\n * @param  {Tickable} tickable\n * @param  {Number} time\n * @param  {Number} muteCallbacks\n * @param  {Number} internalRender\n * @param  {tickModes} tickMode\n * @return {Number}\n */\nconst render = (tickable, time, muteCallbacks, internalRender, tickMode) => {\n  const parent = tickable.parent;\n  const duration = tickable.duration;\n  const completed = tickable.completed;\n  const iterationDuration = tickable.iterationDuration;\n  const iterationCount = tickable.iterationCount;\n  const _currentIteration = tickable._currentIteration;\n  const _loopDelay = tickable._loopDelay;\n  const _reversed = tickable._reversed;\n  const _alternate = tickable._alternate;\n  const _hasChildren = tickable._hasChildren;\n  const tickableDelay = tickable._delay;\n  const tickablePrevAbsoluteTime = tickable._currentTime; // TODO: rename ._currentTime to ._absoluteCurrentTime\n\n  const tickableEndTime = tickableDelay + iterationDuration;\n  const tickableAbsoluteTime = time - tickableDelay;\n  const tickablePrevTime = clamp(tickablePrevAbsoluteTime, -tickableDelay, duration);\n  const tickableCurrentTime = clamp(tickableAbsoluteTime, -tickableDelay, duration);\n  const deltaTime = tickableAbsoluteTime - tickablePrevAbsoluteTime;\n  const isCurrentTimeAboveZero = tickableCurrentTime > 0;\n  const isCurrentTimeEqualOrAboveDuration = tickableCurrentTime >= duration;\n  const isSetter = duration <= minValue;\n  const forcedTick = tickMode === tickModes.FORCE;\n  let isOdd = 0;\n  let iterationElapsedTime = tickableAbsoluteTime;\n  // Render checks\n  // Used to also check if the children have rendered in order to trigger the onRender callback on the parent timer\n  let hasRendered = 0;\n\n  // Execute the \"expensive\" iterations calculations only when necessary\n  if (iterationCount > 1) {\n    // bitwise NOT operator seems to be generally faster than Math.floor() across browsers\n    const currentIteration = ~~(tickableCurrentTime / (iterationDuration + (isCurrentTimeEqualOrAboveDuration ? 0 : _loopDelay)));\n    tickable._currentIteration = clamp(currentIteration, 0, iterationCount);\n    // Prevent the iteration count to go above the max iterations when reaching the end of the animation\n    if (isCurrentTimeEqualOrAboveDuration) tickable._currentIteration--;\n    isOdd = tickable._currentIteration % 2;\n    iterationElapsedTime = tickableCurrentTime % (iterationDuration + _loopDelay) || 0;\n  }\n\n  // Checks if exactly one of _reversed and (_alternate && isOdd) is true\n  const isReversed = _reversed ^ (_alternate && isOdd);\n  const _ease = /** @type {Renderable} */tickable._ease;\n  let iterationTime = isCurrentTimeEqualOrAboveDuration ? isReversed ? 0 : duration : isReversed ? iterationDuration - iterationElapsedTime : iterationElapsedTime;\n  if (_ease) iterationTime = iterationDuration * _ease(iterationTime / iterationDuration) || 0;\n  const isRunningBackwards = (parent ? parent.backwards : tickableAbsoluteTime < tickablePrevAbsoluteTime) ? !isReversed : !!isReversed;\n  tickable._currentTime = tickableAbsoluteTime;\n  tickable._iterationTime = iterationTime;\n  tickable.backwards = isRunningBackwards;\n  if (isCurrentTimeAboveZero && !tickable.began) {\n    tickable.began = true;\n    if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {\n      tickable.onBegin(/** @type {CallbackArgument} */tickable);\n    }\n  } else if (tickableAbsoluteTime <= 0) {\n    tickable.began = false;\n  }\n\n  // Only triggers onLoop for tickable without children, otherwise call the the onLoop callback in the tick function\n  // Make sure to trigger the onLoop before rendering to allow .refresh() to pickup the current values\n  if (!muteCallbacks && !_hasChildren && isCurrentTimeAboveZero && tickable._currentIteration !== _currentIteration) {\n    tickable.onLoop(/** @type {CallbackArgument} */tickable);\n  }\n  if (forcedTick || tickMode === tickModes.AUTO && (time >= tickableDelay && time <= tickableEndTime ||\n  // Normal render\n  time <= tickableDelay && tickablePrevTime > tickableDelay ||\n  // Playhead is before the animation start time so make sure the animation is at its initial state\n  time >= tickableEndTime && tickablePrevTime !== duration // Playhead is after the animation end time so make sure the animation is at its end state\n  ) || iterationTime >= tickableEndTime && tickablePrevTime !== duration || iterationTime <= tickableDelay && tickablePrevTime > 0 || time <= tickablePrevTime && tickablePrevTime === duration && completed ||\n  // Force a render if a seek occurs on an completed animation\n  isCurrentTimeEqualOrAboveDuration && !completed && isSetter // This prevents 0 duration tickables to be skipped\n  ) {\n    if (isCurrentTimeAboveZero) {\n      // Trigger onUpdate callback before rendering\n      tickable.computeDeltaTime(tickablePrevTime);\n      if (!muteCallbacks) tickable.onBeforeUpdate(/** @type {CallbackArgument} */tickable);\n    }\n\n    // Start tweens rendering\n    if (!_hasChildren) {\n      // Time has jumped more than globals.tickThreshold so consider this tick manual\n      const forcedRender = forcedTick || (isRunningBackwards ? deltaTime * -1 : deltaTime) >= globals.tickThreshold;\n      const absoluteTime = tickable._offset + (parent ? parent._offset : 0) + tickableDelay + iterationTime;\n\n      // Only Animation can have tweens, Timer returns undefined\n      let tween = /** @type {Tween} */ /** @type {JSAnimation} */tickable._head;\n      let tweenTarget;\n      let tweenStyle;\n      let tweenTargetTransforms;\n      let tweenTargetTransformsProperties;\n      let tweenTransformsNeedUpdate = 0;\n      while (tween) {\n        const tweenComposition = tween._composition;\n        const tweenCurrentTime = tween._currentTime;\n        const tweenChangeDuration = tween._changeDuration;\n        const tweenAbsEndTime = tween._absoluteStartTime + tween._changeDuration;\n        const tweenNextRep = tween._nextRep;\n        const tweenPrevRep = tween._prevRep;\n        const tweenHasComposition = tweenComposition !== compositionTypes.none;\n        if ((forcedRender || (tweenCurrentTime !== tweenChangeDuration || absoluteTime <= tweenAbsEndTime + (tweenNextRep ? tweenNextRep._delay : 0)) && (tweenCurrentTime !== 0 || absoluteTime >= tween._absoluteStartTime)) && (!tweenHasComposition || !tween._isOverridden && (!tween._isOverlapped || absoluteTime <= tweenAbsEndTime) && (!tweenNextRep || tweenNextRep._isOverridden || absoluteTime <= tweenNextRep._absoluteStartTime) && (!tweenPrevRep || tweenPrevRep._isOverridden || absoluteTime >= tweenPrevRep._absoluteStartTime + tweenPrevRep._changeDuration + tween._delay))) {\n          const tweenNewTime = tween._currentTime = clamp(iterationTime - tween._startTime, 0, tweenChangeDuration);\n          const tweenProgress = tween._ease(tweenNewTime / tween._updateDuration);\n          const tweenModifier = tween._modifier;\n          const tweenValueType = tween._valueType;\n          const tweenType = tween._tweenType;\n          const tweenIsObject = tweenType === tweenTypes.OBJECT;\n          const tweenIsNumber = tweenValueType === valueTypes.NUMBER;\n          // Only round the in-between frames values if the final value is a string\n          const tweenPrecision = tweenIsNumber && tweenIsObject || tweenProgress === 0 || tweenProgress === 1 ? -1 : globals.precision;\n\n          // Recompose tween value\n          /** @type {String|Number} */\n          let value;\n          /** @type {Number} */\n          let number;\n          if (tweenIsNumber) {\n            value = number = /** @type {Number} */tweenModifier(round(interpolate(tween._fromNumber, tween._toNumber, tweenProgress), tweenPrecision));\n          } else if (tweenValueType === valueTypes.UNIT) {\n            // Rounding the values speed up string composition\n            number = /** @type {Number} */tweenModifier(round(interpolate(tween._fromNumber, tween._toNumber, tweenProgress), tweenPrecision));\n            value = `${number}${tween._unit}`;\n          } else if (tweenValueType === valueTypes.COLOR) {\n            const fn = tween._fromNumbers;\n            const tn = tween._toNumbers;\n            const r = round(clamp(/** @type {Number} */tweenModifier(interpolate(fn[0], tn[0], tweenProgress)), 0, 255), 0);\n            const g = round(clamp(/** @type {Number} */tweenModifier(interpolate(fn[1], tn[1], tweenProgress)), 0, 255), 0);\n            const b = round(clamp(/** @type {Number} */tweenModifier(interpolate(fn[2], tn[2], tweenProgress)), 0, 255), 0);\n            const a = clamp(/** @type {Number} */tweenModifier(round(interpolate(fn[3], tn[3], tweenProgress), tweenPrecision)), 0, 1);\n            value = `rgba(${r},${g},${b},${a})`;\n            if (tweenHasComposition) {\n              const ns = tween._numbers;\n              ns[0] = r;\n              ns[1] = g;\n              ns[2] = b;\n              ns[3] = a;\n            }\n          } else if (tweenValueType === valueTypes.COMPLEX) {\n            value = tween._strings[0];\n            for (let j = 0, l = tween._toNumbers.length; j < l; j++) {\n              const n = /** @type {Number} */tweenModifier(round(interpolate(tween._fromNumbers[j], tween._toNumbers[j], tweenProgress), tweenPrecision));\n              const s = tween._strings[j + 1];\n              value += `${s ? n + s : n}`;\n              if (tweenHasComposition) {\n                tween._numbers[j] = n;\n              }\n            }\n          }\n\n          // For additive tweens and Animatables\n          if (tweenHasComposition) {\n            tween._number = number;\n          }\n          if (!internalRender && tweenComposition !== compositionTypes.blend) {\n            const tweenProperty = tween.property;\n            tweenTarget = tween.target;\n            if (tweenIsObject) {\n              tweenTarget[tweenProperty] = value;\n            } else if (tweenType === tweenTypes.ATTRIBUTE) {\n              /** @type {DOMTarget} */tweenTarget.setAttribute(tweenProperty, /** @type {String} */value);\n            } else {\n              tweenStyle = /** @type {DOMTarget} */tweenTarget.style;\n              if (tweenType === tweenTypes.TRANSFORM) {\n                if (tweenTarget !== tweenTargetTransforms) {\n                  tweenTargetTransforms = tweenTarget;\n                  // NOTE: Referencing the cachedTransforms in the tween property directly can be a little bit faster but appears to increase memory usage.\n                  tweenTargetTransformsProperties = tweenTarget[transformsSymbol];\n                }\n                tweenTargetTransformsProperties[tweenProperty] = value;\n                tweenTransformsNeedUpdate = 1;\n              } else if (tweenType === tweenTypes.CSS) {\n                tweenStyle[tweenProperty] = value;\n              } else if (tweenType === tweenTypes.CSS_VAR) {\n                tweenStyle.setProperty(tweenProperty, /** @type {String} */value);\n              }\n            }\n            if (isCurrentTimeAboveZero) hasRendered = 1;\n          } else {\n            // Used for composing timeline tweens without having to do a real render\n            tween._value = value;\n          }\n        }\n\n        // NOTE: Possible improvement: Use translate(x,y) / translate3d(x,y,z) syntax\n        // to reduce memory usage on string composition\n        if (tweenTransformsNeedUpdate && tween._renderTransforms) {\n          let str = emptyString;\n          for (let key in tweenTargetTransformsProperties) {\n            str += `${transformsFragmentStrings[key]}${tweenTargetTransformsProperties[key]}) `;\n          }\n          tweenStyle.transform = str;\n          tweenTransformsNeedUpdate = 0;\n        }\n        tween = tween._next;\n      }\n      if (!muteCallbacks && hasRendered) {\n        /** @type {JSAnimation} */tickable.onRender(/** @type {JSAnimation} */tickable);\n      }\n    }\n    if (!muteCallbacks && isCurrentTimeAboveZero) {\n      tickable.onUpdate(/** @type {CallbackArgument} */tickable);\n    }\n  }\n\n  // End tweens rendering\n\n  // Handle setters on timeline differently and allow re-trigering the onComplete callback when seeking backwards\n  if (parent && isSetter) {\n    if (!muteCallbacks && (parent.began && !isRunningBackwards && tickableAbsoluteTime >= duration && !completed || isRunningBackwards && tickableAbsoluteTime <= minValue && completed)) {\n      tickable.onComplete(/** @type {CallbackArgument} */tickable);\n      tickable.completed = !isRunningBackwards;\n    }\n    // If currentTime is both above 0 and at least equals to duration, handles normal onComplete or infinite loops\n  } else if (isCurrentTimeAboveZero && isCurrentTimeEqualOrAboveDuration) {\n    if (iterationCount === Infinity) {\n      // Offset the tickable _startTime with its duration to reset _currentTime to 0 and continue the infinite timer\n      tickable._startTime += tickable.duration;\n    } else if (tickable._currentIteration >= iterationCount - 1) {\n      // By setting paused to true, we tell the engine loop to not render this tickable and removes it from the list on the next tick\n      tickable.paused = true;\n      if (!completed && !_hasChildren) {\n        // If the tickable has children, triggers onComplete() only when all children have completed in the tick function\n        tickable.completed = true;\n        if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {\n          tickable.onComplete(/** @type {CallbackArgument} */tickable);\n          tickable._resolve(/** @type {CallbackArgument} */tickable);\n        }\n      }\n    }\n    // Otherwise set the completed flag to false\n  } else {\n    tickable.completed = false;\n  }\n\n  // NOTE: hasRendered * direction (negative for backwards) this way we can remove the tickable.backwards property completly ?\n  return hasRendered;\n};\n\n/**\n * @param  {Tickable} tickable\n * @param  {Number} time\n * @param  {Number} muteCallbacks\n * @param  {Number} internalRender\n * @param  {Number} tickMode\n * @return {void}\n */\nconst tick = (tickable, time, muteCallbacks, internalRender, tickMode) => {\n  const _currentIteration = tickable._currentIteration;\n  render(tickable, time, muteCallbacks, internalRender, tickMode);\n  if (tickable._hasChildren) {\n    const tl = /** @type {Timeline} */tickable;\n    const tlIsRunningBackwards = tl.backwards;\n    const tlChildrenTime = internalRender ? time : tl._iterationTime;\n    const tlCildrenTickTime = now();\n    let tlChildrenHasRendered = 0;\n    let tlChildrenHaveCompleted = true;\n\n    // If the timeline has looped forward, we need to manually triggers children skipped callbacks\n    if (!internalRender && tl._currentIteration !== _currentIteration) {\n      const tlIterationDuration = tl.iterationDuration;\n      forEachChildren(tl, (/** @type {JSAnimation} */child) => {\n        if (!tlIsRunningBackwards) {\n          // Force an internal render to trigger the callbacks if the child has not completed on loop\n          if (!child.completed && !child.backwards && child._currentTime < child.iterationDuration) {\n            render(child, tlIterationDuration, muteCallbacks, 1, tickModes.FORCE);\n          }\n          // Reset their began and completed flags to allow retrigering callbacks on the next iteration\n          child.began = false;\n          child.completed = false;\n        } else {\n          const childDuration = child.duration;\n          const childStartTime = child._offset + child._delay;\n          const childEndTime = childStartTime + childDuration;\n          // Triggers the onComplete callback on reverse for children on the edges of the timeline\n          if (!muteCallbacks && childDuration <= minValue && (!childStartTime || childEndTime === tlIterationDuration)) {\n            child.onComplete(child);\n          }\n        }\n      });\n      if (!muteCallbacks) tl.onLoop(/** @type {CallbackArgument} */tl);\n    }\n    forEachChildren(tl, (/** @type {JSAnimation} */child) => {\n      const childTime = round((tlChildrenTime - child._offset) * child._speed, 12); // Rounding is needed when using seconds\n      const childTickMode = child._fps < tl._fps ? child.requestTick(tlCildrenTickTime) : tickMode;\n      tlChildrenHasRendered += render(child, childTime, muteCallbacks, internalRender, childTickMode);\n      if (!child.completed && tlChildrenHaveCompleted) tlChildrenHaveCompleted = false;\n    }, tlIsRunningBackwards);\n\n    // Renders on timeline are triggered by its children so it needs to be set after rendering the children\n    if (!muteCallbacks && tlChildrenHasRendered) tl.onRender(/** @type {CallbackArgument} */tl);\n\n    // Triggers the timeline onComplete() once all chindren all completed and the current time has reached the end\n    if ((tlChildrenHaveCompleted || tlIsRunningBackwards) && tl._currentTime >= tl.duration) {\n      // Make sure the paused flag is false in case it has been skipped in the render function\n      tl.paused = true;\n      if (!tl.completed) {\n        tl.completed = true;\n        if (!muteCallbacks) {\n          tl.onComplete(/** @type {CallbackArgument} */tl);\n          tl._resolve(/** @type {CallbackArgument} */tl);\n        }\n      }\n    }\n  }\n};\nconst additive = {\n  animation: null,\n  update: noop\n};\n\n/**\n * @typedef AdditiveAnimation\n * @property {Number} duration\n * @property {Number} _offset\n * @property {Number} _delay\n * @property {Tween} _head\n * @property {Tween} _tail\n */\n\n/**\n * @param  {TweenAdditiveLookups} lookups\n * @return {AdditiveAnimation}\n */\nconst addAdditiveAnimation = lookups => {\n  let animation = additive.animation;\n  if (!animation) {\n    animation = {\n      duration: minValue,\n      computeDeltaTime: noop,\n      _offset: 0,\n      _delay: 0,\n      _head: null,\n      _tail: null\n    };\n    additive.animation = animation;\n    additive.update = () => {\n      lookups.forEach(propertyAnimation => {\n        for (let propertyName in propertyAnimation) {\n          const tweens = propertyAnimation[propertyName];\n          const lookupTween = tweens._head;\n          if (lookupTween) {\n            const valueType = lookupTween._valueType;\n            const additiveValues = valueType === valueTypes.COMPLEX || valueType === valueTypes.COLOR ? cloneArray(lookupTween._fromNumbers) : null;\n            let additiveValue = lookupTween._fromNumber;\n            let tween = tweens._tail;\n            while (tween && tween !== lookupTween) {\n              if (additiveValues) {\n                for (let i = 0, l = tween._numbers.length; i < l; i++) additiveValues[i] += tween._numbers[i];\n              } else {\n                additiveValue += tween._number;\n              }\n              tween = tween._prevAdd;\n            }\n            lookupTween._toNumber = additiveValue;\n            lookupTween._toNumbers = additiveValues;\n          }\n        }\n      });\n      // TODO: Avoid polymorphism here, idealy the additive animation should be a regular animation with a higher priority in the render loop\n      render(animation, 1, 1, 0, tickModes.FORCE);\n    };\n  }\n  return animation;\n};\nconst engineTickMethod = /*#__PURE__*/(() => isBrowser ? requestAnimationFrame : setImmediate)();\nconst engineCancelMethod = /*#__PURE__*/(() => isBrowser ? cancelAnimationFrame : clearImmediate)();\nclass Engine extends Clock {\n  /** @param {Number} [initTime] */\n  constructor(initTime) {\n    super(initTime);\n    this.useDefaultMainLoop = true;\n    this.pauseOnDocumentHidden = true;\n    /** @type {DefaultsParams} */\n    this.defaults = defaults;\n    this.paused = isBrowser && doc.hidden ? true : false;\n    /** @type {Number|NodeJS.Immediate} */\n    this.reqId = null;\n  }\n  update() {\n    const time = this._currentTime = now();\n    if (this.requestTick(time)) {\n      this.computeDeltaTime(time);\n      const engineSpeed = this._speed;\n      const engineFps = this._fps;\n      let activeTickable = /** @type {Tickable} */this._head;\n      while (activeTickable) {\n        const nextTickable = activeTickable._next;\n        if (!activeTickable.paused) {\n          tick(activeTickable, (time - activeTickable._startTime) * activeTickable._speed * engineSpeed, 0,\n          // !muteCallbacks\n          0,\n          // !internalRender\n          activeTickable._fps < engineFps ? activeTickable.requestTick(time) : tickModes.AUTO);\n        } else {\n          removeChild(this, activeTickable);\n          this._hasChildren = !!this._tail;\n          activeTickable._running = false;\n          if (activeTickable.completed && !activeTickable._cancelled) {\n            activeTickable.cancel();\n          }\n        }\n        activeTickable = nextTickable;\n      }\n      additive.update();\n    }\n  }\n  wake() {\n    if (this.useDefaultMainLoop && !this.reqId && !this.paused) {\n      this.reqId = engineTickMethod(tickEngine);\n    }\n    return this;\n  }\n  pause() {\n    this.paused = true;\n    return killEngine();\n  }\n  resume() {\n    if (!this.paused) return;\n    this.paused = false;\n    forEachChildren(this, (/** @type {Tickable} */child) => child.resetTime());\n    return this.wake();\n  }\n\n  // Getter and setter for speed\n  get speed() {\n    return this._speed * (globals.timeScale === 1 ? 1 : K);\n  }\n  set speed(playbackRate) {\n    this._speed = playbackRate * globals.timeScale;\n    forEachChildren(this, (/** @type {Tickable} */child) => child.speed = child._speed);\n  }\n\n  // Getter and setter for timeUnit\n  get timeUnit() {\n    return globals.timeScale === 1 ? 'ms' : 's';\n  }\n  set timeUnit(unit) {\n    const secondsScale = 0.001;\n    const isSecond = unit === 's';\n    const newScale = isSecond ? secondsScale : 1;\n    if (globals.timeScale !== newScale) {\n      globals.timeScale = newScale;\n      globals.tickThreshold = 200 * newScale;\n      const scaleFactor = isSecond ? secondsScale : K;\n      /** @type {Number} */\n      this.defaults.duration *= scaleFactor;\n      this._speed *= scaleFactor;\n    }\n  }\n\n  // Getter and setter for precision\n  get precision() {\n    return globals.precision;\n  }\n  set precision(precision) {\n    globals.precision = precision;\n  }\n}\nconst engine = /*#__PURE__*/(() => {\n  const engine = new Engine(now());\n  if (isBrowser) {\n    globalVersions.engine = engine;\n    doc.addEventListener('visibilitychange', () => {\n      if (!engine.pauseOnDocumentHidden) return;\n      doc.hidden ? engine.pause() : engine.resume();\n    });\n  }\n  return engine;\n})();\nconst tickEngine = () => {\n  if (engine._head) {\n    engine.reqId = engineTickMethod(tickEngine);\n    engine.update();\n  } else {\n    engine.reqId = 0;\n  }\n};\nconst killEngine = () => {\n  engineCancelMethod(/** @type {NodeJS.Immediate & Number} */engine.reqId);\n  engine.reqId = 0;\n  return engine;\n};\n\n/**\n * @param  {DOMTarget} target\n * @param  {String} propName\n * @param  {Object} animationInlineStyles\n * @return {String}\n */\nconst parseInlineTransforms = (target, propName, animationInlineStyles) => {\n  const inlineTransforms = target.style.transform;\n  let inlinedStylesPropertyValue;\n  if (inlineTransforms) {\n    const cachedTransforms = target[transformsSymbol];\n    let t;\n    while (t = transformsExecRgx.exec(inlineTransforms)) {\n      const inlinePropertyName = t[1];\n      // const inlinePropertyValue = t[2];\n      const inlinePropertyValue = t[2].slice(1, -1);\n      cachedTransforms[inlinePropertyName] = inlinePropertyValue;\n      if (inlinePropertyName === propName) {\n        inlinedStylesPropertyValue = inlinePropertyValue;\n        // Store the new parsed inline styles if animationInlineStyles is provided\n        if (animationInlineStyles) {\n          animationInlineStyles[propName] = inlinePropertyValue;\n        }\n      }\n    }\n  }\n  return inlineTransforms && !isUnd(inlinedStylesPropertyValue) ? inlinedStylesPropertyValue : stringStartsWith(propName, 'scale') ? '1' : stringStartsWith(propName, 'rotate') || stringStartsWith(propName, 'skew') ? '0deg' : '0px';\n};\n\n/**\n * @param  {DOMTargetsParam|TargetsParam} v\n * @return {NodeList|HTMLCollection}\n */\nfunction getNodeList(v) {\n  const n = isStr(v) ? scope.root.querySelectorAll(v) : v;\n  if (n instanceof NodeList || n instanceof HTMLCollection) return n;\n}\n\n/**\n * @overload\n * @param  {DOMTargetsParam} targets\n * @return {DOMTargetsArray}\n *\n * @overload\n * @param  {JSTargetsParam} targets\n * @return {JSTargetsArray}\n *\n * @overload\n * @param  {TargetsParam} targets\n * @return {TargetsArray}\n *\n * @param  {DOMTargetsParam|JSTargetsParam|TargetsParam} targets\n */\nfunction parseTargets(targets) {\n  if (isNil(targets)) return /** @type {TargetsArray} */[];\n  if (isArr(targets)) {\n    const flattened = targets.flat(Infinity);\n    /** @type {TargetsArray} */\n    const parsed = [];\n    for (let i = 0, l = flattened.length; i < l; i++) {\n      const item = flattened[i];\n      if (!isNil(item)) {\n        const nodeList = getNodeList(item);\n        if (nodeList) {\n          for (let j = 0, jl = nodeList.length; j < jl; j++) {\n            const subItem = nodeList[j];\n            if (!isNil(subItem)) {\n              let isDuplicate = false;\n              for (let k = 0, kl = parsed.length; k < kl; k++) {\n                if (parsed[k] === subItem) {\n                  isDuplicate = true;\n                  break;\n                }\n              }\n              if (!isDuplicate) {\n                parsed.push(subItem);\n              }\n            }\n          }\n        } else {\n          let isDuplicate = false;\n          for (let j = 0, jl = parsed.length; j < jl; j++) {\n            if (parsed[j] === item) {\n              isDuplicate = true;\n              break;\n            }\n          }\n          if (!isDuplicate) {\n            parsed.push(item);\n          }\n        }\n      }\n    }\n    return parsed;\n  }\n  if (!isBrowser) return /** @type {JSTargetsArray} */[targets];\n  const nodeList = getNodeList(targets);\n  if (nodeList) return /** @type {DOMTargetsArray} */Array.from(nodeList);\n  return /** @type {TargetsArray} */[targets];\n}\n\n/**\n * @overload\n * @param  {DOMTargetsParam} targets\n * @return {DOMTargetsArray}\n *\n * @overload\n * @param  {JSTargetsParam} targets\n * @return {JSTargetsArray}\n *\n * @overload\n * @param  {TargetsParam} targets\n * @return {TargetsArray}\n *\n * @param  {DOMTargetsParam|JSTargetsParam|TargetsParam} targets\n */\nfunction registerTargets(targets) {\n  const parsedTargetsArray = parseTargets(targets);\n  const parsedTargetsLength = parsedTargetsArray.length;\n  if (parsedTargetsLength) {\n    for (let i = 0; i < parsedTargetsLength; i++) {\n      const target = parsedTargetsArray[i];\n      if (!target[isRegisteredTargetSymbol]) {\n        target[isRegisteredTargetSymbol] = true;\n        const isSvgType = isSvg(target);\n        const isDom = /** @type {DOMTarget} */target.nodeType || isSvgType;\n        if (isDom) {\n          target[isDomSymbol] = true;\n          target[isSvgSymbol] = isSvgType;\n          target[transformsSymbol] = {};\n        }\n      }\n    }\n  }\n  return parsedTargetsArray;\n}\n\n/**\n * @param  {TargetsParam} path\n * @return {SVGGeometryElement|undefined}\n */\nconst getPath = path => {\n  const parsedTargets = parseTargets(path);\n  const $parsedSvg = /** @type {SVGGeometryElement} */parsedTargets[0];\n  if (!$parsedSvg || !isSvg($parsedSvg)) return;\n  return $parsedSvg;\n};\n\n/**\n * @param  {TargetsParam} path2\n * @param  {Number} [precision]\n * @return {FunctionValue}\n */\nconst morphTo = (path2, precision = .33) => $path1 => {\n  const $path2 = /** @type {SVGGeometryElement} */getPath(path2);\n  if (!$path2) return;\n  const isPath = $path1.tagName === 'path';\n  const separator = isPath ? ' ' : ',';\n  const previousPoints = $path1[morphPointsSymbol];\n  if (previousPoints) $path1.setAttribute(isPath ? 'd' : 'points', previousPoints);\n  let v1 = '',\n    v2 = '';\n  if (!precision) {\n    v1 = $path1.getAttribute(isPath ? 'd' : 'points');\n    v2 = $path2.getAttribute(isPath ? 'd' : 'points');\n  } else {\n    const length1 = /** @type {SVGGeometryElement} */$path1.getTotalLength();\n    const length2 = $path2.getTotalLength();\n    const maxPoints = Math.max(Math.ceil(length1 * precision), Math.ceil(length2 * precision));\n    for (let i = 0; i < maxPoints; i++) {\n      const t = i / (maxPoints - 1);\n      const pointOnPath1 = /** @type {SVGGeometryElement} */$path1.getPointAtLength(length1 * t);\n      const pointOnPath2 = $path2.getPointAtLength(length2 * t);\n      const prefix = isPath ? i === 0 ? 'M' : 'L' : '';\n      v1 += prefix + round(pointOnPath1.x, 3) + separator + pointOnPath1.y + ' ';\n      v2 += prefix + round(pointOnPath2.x, 3) + separator + pointOnPath2.y + ' ';\n    }\n  }\n  $path1[morphPointsSymbol] = v2;\n  return [v1, v2];\n};\n\n/**\n * @param {SVGGeometryElement} [$el]\n * @return {Number}\n */\nconst getScaleFactor = $el => {\n  let scaleFactor = 1;\n  if ($el && $el.getCTM) {\n    const ctm = $el.getCTM();\n    if (ctm) {\n      const scaleX = sqrt(ctm.a * ctm.a + ctm.b * ctm.b);\n      const scaleY = sqrt(ctm.c * ctm.c + ctm.d * ctm.d);\n      scaleFactor = (scaleX + scaleY) / 2;\n    }\n  }\n  return scaleFactor;\n};\n\n/**\n * Creates a proxy that wraps an SVGGeometryElement and adds drawing functionality.\n * @param {SVGGeometryElement} $el - The SVG element to transform into a drawable\n * @param {number} start - Starting position (0-1)\n * @param {number} end - Ending position (0-1)\n * @return {DrawableSVGGeometry} - Returns a proxy that preserves the original element's type with additional 'draw' attribute functionality\n */\nconst createDrawableProxy = ($el, start, end) => {\n  const pathLength = K;\n  const computedStyles = getComputedStyle($el);\n  const strokeLineCap = computedStyles.strokeLinecap;\n  // @ts-ignore\n  const $scalled = computedStyles.vectorEffect === 'non-scaling-stroke' ? $el : null;\n  let currentCap = strokeLineCap;\n  const proxy = new Proxy($el, {\n    get(target, property) {\n      const value = target[property];\n      if (property === proxyTargetSymbol) return target;\n      if (property === 'setAttribute') {\n        return (...args) => {\n          if (args[0] === 'draw') {\n            const value = args[1];\n            const values = value.split(' ');\n            const v1 = +values[0];\n            const v2 = +values[1];\n            // TOTO: Benchmark if performing two slices is more performant than one split\n            // const spaceIndex = value.indexOf(' ');\n            // const v1 = round(+value.slice(0, spaceIndex), precision);\n            // const v2 = round(+value.slice(spaceIndex + 1), precision);\n            const scaleFactor = getScaleFactor($scalled);\n            const os = v1 * -1e3 * scaleFactor;\n            const d1 = v2 * pathLength * scaleFactor + os;\n            const d2 = pathLength * scaleFactor + (v1 === 0 && v2 === 1 || v1 === 1 && v2 === 0 ? 0 : 10 * scaleFactor) - d1;\n            if (strokeLineCap !== 'butt') {\n              const newCap = v1 === v2 ? 'butt' : strokeLineCap;\n              if (currentCap !== newCap) {\n                target.style.strokeLinecap = `${newCap}`;\n                currentCap = newCap;\n              }\n            }\n            target.setAttribute('stroke-dashoffset', `${os}`);\n            target.setAttribute('stroke-dasharray', `${d1} ${d2}`);\n          }\n          return Reflect.apply(value, target, args);\n        };\n      }\n      if (isFnc(value)) {\n        return (...args) => Reflect.apply(value, target, args);\n      } else {\n        return value;\n      }\n    }\n  });\n  if ($el.getAttribute('pathLength') !== `${pathLength}`) {\n    $el.setAttribute('pathLength', `${pathLength}`);\n    proxy.setAttribute('draw', `${start} ${end}`);\n  }\n  return /** @type {DrawableSVGGeometry} */proxy;\n};\n\n/**\n * Creates drawable proxies for multiple SVG elements.\n * @param {TargetsParam} selector - CSS selector, SVG element, or array of elements and selectors\n * @param {number} [start=0] - Starting position (0-1)\n * @param {number} [end=0] - Ending position (0-1)\n * @return {Array<DrawableSVGGeometry>} - Array of proxied elements with drawing functionality\n */\nconst createDrawable = (selector, start = 0, end = 0) => {\n  const els = parseTargets(selector);\n  return els.map($el => createDrawableProxy(/** @type {SVGGeometryElement} */$el, start, end));\n};\n\n// Motion path animation\n\n/**\n * @param {SVGGeometryElement} $path\n * @param {Number} progress\n * @param {Number}lookup\n * @return {DOMPoint}\n */\nconst getPathPoint = ($path, progress, lookup = 0) => {\n  return $path.getPointAtLength(progress + lookup >= 1 ? progress + lookup : 0);\n};\n\n/**\n * @param {SVGGeometryElement} $path\n * @param {String} pathProperty\n * @return {FunctionValue}\n */\nconst getPathProgess = ($path, pathProperty) => {\n  return $el => {\n    const totalLength = +$path.getTotalLength();\n    const inSvg = $el[isSvgSymbol];\n    const ctm = $path.getCTM();\n    /** @type {TweenObjectValue} */\n    return {\n      from: 0,\n      to: totalLength,\n      /** @type {TweenModifier} */\n      modifier: progress => {\n        if (pathProperty === 'a') {\n          const p0 = getPathPoint($path, progress, -1);\n          const p1 = getPathPoint($path, progress, 1);\n          return atan2(p1.y - p0.y, p1.x - p0.x) * 180 / PI;\n        } else {\n          const p = getPathPoint($path, progress, 0);\n          return pathProperty === 'x' ? inSvg || !ctm ? p.x : p.x * ctm.a + p.y * ctm.c + ctm.e : inSvg || !ctm ? p.y : p.x * ctm.b + p.y * ctm.d + ctm.f;\n        }\n      }\n    };\n  };\n};\n\n/**\n * @param {TargetsParam} path\n */\nconst createMotionPath = path => {\n  const $path = getPath(path);\n  if (!$path) return;\n  return {\n    translateX: getPathProgess($path, 'x'),\n    translateY: getPathProgess($path, 'y'),\n    rotate: getPathProgess($path, 'a')\n  };\n};\n\n// Check for valid SVG attribute\n\nconst cssReservedProperties = ['opacity', 'rotate', 'overflow', 'color'];\n\n/**\n * @param  {Target} el\n * @param  {String} propertyName\n * @return {Boolean}\n */\nconst isValidSVGAttribute = (el, propertyName) => {\n  // Return early and use CSS opacity animation instead (already better default values (opacity: 1 instead of 0)) and rotate should be considered a transform\n  if (cssReservedProperties.includes(propertyName)) return false;\n  if (el.getAttribute(propertyName) || propertyName in el) {\n    if (propertyName === 'scale') {\n      // Scale\n      const elParentNode = /** @type {SVGGeometryElement} */ /** @type {DOMTarget} */el.parentNode;\n      // Only consider scale as a valid SVG attribute on filter element\n      return elParentNode && elParentNode.tagName === 'filter';\n    }\n    return true;\n  }\n};\nconst svg = {\n  morphTo,\n  createMotionPath,\n  createDrawable\n};\n\n/**\n * RGB / RGBA Color value string -> RGBA values array\n * @param  {String} rgbValue\n * @return {ColorArray}\n */\nconst rgbToRgba = rgbValue => {\n  const rgba = rgbExecRgx.exec(rgbValue) || rgbaExecRgx.exec(rgbValue);\n  const a = !isUnd(rgba[4]) ? +rgba[4] : 1;\n  return [+rgba[1], +rgba[2], +rgba[3], a];\n};\n\n/**\n * HEX3 / HEX3A / HEX6 / HEX6A Color value string -> RGBA values array\n * @param  {String} hexValue\n * @return {ColorArray}\n */\nconst hexToRgba = hexValue => {\n  const hexLength = hexValue.length;\n  const isShort = hexLength === 4 || hexLength === 5;\n  return [+('0x' + hexValue[1] + hexValue[isShort ? 1 : 2]), +('0x' + hexValue[isShort ? 2 : 3] + hexValue[isShort ? 2 : 4]), +('0x' + hexValue[isShort ? 3 : 5] + hexValue[isShort ? 3 : 6]), hexLength === 5 || hexLength === 9 ? +(+('0x' + hexValue[isShort ? 4 : 7] + hexValue[isShort ? 4 : 8]) / 255).toFixed(3) : 1];\n};\n\n/**\n * @param  {Number} p\n * @param  {Number} q\n * @param  {Number} t\n * @return {Number}\n */\nconst hue2rgb = (p, q, t) => {\n  if (t < 0) t += 1;\n  if (t > 1) t -= 1;\n  return t < 1 / 6 ? p + (q - p) * 6 * t : t < 1 / 2 ? q : t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 : p;\n};\n\n/**\n * HSL / HSLA Color value string -> RGBA values array\n * @param  {String} hslValue\n * @return {ColorArray}\n */\nconst hslToRgba = hslValue => {\n  const hsla = hslExecRgx.exec(hslValue) || hslaExecRgx.exec(hslValue);\n  const h = +hsla[1] / 360;\n  const s = +hsla[2] / 100;\n  const l = +hsla[3] / 100;\n  const a = !isUnd(hsla[4]) ? +hsla[4] : 1;\n  let r, g, b;\n  if (s === 0) {\n    r = g = b = l;\n  } else {\n    const q = l < .5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    r = round(hue2rgb(p, q, h + 1 / 3) * 255, 0);\n    g = round(hue2rgb(p, q, h) * 255, 0);\n    b = round(hue2rgb(p, q, h - 1 / 3) * 255, 0);\n  }\n  return [r, g, b, a];\n};\n\n/**\n * All in one color converter that converts a color string value into an array of RGBA values\n * @param  {String} colorString\n * @return {ColorArray}\n */\nconst convertColorStringValuesToRgbaArray = colorString => {\n  return isRgb(colorString) ? rgbToRgba(colorString) : isHex(colorString) ? hexToRgba(colorString) : isHsl(colorString) ? hslToRgba(colorString) : [0, 0, 0, 1];\n};\n\n/**\n * @template T, D\n * @param {T|undefined} targetValue\n * @param {D} defaultValue\n * @return {T|D}\n */\nconst setValue = (targetValue, defaultValue) => {\n  return isUnd(targetValue) ? defaultValue : targetValue;\n};\n\n/**\n * @param  {TweenPropValue} value\n * @param  {Target} target\n * @param  {Number} index\n * @param  {Number} total\n * @param  {Object} [store]\n * @return {any}\n */\nconst getFunctionValue = (value, target, index, total, store) => {\n  if (isFnc(value)) {\n    const func = () => {\n      const computed = /** @type {Function} */value(target, index, total);\n      // Fallback to 0 if the function returns undefined / NaN / null / false / 0\n      return !isNaN(+computed) ? +computed : computed || 0;\n    };\n    if (store) {\n      store.func = func;\n    }\n    return func();\n  } else {\n    return value;\n  }\n};\n\n/**\n * @param  {Target} target\n * @param  {String} prop\n * @return {tweenTypes}\n */\nconst getTweenType = (target, prop) => {\n  return !target[isDomSymbol] ? tweenTypes.OBJECT :\n  // Handle SVG attributes\n  target[isSvgSymbol] && isValidSVGAttribute(target, prop) ? tweenTypes.ATTRIBUTE :\n  // Handle CSS Transform properties differently than CSS to allow individual animations\n  validTransforms.includes(prop) || shortTransforms.get(prop) ? tweenTypes.TRANSFORM :\n  // CSS variables\n  stringStartsWith(prop, '--') ? tweenTypes.CSS_VAR :\n  // All other CSS properties\n  prop in /** @type {DOMTarget} */target.style ? tweenTypes.CSS :\n  // Handle other DOM Attributes\n  prop in target ? tweenTypes.OBJECT : tweenTypes.ATTRIBUTE;\n};\n\n/**\n * @param  {DOMTarget} target\n * @param  {String} propName\n * @param  {Object} animationInlineStyles\n * @return {String}\n */\nconst getCSSValue = (target, propName, animationInlineStyles) => {\n  const inlineStyles = target.style[propName];\n  if (inlineStyles && animationInlineStyles) {\n    animationInlineStyles[propName] = inlineStyles;\n  }\n  const value = inlineStyles || getComputedStyle(target[proxyTargetSymbol] || target).getPropertyValue(propName);\n  return value === 'auto' ? '0' : value;\n};\n\n/**\n * @param {Target} target\n * @param {String} propName\n * @param {tweenTypes} [tweenType]\n * @param {Object|void} [animationInlineStyles]\n * @return {String|Number}\n */\nconst getOriginalAnimatableValue = (target, propName, tweenType, animationInlineStyles) => {\n  const type = !isUnd(tweenType) ? tweenType : getTweenType(target, propName);\n  return type === tweenTypes.OBJECT ? target[propName] || 0 : type === tweenTypes.ATTRIBUTE ? /** @type {DOMTarget} */target.getAttribute(propName) : type === tweenTypes.TRANSFORM ? parseInlineTransforms(/** @type {DOMTarget} */target, propName, animationInlineStyles) : type === tweenTypes.CSS_VAR ? getCSSValue(/** @type {DOMTarget} */target, propName, animationInlineStyles).trimStart() : getCSSValue(/** @type {DOMTarget} */target, propName, animationInlineStyles);\n};\n\n/**\n * @param  {Number} x\n * @param  {Number} y\n * @param  {String} operator\n * @return {Number}\n */\nconst getRelativeValue = (x, y, operator) => {\n  return operator === '-' ? x - y : operator === '+' ? x + y : x * y;\n};\n\n/** @return {TweenDecomposedValue} */\nconst createDecomposedValueTargetObject = () => {\n  return {\n    /** @type {valueTypes} */\n    t: valueTypes.NUMBER,\n    n: 0,\n    u: null,\n    o: null,\n    d: null,\n    s: null\n  };\n};\n\n/**\n * @param  {String|Number} rawValue\n * @param  {TweenDecomposedValue} targetObject\n * @return {TweenDecomposedValue}\n */\nconst decomposeRawValue = (rawValue, targetObject) => {\n  /** @type {valueTypes} */\n  targetObject.t = valueTypes.NUMBER;\n  targetObject.n = 0;\n  targetObject.u = null;\n  targetObject.o = null;\n  targetObject.d = null;\n  targetObject.s = null;\n  if (!rawValue) return targetObject;\n  const num = +rawValue;\n  if (!isNaN(num)) {\n    // It's a number\n    targetObject.n = num;\n    return targetObject;\n  } else {\n    // let str = /** @type {String} */(rawValue).trim();\n    let str = /** @type {String} */rawValue;\n    // Parsing operators (+=, -=, *=) manually is much faster than using regex here\n    if (str[1] === '=') {\n      targetObject.o = str[0];\n      str = str.slice(2);\n    }\n    // Skip exec regex if the value type is complex or color to avoid long regex backtracking\n    const unitMatch = str.includes(' ') ? false : unitsExecRgx.exec(str);\n    if (unitMatch) {\n      // Has a number and a unit\n      targetObject.t = valueTypes.UNIT;\n      targetObject.n = +unitMatch[1];\n      targetObject.u = unitMatch[2];\n      return targetObject;\n    } else if (targetObject.o) {\n      // Has an operator (+=, -=, *=)\n      targetObject.n = +str;\n      return targetObject;\n    } else if (isCol(str)) {\n      // Is a color\n      targetObject.t = valueTypes.COLOR;\n      targetObject.d = convertColorStringValuesToRgbaArray(str);\n      return targetObject;\n    } else {\n      // Is a more complex string (generally svg coords, calc() or filters CSS values)\n      const matchedNumbers = str.match(digitWithExponentRgx);\n      targetObject.t = valueTypes.COMPLEX;\n      targetObject.d = matchedNumbers ? matchedNumbers.map(Number) : [];\n      targetObject.s = str.split(digitWithExponentRgx) || [];\n      return targetObject;\n    }\n  }\n};\n\n/**\n * @param  {Tween} tween\n * @param  {TweenDecomposedValue} targetObject\n * @return {TweenDecomposedValue}\n */\nconst decomposeTweenValue = (tween, targetObject) => {\n  targetObject.t = tween._valueType;\n  targetObject.n = tween._toNumber;\n  targetObject.u = tween._unit;\n  targetObject.o = null;\n  targetObject.d = cloneArray(tween._toNumbers);\n  targetObject.s = cloneArray(tween._strings);\n  return targetObject;\n};\nconst decomposedOriginalValue = createDecomposedValueTargetObject();\nconst lookups = {\n  /** @type {TweenReplaceLookups} */\n  _rep: new WeakMap(),\n  /** @type {TweenAdditiveLookups} */\n  _add: new Map()\n};\n\n/**\n * @param  {Target} target\n * @param  {String} property\n * @param  {String} lookup\n * @return {TweenPropertySiblings}\n */\nconst getTweenSiblings = (target, property, lookup = '_rep') => {\n  const lookupMap = lookups[lookup];\n  let targetLookup = lookupMap.get(target);\n  if (!targetLookup) {\n    targetLookup = {};\n    lookupMap.set(target, targetLookup);\n  }\n  return targetLookup[property] ? targetLookup[property] : targetLookup[property] = {\n    _head: null,\n    _tail: null\n  };\n};\n\n/**\n * @param  {Tween} p\n * @param  {Tween} c\n * @return {Number|Boolean}\n */\nconst addTweenSortMethod = (p, c) => {\n  return p._isOverridden || p._absoluteStartTime > c._absoluteStartTime;\n};\n\n/**\n * @param {Tween} tween\n */\nconst overrideTween = tween => {\n  tween._isOverlapped = 1;\n  tween._isOverridden = 1;\n  tween._changeDuration = minValue;\n  tween._currentTime = minValue;\n};\n\n/**\n * @param  {Tween} tween\n * @param  {TweenPropertySiblings} siblings\n * @return {Tween}\n */\nconst composeTween = (tween, siblings) => {\n  const tweenCompositionType = tween._composition;\n\n  // Handle replaced tweens\n\n  if (tweenCompositionType === compositionTypes.replace) {\n    const tweenAbsStartTime = tween._absoluteStartTime;\n    addChild(siblings, tween, addTweenSortMethod, '_prevRep', '_nextRep');\n    const prevSibling = tween._prevRep;\n\n    // Update the previous siblings for composition replace tweens\n\n    if (prevSibling) {\n      const prevParent = prevSibling.parent;\n      const prevAbsEndTime = prevSibling._absoluteStartTime + prevSibling._changeDuration;\n\n      // Handle looped animations tween\n\n      if (\n      // Check if the previous tween is from a different animation\n      tween.parent.id !== prevParent.id &&\n      // Check if the animation has loops\n      prevParent.iterationCount > 1 &&\n      // Check if _absoluteChangeEndTime of last loop overlaps the current tween\n      prevAbsEndTime + (prevParent.duration - prevParent.iterationDuration) > tweenAbsStartTime) {\n        // TODO: Find a way to only override the iterations overlapping with the tween\n        overrideTween(prevSibling);\n        let prevPrevSibling = prevSibling._prevRep;\n\n        // If the tween was part of a set of keyframes, override its siblings\n        while (prevPrevSibling && prevPrevSibling.parent.id === prevParent.id) {\n          overrideTween(prevPrevSibling);\n          prevPrevSibling = prevPrevSibling._prevRep;\n        }\n      }\n      const absoluteUpdateStartTime = tweenAbsStartTime - tween._delay;\n      if (prevAbsEndTime > absoluteUpdateStartTime) {\n        const prevChangeStartTime = prevSibling._startTime;\n        const prevTLOffset = prevAbsEndTime - (prevChangeStartTime + prevSibling._updateDuration);\n        prevSibling._changeDuration = absoluteUpdateStartTime - prevTLOffset - prevChangeStartTime;\n        prevSibling._currentTime = prevSibling._changeDuration;\n        prevSibling._isOverlapped = 1;\n        if (prevSibling._changeDuration < minValue) {\n          overrideTween(prevSibling);\n        }\n      }\n\n      // Pause (and cancel) the parent if it only contains overlapped tweens\n\n      let pausePrevParentAnimation = true;\n      forEachChildren(prevParent, (/** @type Tween */t) => {\n        if (!t._isOverlapped) pausePrevParentAnimation = false;\n      });\n      if (pausePrevParentAnimation) {\n        const prevParentTL = prevParent.parent;\n        if (prevParentTL) {\n          let pausePrevParentTL = true;\n          forEachChildren(prevParentTL, (/** @type JSAnimation */a) => {\n            if (a !== prevParent) {\n              forEachChildren(a, (/** @type Tween */t) => {\n                if (!t._isOverlapped) pausePrevParentTL = false;\n              });\n            }\n          });\n          if (pausePrevParentTL) {\n            prevParentTL.cancel();\n          }\n        } else {\n          prevParent.cancel();\n          // Previously, calling .cancel() on a timeline child would affect the render order of other children\n          // Worked around this by marking it as .completed and using .pause() for safe removal in the engine loop\n          // This is no longer needed since timeline tween composition is now handled separatly\n          // Keeping this here for reference\n          // prevParent.completed = true;\n          // prevParent.pause();\n        }\n      }\n    }\n\n    // let nextSibling = tween._nextRep;\n\n    // // All the next siblings are automatically overridden\n\n    // if (nextSibling && nextSibling._absoluteStartTime >= tweenAbsStartTime) {\n    //   while (nextSibling) {\n    //     overrideTween(nextSibling);\n    //     nextSibling = nextSibling._nextRep;\n    //   }\n    // }\n\n    // if (nextSibling && nextSibling._absoluteStartTime < tweenAbsStartTime) {\n    //   while (nextSibling) {\n    //     overrideTween(nextSibling);\n    //     console.log(tween.id, nextSibling.id);\n    //     nextSibling = nextSibling._nextRep;\n    //   }\n    // }\n\n    // Handle additive tweens composition\n  } else if (tweenCompositionType === compositionTypes.blend) {\n    const additiveTweenSiblings = getTweenSiblings(tween.target, tween.property, '_add');\n    const additiveAnimation = addAdditiveAnimation(lookups._add);\n    let lookupTween = additiveTweenSiblings._head;\n    if (!lookupTween) {\n      lookupTween = {\n        ...tween\n      };\n      lookupTween._composition = compositionTypes.replace;\n      lookupTween._updateDuration = minValue;\n      lookupTween._startTime = 0;\n      lookupTween._numbers = cloneArray(tween._fromNumbers);\n      lookupTween._number = 0;\n      lookupTween._next = null;\n      lookupTween._prev = null;\n      addChild(additiveTweenSiblings, lookupTween);\n      addChild(additiveAnimation, lookupTween);\n    }\n\n    // Convert the values of TO to FROM and set TO to 0\n\n    const toNumber = tween._toNumber;\n    tween._fromNumber = lookupTween._fromNumber - toNumber;\n    tween._toNumber = 0;\n    tween._numbers = cloneArray(tween._fromNumbers);\n    tween._number = 0;\n    lookupTween._fromNumber = toNumber;\n    if (tween._toNumbers) {\n      const toNumbers = cloneArray(tween._toNumbers);\n      if (toNumbers) {\n        toNumbers.forEach((value, i) => {\n          tween._fromNumbers[i] = lookupTween._fromNumbers[i] - value;\n          tween._toNumbers[i] = 0;\n        });\n      }\n      lookupTween._fromNumbers = toNumbers;\n    }\n    addChild(additiveTweenSiblings, tween, null, '_prevAdd', '_nextAdd');\n  }\n  return tween;\n};\n\n/**\n * @param  {Tween} tween\n * @return {Tween}\n */\nconst removeTweenSliblings = tween => {\n  const tweenComposition = tween._composition;\n  if (tweenComposition !== compositionTypes.none) {\n    const tweenTarget = tween.target;\n    const tweenProperty = tween.property;\n    const replaceTweensLookup = lookups._rep;\n    const replaceTargetProps = replaceTweensLookup.get(tweenTarget);\n    const tweenReplaceSiblings = replaceTargetProps[tweenProperty];\n    removeChild(tweenReplaceSiblings, tween, '_prevRep', '_nextRep');\n    if (tweenComposition === compositionTypes.blend) {\n      const addTweensLookup = lookups._add;\n      const addTargetProps = addTweensLookup.get(tweenTarget);\n      if (!addTargetProps) return;\n      const additiveTweenSiblings = addTargetProps[tweenProperty];\n      const additiveAnimation = additive.animation;\n      removeChild(additiveTweenSiblings, tween, '_prevAdd', '_nextAdd');\n      // If only one tween is left in the additive lookup, it's the tween lookup\n      const lookupTween = additiveTweenSiblings._head;\n      if (lookupTween && lookupTween === additiveTweenSiblings._tail) {\n        removeChild(additiveTweenSiblings, lookupTween, '_prevAdd', '_nextAdd');\n        removeChild(additiveAnimation, lookupTween);\n        let shouldClean = true;\n        for (let prop in addTargetProps) {\n          if (addTargetProps[prop]._head) {\n            shouldClean = false;\n            break;\n          }\n        }\n        if (shouldClean) {\n          addTweensLookup.delete(tweenTarget);\n        }\n      }\n    }\n  }\n  return tween;\n};\n\n/**\n * @param  {Timer} timer\n * @return {Timer}\n */\nconst resetTimerProperties = timer => {\n  timer.paused = true;\n  timer.began = false;\n  timer.completed = false;\n  return timer;\n};\n\n/**\n * @param  {Timer} timer\n * @return {Timer}\n */\nconst reviveTimer = timer => {\n  if (!timer._cancelled) return timer;\n  if (timer._hasChildren) {\n    forEachChildren(timer, reviveTimer);\n  } else {\n    forEachChildren(timer, (/** @type {Tween} tween*/tween) => {\n      if (tween._composition !== compositionTypes.none) {\n        composeTween(tween, getTweenSiblings(tween.target, tween.property));\n      }\n    });\n  }\n  timer._cancelled = 0;\n  return timer;\n};\nlet timerId = 0;\n\n/**\n * Base class used to create Timers, Animations and Timelines\n */\nclass Timer extends Clock {\n  /**\n   * @param {TimerParams} [parameters]\n   * @param {Timeline} [parent]\n   * @param {Number} [parentPosition]\n   */\n  constructor(parameters = {}, parent = null, parentPosition = 0) {\n    super(0);\n    const {\n      id,\n      delay,\n      duration,\n      reversed,\n      alternate,\n      loop,\n      loopDelay,\n      autoplay,\n      frameRate,\n      playbackRate,\n      onComplete,\n      onLoop,\n      onPause,\n      onBegin,\n      onBeforeUpdate,\n      onUpdate\n    } = parameters;\n    if (scope.current) scope.current.register(this);\n    const timerInitTime = parent ? 0 : engine._elapsedTime;\n    const timerDefaults = parent ? parent.defaults : globals.defaults;\n    const timerDelay = /** @type {Number} */isFnc(delay) || isUnd(delay) ? timerDefaults.delay : +delay;\n    const timerDuration = isFnc(duration) || isUnd(duration) ? Infinity : +duration;\n    const timerLoop = setValue(loop, timerDefaults.loop);\n    const timerLoopDelay = setValue(loopDelay, timerDefaults.loopDelay);\n    const timerIterationCount = timerLoop === true || timerLoop === Infinity || /** @type {Number} */timerLoop < 0 ? Infinity : /** @type {Number} */timerLoop + 1;\n    let offsetPosition = 0;\n    if (parent) {\n      offsetPosition = parentPosition;\n    } else {\n      let startTime = now();\n      // Make sure to tick the engine once if suspended to avoid big gaps with the following offsetPosition calculation\n      if (engine.paused) {\n        engine.requestTick(startTime);\n        startTime = engine._elapsedTime;\n      }\n      offsetPosition = startTime - engine._startTime;\n    }\n\n    // Timer's parameters\n    this.id = !isUnd(id) ? id : ++timerId;\n    /** @type {Timeline} */\n    this.parent = parent;\n    // Total duration of the timer\n    this.duration = clampInfinity((timerDuration + timerLoopDelay) * timerIterationCount - timerLoopDelay) || minValue;\n    /** @type {Boolean} */\n    this.backwards = false;\n    /** @type {Boolean} */\n    this.paused = true;\n    /** @type {Boolean} */\n    this.began = false;\n    /** @type {Boolean} */\n    this.completed = false;\n    /** @type {Callback<this>} */\n    this.onBegin = onBegin || timerDefaults.onBegin;\n    /** @type {Callback<this>} */\n    this.onBeforeUpdate = onBeforeUpdate || timerDefaults.onBeforeUpdate;\n    /** @type {Callback<this>} */\n    this.onUpdate = onUpdate || timerDefaults.onUpdate;\n    /** @type {Callback<this>} */\n    this.onLoop = onLoop || timerDefaults.onLoop;\n    /** @type {Callback<this>} */\n    this.onPause = onPause || timerDefaults.onPause;\n    /** @type {Callback<this>} */\n    this.onComplete = onComplete || timerDefaults.onComplete;\n    /** @type {Number} */\n    this.iterationDuration = timerDuration; // Duration of one loop\n    /** @type {Number} */\n    this.iterationCount = timerIterationCount; // Number of loops\n    /** @type {Boolean|ScrollObserver} */\n    this._autoplay = parent ? false : setValue(autoplay, timerDefaults.autoplay);\n    /** @type {Number} */\n    this._offset = offsetPosition;\n    /** @type {Number} */\n    this._delay = timerDelay;\n    /** @type {Number} */\n    this._loopDelay = timerLoopDelay;\n    /** @type {Number} */\n    this._iterationTime = 0;\n    /** @type {Number} */\n    this._currentIteration = 0; // Current loop index\n    /** @type {Function} */\n    this._resolve = noop; // Used by .then()\n    /** @type {Boolean} */\n    this._running = false;\n    /** @type {Number} */\n    this._reversed = +setValue(reversed, timerDefaults.reversed);\n    /** @type {Number} */\n    this._reverse = this._reversed;\n    /** @type {Number} */\n    this._cancelled = 0;\n    /** @type {Boolean} */\n    this._alternate = setValue(alternate, timerDefaults.alternate);\n    /** @type {Renderable} */\n    this._prev = null;\n    /** @type {Renderable} */\n    this._next = null;\n\n    // Clock's parameters\n    /** @type {Number} */\n    this._elapsedTime = timerInitTime;\n    /** @type {Number} */\n    this._startTime = timerInitTime;\n    /** @type {Number} */\n    this._lastTime = timerInitTime;\n    /** @type {Number} */\n    this._fps = setValue(frameRate, timerDefaults.frameRate);\n    /** @type {Number} */\n    this._speed = setValue(playbackRate, timerDefaults.playbackRate);\n  }\n  get cancelled() {\n    return !!this._cancelled;\n  }\n\n  /** @param {Boolean} cancelled  */\n  set cancelled(cancelled) {\n    cancelled ? this.cancel() : this.reset(1).play();\n  }\n  get currentTime() {\n    return clamp(round(this._currentTime, globals.precision), -this._delay, this.duration);\n  }\n\n  /** @param {Number} time  */\n  set currentTime(time) {\n    const paused = this.paused;\n    // Pausing the timer is necessary to avoid time jumps on a running instance\n    this.pause().seek(+time);\n    if (!paused) this.resume();\n  }\n  get iterationCurrentTime() {\n    return round(this._iterationTime, globals.precision);\n  }\n\n  /** @param {Number} time  */\n  set iterationCurrentTime(time) {\n    this.currentTime = this.iterationDuration * this._currentIteration + time;\n  }\n  get progress() {\n    return clamp(round(this._currentTime / this.duration, 10), 0, 1);\n  }\n\n  /** @param {Number} progress  */\n  set progress(progress) {\n    this.currentTime = this.duration * progress;\n  }\n  get iterationProgress() {\n    return clamp(round(this._iterationTime / this.iterationDuration, 10), 0, 1);\n  }\n\n  /** @param {Number} progress  */\n  set iterationProgress(progress) {\n    const iterationDuration = this.iterationDuration;\n    this.currentTime = iterationDuration * this._currentIteration + iterationDuration * progress;\n  }\n  get currentIteration() {\n    return this._currentIteration;\n  }\n\n  /** @param {Number} iterationCount  */\n  set currentIteration(iterationCount) {\n    this.currentTime = this.iterationDuration * clamp(+iterationCount, 0, this.iterationCount - 1);\n  }\n  get reversed() {\n    return !!this._reversed;\n  }\n\n  /** @param {Boolean} reverse  */\n  set reversed(reverse) {\n    reverse ? this.reverse() : this.play();\n  }\n  get speed() {\n    return super.speed;\n  }\n\n  /** @param {Number} playbackRate  */\n  set speed(playbackRate) {\n    super.speed = playbackRate;\n    this.resetTime();\n  }\n\n  /**\n   * @param  {Number} internalRender\n   * @return {this}\n   */\n  reset(internalRender = 0) {\n    // If cancelled, revive the timer before rendering in order to have propertly composed tweens siblings\n    reviveTimer(this);\n    if (this._reversed && !this._reverse) this.reversed = false;\n    // Rendering before updating the completed flag to prevent skips and to make sure the properties are not overridden\n    // Setting the iterationTime at the end to force the rendering to happend backwards, otherwise calling .reset() on Timelines might not render children in the right order\n    // NOTE: This is only required for Timelines and might be better to move to the Timeline class?\n    this._iterationTime = this.iterationDuration;\n    // Set tickMode to tickModes.FORCE to force rendering\n    tick(this, 0, 1, internalRender, tickModes.FORCE);\n    // Reset timer properties after revive / render to make sure the props are not updated again\n    resetTimerProperties(this);\n    // Also reset children properties\n    if (this._hasChildren) {\n      forEachChildren(this, resetTimerProperties);\n    }\n    return this;\n  }\n\n  /**\n   * @param  {Number} internalRender\n   * @return {this}\n   */\n  init(internalRender = 0) {\n    this.fps = this._fps;\n    this.speed = this._speed;\n    // Manually calling .init() on timelines should render all children intial state\n    // Forces all children to render once then render to 0 when reseted\n    if (!internalRender && this._hasChildren) {\n      tick(this, this.duration, 1, internalRender, tickModes.FORCE);\n    }\n    this.reset(internalRender);\n    // Make sure to set autoplay to false to child timers so it doesn't attempt to autoplay / link\n    const autoplay = this._autoplay;\n    if (autoplay === true) {\n      this.resume();\n    } else if (autoplay && !isUnd(/** @type {ScrollObserver} */autoplay.linked)) {\n      /** @type {ScrollObserver} */autoplay.link(this);\n    }\n    return this;\n  }\n\n  /** @return {this} */\n  resetTime() {\n    const timeScale = 1 / (this._speed * engine._speed);\n    this._startTime = now() - (this._currentTime + this._delay) * timeScale;\n    return this;\n  }\n\n  /** @return {this} */\n  pause() {\n    if (this.paused) return this;\n    this.paused = true;\n    this.onPause(this);\n    return this;\n  }\n\n  /** @return {this} */\n  resume() {\n    if (!this.paused) return this;\n    this.paused = false;\n    // We can safely imediatly render a timer that has no duration and no children\n    if (this.duration <= minValue && !this._hasChildren) {\n      tick(this, minValue, 0, 0, tickModes.FORCE);\n    } else {\n      if (!this._running) {\n        addChild(engine, this);\n        engine._hasChildren = true;\n        this._running = true;\n      }\n      this.resetTime();\n      // Forces the timer to advance by at least one frame when the next tick occurs\n      this._startTime -= 12;\n      engine.wake();\n    }\n    return this;\n  }\n\n  /** @return {this} */\n  restart() {\n    return this.reset(0).resume();\n  }\n\n  /**\n   * @param  {Number} time\n   * @param  {Boolean|Number} [muteCallbacks]\n   * @param  {Boolean|Number} [internalRender]\n   * @return {this}\n   */\n  seek(time, muteCallbacks = 0, internalRender = 0) {\n    // Recompose the tween siblings in case the timer has been cancelled\n    reviveTimer(this);\n    // If you seek a completed animation, otherwise the next play will starts at 0\n    this.completed = false;\n    const isPaused = this.paused;\n    this.paused = true;\n    // timer, time, muteCallbacks, internalRender, tickMode\n    tick(this, time + this._delay, ~~muteCallbacks, ~~internalRender, tickModes.AUTO);\n    return isPaused ? this : this.resume();\n  }\n\n  /** @return {this} */\n  alternate() {\n    const reversed = this._reversed;\n    const count = this.iterationCount;\n    const duration = this.iterationDuration;\n    // Calculate the maximum iterations possible given the iteration duration\n    const iterations = count === Infinity ? floor(maxValue / duration) : count;\n    this._reversed = +(this._alternate && !(iterations % 2) ? reversed : !reversed);\n    if (count === Infinity) {\n      // Handle infinite loops to loop on themself\n      this.iterationProgress = this._reversed ? 1 - this.iterationProgress : this.iterationProgress;\n    } else {\n      this.seek(duration * iterations - this._currentTime);\n    }\n    this.resetTime();\n    return this;\n  }\n\n  /** @return {this} */\n  play() {\n    if (this._reversed) this.alternate();\n    return this.resume();\n  }\n\n  /** @return {this} */\n  reverse() {\n    if (!this._reversed) this.alternate();\n    return this.resume();\n  }\n\n  // TODO: Move all the animation / tweens / children related code to Animation / Timeline\n\n  /** @return {this} */\n  cancel() {\n    if (this._hasChildren) {\n      forEachChildren(this, (/** @type {Renderable} */child) => child.cancel(), true);\n    } else {\n      forEachChildren(this, removeTweenSliblings);\n    }\n    this._cancelled = 1;\n    // Pausing the timer removes it from the engine\n    return this.pause();\n  }\n\n  /**\n   * @param  {Number} newDuration\n   * @return {this}\n   */\n  stretch(newDuration) {\n    const currentDuration = this.duration;\n    const normlizedDuration = normalizeTime(newDuration);\n    if (currentDuration === normlizedDuration) return this;\n    const timeScale = newDuration / currentDuration;\n    const isSetter = newDuration <= minValue;\n    this.duration = isSetter ? minValue : normlizedDuration;\n    this.iterationDuration = isSetter ? minValue : normalizeTime(this.iterationDuration * timeScale);\n    this._offset *= timeScale;\n    this._delay *= timeScale;\n    this._loopDelay *= timeScale;\n    return this;\n  }\n\n  /**\n    * Cancels the timer by seeking it back to 0 and reverting the attached scroller if necessary\n    * @return {this}\n    */\n  revert() {\n    tick(this, 0, 1, 0, tickModes.AUTO);\n    const ap = /** @type {ScrollObserver} */this._autoplay;\n    if (ap && ap.linked && ap.linked === this) ap.revert();\n    return this.cancel();\n  }\n\n  /**\n    * Imediatly completes the timer, cancels it and triggers the onComplete callback\n    * @return {this}\n    */\n  complete() {\n    return this.seek(this.duration).cancel();\n  }\n\n  /**\n   * @param  {Callback<this>} [callback]\n   * @return {Promise}\n   */\n  then(callback = noop) {\n    const then = this.then;\n    const onResolve = () => {\n      // this.then = null prevents infinite recursion if returned by an async function\n      // https://github.com/juliangarnierorg/anime-beta/issues/26\n      this.then = null;\n      callback(this);\n      this.then = then;\n      this._resolve = noop;\n    };\n    return new Promise(r => {\n      this._resolve = () => r(onResolve());\n      // Make sure to resolve imediatly if the timer has already completed\n      if (this.completed) this._resolve();\n      return this;\n    });\n  }\n}\n\n/**\n * @param {TimerParams} [parameters]\n * @return {Timer}\n */\nconst createTimer = parameters => new Timer(parameters, null, 0).init();\n\n/** @type {EasingFunction} */\nconst none = t => t;\n\n// Cubic Bezier solver adapted from https://github.com/gre/bezier-ease © Gaëtan Renaudeau\n\n/**\n * @param  {Number} aT\n * @param  {Number} aA1\n * @param  {Number} aA2\n * @return {Number}\n */\nconst calcBezier = (aT, aA1, aA2) => (((1 - 3 * aA2 + 3 * aA1) * aT + (3 * aA2 - 6 * aA1)) * aT + 3 * aA1) * aT;\n\n/**\n * @param  {Number} aX\n * @param  {Number} mX1\n * @param  {Number} mX2\n * @return {Number}\n */\nconst binarySubdivide = (aX, mX1, mX2) => {\n  let aA = 0,\n    aB = 1,\n    currentX,\n    currentT,\n    i = 0;\n  do {\n    currentT = aA + (aB - aA) / 2;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (abs(currentX) > .0000001 && ++i < 100);\n  return currentT;\n};\n\n/**\n * @param  {Number} [mX1]\n * @param  {Number} [mY1]\n * @param  {Number} [mX2]\n * @param  {Number} [mY2]\n * @return {EasingFunction}\n */\n\nconst cubicBezier = (mX1 = 0.5, mY1 = 0.0, mX2 = 0.5, mY2 = 1.0) => mX1 === mY1 && mX2 === mY2 ? none : t => t === 0 || t === 1 ? t : calcBezier(binarySubdivide(t, mX1, mX2), mY1, mY2);\n\n/**\n * Steps ease implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function\n * Only covers 'end' and 'start' jumpterms\n * @param  {Number} steps\n * @param  {Boolean} [fromStart]\n * @return {EasingFunction}\n */\nconst steps = (steps = 10, fromStart) => {\n  const roundMethod = fromStart ? ceil : floor;\n  return t => roundMethod(clamp(t, 0, 1) * steps) * (1 / steps);\n};\n\n/**\n * Without parameters, the linear function creates a non-eased transition.\n * Parameters, if used, creates a piecewise linear easing by interpolating linearly between the specified points.\n * @param  {...String|Number} [args] - Points\n * @return {EasingFunction}\n */\nconst linear = (...args) => {\n  const argsLength = args.length;\n  if (!argsLength) return none;\n  const totalPoints = argsLength - 1;\n  const firstArg = args[0];\n  const lastArg = args[totalPoints];\n  const xPoints = [0];\n  const yPoints = [parseNumber(firstArg)];\n  for (let i = 1; i < totalPoints; i++) {\n    const arg = args[i];\n    const splitValue = isStr(arg) ? /** @type {String} */arg.trim().split(' ') : [arg];\n    const value = splitValue[0];\n    const percent = splitValue[1];\n    xPoints.push(!isUnd(percent) ? parseNumber(percent) / 100 : i / totalPoints);\n    yPoints.push(parseNumber(value));\n  }\n  yPoints.push(parseNumber(lastArg));\n  xPoints.push(1);\n  return function easeLinear(t) {\n    for (let i = 1, l = xPoints.length; i < l; i++) {\n      const currentX = xPoints[i];\n      if (t <= currentX) {\n        const prevX = xPoints[i - 1];\n        const prevY = yPoints[i - 1];\n        return prevY + (yPoints[i] - prevY) * (t - prevX) / (currentX - prevX);\n      }\n    }\n    return yPoints[yPoints.length - 1];\n  };\n};\n\n/**\n * Generate random steps\n * @param  {Number} [length] - The number of steps\n * @param  {Number} [randomness] - How strong the randomness is\n * @return {EasingFunction}\n */\nconst irregular = (length = 10, randomness = 1) => {\n  const values = [0];\n  const total = length - 1;\n  for (let i = 1; i < total; i++) {\n    const previousValue = values[i - 1];\n    const spacing = i / total;\n    const segmentEnd = (i + 1) / total;\n    const randomVariation = spacing + (segmentEnd - spacing) * Math.random();\n    // Mix the even spacing and random variation based on the randomness parameter\n    const randomValue = spacing * (1 - randomness) + randomVariation * randomness;\n    values.push(clamp(randomValue, previousValue, 1));\n  }\n  values.push(1);\n  return linear(...values);\n};\n\n// Easing functions adapted from http://www.robertpenner.com/ease © Robert Penner\n\n/**\n * @callback PowerEasing\n * @param {Number|String} [power=1.675]\n * @return {EasingFunction}\n */\n\n/**\n * @callback BackEasing\n * @param {Number|String} [overshoot=1.70158]\n * @return {EasingFunction}\n */\n\n/**\n * @callback ElasticEasing\n * @param {Number|String} [amplitude=1]\n * @param {Number|String} [period=.3]\n * @return {EasingFunction}\n */\n\n/**\n * @callback EaseFactory\n * @param {Number|String} [paramA]\n * @param {Number|String} [paramB]\n * @return {EasingFunction|Number}\n */\n\n/** @typedef {PowerEasing|BackEasing|ElasticEasing} EasesFactory */\n\nconst halfPI = PI / 2;\nconst doublePI = PI * 2;\n/** @type {PowerEasing} */\nconst easeInPower = (p = 1.68) => t => pow(t, +p);\n\n/** @type {Record<String, EasesFactory|EasingFunction>} */\nconst easeInFunctions = {\n  [emptyString]: easeInPower,\n  Quad: easeInPower(2),\n  Cubic: easeInPower(3),\n  Quart: easeInPower(4),\n  Quint: easeInPower(5),\n  /** @type {EasingFunction} */\n  Sine: t => 1 - cos(t * halfPI),\n  /** @type {EasingFunction} */\n  Circ: t => 1 - sqrt(1 - t * t),\n  /** @type {EasingFunction} */\n  Expo: t => t ? pow(2, 10 * t - 10) : 0,\n  /** @type {EasingFunction} */\n  Bounce: t => {\n    let pow2,\n      b = 4;\n    while (t < ((pow2 = pow(2, --b)) - 1) / 11);\n    return 1 / pow(4, 3 - b) - 7.5625 * pow((pow2 * 3 - 2) / 22 - t, 2);\n  },\n  /** @type {BackEasing} */\n  Back: (overshoot = 1.70158) => t => (+overshoot + 1) * t * t * t - +overshoot * t * t,\n  /** @type {ElasticEasing} */\n  Elastic: (amplitude = 1, period = .3) => {\n    const a = clamp(+amplitude, 1, 10);\n    const p = clamp(+period, minValue, 2);\n    const s = p / doublePI * asin(1 / a);\n    const e = doublePI / p;\n    return t => t === 0 || t === 1 ? t : -a * pow(2, -10 * (1 - t)) * sin((1 - t - s) * e);\n  }\n};\n\n/**\n * @callback EaseType\n * @param {EasingFunction} Ease\n * @return {EasingFunction}\n */\n\n/** @type {Record<String, EaseType>} */\nconst easeTypes = {\n  in: easeIn => t => easeIn(t),\n  out: easeIn => t => 1 - easeIn(1 - t),\n  inOut: easeIn => t => t < .5 ? easeIn(t * 2) / 2 : 1 - easeIn(t * -2 + 2) / 2,\n  outIn: easeIn => t => t < .5 ? (1 - easeIn(1 - t * 2)) / 2 : (easeIn(t * 2 - 1) + 1) / 2\n};\n\n/**\n * @param  {String} string\n * @param  {Record<String, EasesFactory|EasingFunction>} easesFunctions\n * @param  {Object} easesLookups\n * @return {EasingFunction}\n */\nconst parseEaseString = (string, easesFunctions, easesLookups) => {\n  if (easesLookups[string]) return easesLookups[string];\n  if (string.indexOf('(') <= -1) {\n    const hasParams = easeTypes[string] || string.includes('Back') || string.includes('Elastic');\n    const parsedFn = /** @type {EasingFunction} */hasParams ? /** @type {EasesFactory} */easesFunctions[string]() : easesFunctions[string];\n    return parsedFn ? easesLookups[string] = parsedFn : none;\n  } else {\n    const split = string.slice(0, -1).split('(');\n    const parsedFn = /** @type {EasesFactory} */easesFunctions[split[0]];\n    return parsedFn ? easesLookups[string] = parsedFn(...split[1].split(',')) : none;\n  }\n};\n\n/**\n * @typedef  {Object} EasesFunctions\n * @property {typeof linear} linear\n * @property {typeof irregular} irregular\n * @property {typeof steps} steps\n * @property {typeof cubicBezier} cubicBezier\n * @property {PowerEasing} in\n * @property {PowerEasing} out\n * @property {PowerEasing} inOut\n * @property {PowerEasing} outIn\n * @property {EasingFunction} inQuad\n * @property {EasingFunction} outQuad\n * @property {EasingFunction} inOutQuad\n * @property {EasingFunction} outInQuad\n * @property {EasingFunction} inCubic\n * @property {EasingFunction} outCubic\n * @property {EasingFunction} inOutCubic\n * @property {EasingFunction} outInCubic\n * @property {EasingFunction} inQuart\n * @property {EasingFunction} outQuart\n * @property {EasingFunction} inOutQuart\n * @property {EasingFunction} outInQuart\n * @property {EasingFunction} inQuint\n * @property {EasingFunction} outQuint\n * @property {EasingFunction} inOutQuint\n * @property {EasingFunction} outInQuint\n * @property {EasingFunction} inSine\n * @property {EasingFunction} outSine\n * @property {EasingFunction} inOutSine\n * @property {EasingFunction} outInSine\n * @property {EasingFunction} inCirc\n * @property {EasingFunction} outCirc\n * @property {EasingFunction} inOutCirc\n * @property {EasingFunction} outInCirc\n * @property {EasingFunction} inExpo\n * @property {EasingFunction} outExpo\n * @property {EasingFunction} inOutExpo\n * @property {EasingFunction} outInExpo\n * @property {EasingFunction} inBounce\n * @property {EasingFunction} outBounce\n * @property {EasingFunction} inOutBounce\n * @property {EasingFunction} outInBounce\n * @property {BackEasing} inBack\n * @property {BackEasing} outBack\n * @property {BackEasing} inOutBack\n * @property {BackEasing} outInBack\n * @property {ElasticEasing} inElastic\n * @property {ElasticEasing} outElastic\n * @property {ElasticEasing} inOutElastic\n * @property {ElasticEasing} outInElastic\n */\n\nconst eases = /*#__PURE__*/(() => {\n  const list = {\n    linear,\n    irregular,\n    steps,\n    cubicBezier\n  };\n  for (let type in easeTypes) {\n    for (let name in easeInFunctions) {\n      const easeIn = easeInFunctions[name];\n      const easeType = easeTypes[type];\n      list[type + name] = /** @type {EasesFactory|EasingFunction} */\n      name === emptyString || name === 'Back' || name === 'Elastic' ? (a, b) => easeType(/** @type {EasesFactory} */easeIn(a, b)) : easeType(/** @type {EasingFunction} */easeIn);\n    }\n  }\n  return /** @type {EasesFunctions} */list;\n})();\n\n/** @type {Record<String, EasingFunction>} */\nconst JSEasesLookups = {\n  linear: none\n};\n\n/**\n * @param  {EasingParam} ease\n * @return {EasingFunction}\n */\nconst parseEasings = ease => isFnc(ease) ? ease : isStr(ease) ? parseEaseString(/** @type {String} */ease, eases, JSEasesLookups) : none;\nconst propertyNamesCache = {};\n\n/**\n * @param  {String} propertyName\n * @param  {Target} target\n * @param  {tweenTypes} tweenType\n * @return {String}\n */\nconst sanitizePropertyName = (propertyName, target, tweenType) => {\n  if (tweenType === tweenTypes.TRANSFORM) {\n    const t = shortTransforms.get(propertyName);\n    return t ? t : propertyName;\n  } else if (tweenType === tweenTypes.CSS ||\n  // Handle special cases where properties like \"strokeDashoffset\" needs to be set as \"stroke-dashoffset\"\n  // but properties like \"baseFrequency\" should stay in lowerCamelCase\n  tweenType === tweenTypes.ATTRIBUTE && isSvg(target) && propertyName in /** @type {DOMTarget} */target.style) {\n    const cachedPropertyName = propertyNamesCache[propertyName];\n    if (cachedPropertyName) {\n      return cachedPropertyName;\n    } else {\n      const lowerCaseName = propertyName ? toLowerCase(propertyName) : propertyName;\n      propertyNamesCache[propertyName] = lowerCaseName;\n      return lowerCaseName;\n    }\n  } else {\n    return propertyName;\n  }\n};\nconst angleUnitsMap = {\n  'deg': 1,\n  'rad': 180 / PI,\n  'turn': 360\n};\nconst convertedValuesCache = {};\n\n/**\n * @param  {DOMTarget} el\n * @param  {TweenDecomposedValue} decomposedValue\n * @param  {String} unit\n * @param  {Boolean} [force]\n * @return {TweenDecomposedValue}\n */\nconst convertValueUnit = (el, decomposedValue, unit, force = false) => {\n  const currentUnit = decomposedValue.u;\n  const currentNumber = decomposedValue.n;\n  if (decomposedValue.t === valueTypes.UNIT && currentUnit === unit) {\n    // TODO: Check if checking against the same unit string is necessary\n    return decomposedValue;\n  }\n  const cachedKey = currentNumber + currentUnit + unit;\n  const cached = convertedValuesCache[cachedKey];\n  if (!isUnd(cached) && !force) {\n    decomposedValue.n = cached;\n  } else {\n    let convertedValue;\n    if (currentUnit in angleUnitsMap) {\n      convertedValue = currentNumber * angleUnitsMap[currentUnit] / angleUnitsMap[unit];\n    } else {\n      const baseline = 100;\n      const tempEl = /** @type {DOMTarget} */el.cloneNode();\n      const parentNode = el.parentNode;\n      const parentEl = parentNode && parentNode !== doc ? parentNode : doc.body;\n      parentEl.appendChild(tempEl);\n      const elStyle = tempEl.style;\n      elStyle.width = baseline + currentUnit;\n      const currentUnitWidth = /** @type {HTMLElement} */tempEl.offsetWidth || baseline;\n      elStyle.width = baseline + unit;\n      const newUnitWidth = /** @type {HTMLElement} */tempEl.offsetWidth || baseline;\n      const factor = currentUnitWidth / newUnitWidth;\n      parentEl.removeChild(tempEl);\n      convertedValue = factor * currentNumber;\n    }\n    decomposedValue.n = convertedValue;\n    convertedValuesCache[cachedKey] = convertedValue;\n  }\n  decomposedValue.t === valueTypes.UNIT;\n  decomposedValue.u = unit;\n  return decomposedValue;\n};\n\n/**\n * @template {Renderable} T\n * @param {T} renderable\n * @return {T}\n */\nconst cleanInlineStyles = renderable => {\n  // Allow cleanInlineStyles() to be called on timelines\n  if (renderable._hasChildren) {\n    forEachChildren(renderable, cleanInlineStyles, true);\n  } else {\n    const animation = /** @type {JSAnimation} */renderable;\n    animation.pause();\n    forEachChildren(animation, (/** @type {Tween} */tween) => {\n      const tweenProperty = tween.property;\n      const tweenTarget = tween.target;\n      if (tweenTarget[isDomSymbol]) {\n        const targetStyle = /** @type {DOMTarget} */tweenTarget.style;\n        const originalInlinedValue = animation._inlineStyles[tweenProperty];\n        if (tween._tweenType === tweenTypes.TRANSFORM) {\n          const cachedTransforms = tweenTarget[transformsSymbol];\n          if (isUnd(originalInlinedValue) || originalInlinedValue === emptyString) {\n            delete cachedTransforms[tweenProperty];\n          } else {\n            cachedTransforms[tweenProperty] = originalInlinedValue;\n          }\n          if (tween._renderTransforms) {\n            if (!Object.keys(cachedTransforms).length) {\n              targetStyle.removeProperty('transform');\n            } else {\n              let str = emptyString;\n              for (let key in cachedTransforms) {\n                str += transformsFragmentStrings[key] + cachedTransforms[key] + ') ';\n              }\n              targetStyle.transform = str;\n            }\n          }\n        } else {\n          if (isUnd(originalInlinedValue) || originalInlinedValue === emptyString) {\n            targetStyle.removeProperty(tweenProperty);\n          } else {\n            targetStyle[tweenProperty] = originalInlinedValue;\n          }\n        }\n        if (animation._tail === tween) {\n          animation.targets.forEach(t => {\n            if (t.getAttribute && t.getAttribute('style') === emptyString) {\n              t.removeAttribute('style');\n            }\n          });\n        }\n      }\n    });\n  }\n  return renderable;\n};\n\n// Defines decomposed values target objects only once and mutate their properties later to avoid GC\n// TODO: Maybe move the objects creation to values.js and use the decompose function to create the base object\nconst fromTargetObject = createDecomposedValueTargetObject();\nconst toTargetObject = createDecomposedValueTargetObject();\nconst toFunctionStore = {\n  func: null\n};\nconst keyframesTargetArray = [null];\nconst fastSetValuesArray = [null, null];\n/** @type {TweenKeyValue} */\nconst keyObjectTarget = {\n  to: null\n};\nlet tweenId = 0;\nlet keyframes;\n/** @type {TweenParamsOptions & TweenValues} */\nlet key;\n\n/**\n * @param {DurationKeyframes | PercentageKeyframes} keyframes\n * @param {AnimationParams} parameters\n * @return {AnimationParams}\n */\nconst generateKeyframes = (keyframes, parameters) => {\n  /** @type {AnimationParams} */\n  const properties = {};\n  if (isArr(keyframes)) {\n    const propertyNames = [].concat(... /** @type {DurationKeyframes} */keyframes.map(key => Object.keys(key))).filter(isKey);\n    for (let i = 0, l = propertyNames.length; i < l; i++) {\n      const propName = propertyNames[i];\n      const propArray = /** @type {DurationKeyframes} */keyframes.map(key => {\n        /** @type {TweenKeyValue} */\n        const newKey = {};\n        for (let p in key) {\n          const keyValue = /** @type {TweenPropValue} */key[p];\n          if (isKey(p)) {\n            if (p === propName) {\n              newKey.to = keyValue;\n            }\n          } else {\n            newKey[p] = keyValue;\n          }\n        }\n        return newKey;\n      });\n      properties[propName] = /** @type {ArraySyntaxValue} */propArray;\n    }\n  } else {\n    const totalDuration = /** @type {Number} */setValue(parameters.duration, globals.defaults.duration);\n    const keys = Object.keys(keyframes).map(key => {\n      return {\n        o: parseFloat(key) / 100,\n        p: keyframes[key]\n      };\n    }).sort((a, b) => a.o - b.o);\n    keys.forEach(key => {\n      const offset = key.o;\n      const prop = key.p;\n      for (let name in prop) {\n        if (isKey(name)) {\n          let propArray = /** @type {Array} */properties[name];\n          if (!propArray) propArray = properties[name] = [];\n          const duration = offset * totalDuration;\n          let length = propArray.length;\n          let prevKey = propArray[length - 1];\n          const keyObj = {\n            to: prop[name]\n          };\n          let durProgress = 0;\n          for (let i = 0; i < length; i++) {\n            durProgress += propArray[i].duration;\n          }\n          if (length === 1) {\n            keyObj.from = prevKey.to;\n          }\n          if (prop.ease) {\n            keyObj.ease = prop.ease;\n          }\n          keyObj.duration = duration - (length ? durProgress : 0);\n          propArray.push(keyObj);\n        }\n      }\n      return key;\n    });\n    for (let name in properties) {\n      const propArray = /** @type {Array} */properties[name];\n      let prevEase;\n      // let durProgress = 0\n      for (let i = 0, l = propArray.length; i < l; i++) {\n        const prop = propArray[i];\n        // Emulate WAPPI easing parameter position\n        const currentEase = prop.ease;\n        prop.ease = prevEase ? prevEase : undefined;\n        prevEase = currentEase;\n        // durProgress += prop.duration;\n        // if (i === l - 1 && durProgress !== totalDuration) {\n        //   propArray.push({ from: prop.to, ease: prop.ease, duration: totalDuration - durProgress })\n        // }\n      }\n      if (!propArray[0].duration) {\n        propArray.shift();\n      }\n    }\n  }\n  return properties;\n};\nclass JSAnimation extends Timer {\n  /**\n   * @param {TargetsParam} targets\n   * @param {AnimationParams} parameters\n   * @param {Timeline} [parent]\n   * @param {Number} [parentPosition]\n   * @param {Boolean} [fastSet=false]\n   * @param {Number} [index=0]\n   * @param {Number} [length=0]\n   */\n  constructor(targets, parameters, parent, parentPosition, fastSet = false, index = 0, length = 0) {\n    super(/** @type {TimerParams&AnimationParams} */parameters, parent, parentPosition);\n    const parsedTargets = registerTargets(targets);\n    const targetsLength = parsedTargets.length;\n\n    // If the parameters object contains a \"keyframes\" property, convert all the keyframes values to regular properties\n\n    const kfParams = /** @type {AnimationParams} */parameters.keyframes;\n    const params = /** @type {AnimationParams} */kfParams ? mergeObjects(generateKeyframes(/** @type {DurationKeyframes} */kfParams, parameters), parameters) : parameters;\n    const {\n      delay,\n      duration,\n      ease,\n      playbackEase,\n      modifier,\n      composition,\n      onRender\n    } = params;\n    const animDefaults = parent ? parent.defaults : globals.defaults;\n    const animaPlaybackEase = setValue(playbackEase, animDefaults.playbackEase);\n    const animEase = animaPlaybackEase ? parseEasings(animaPlaybackEase) : null;\n    const hasSpring = !isUnd(ease) && !isUnd(/** @type {Spring} */ease.ease);\n    const tEasing = hasSpring ? /** @type {Spring} */ease.ease : setValue(ease, animEase ? 'linear' : animDefaults.ease);\n    const tDuration = hasSpring ? /** @type {Spring} */ease.duration : setValue(duration, animDefaults.duration);\n    const tDelay = setValue(delay, animDefaults.delay);\n    const tModifier = modifier || animDefaults.modifier;\n    // If no composition is defined and the targets length is high (>= 1000) set the composition to 'none' (0) for faster tween creation\n    const tComposition = isUnd(composition) && targetsLength >= K ? compositionTypes.none : !isUnd(composition) ? composition : animDefaults.composition;\n    // TODO: Do not create an empty object until we know the animation will generate inline styles\n    const animInlineStyles = {};\n    // const absoluteOffsetTime = this._offset;\n    const absoluteOffsetTime = this._offset + (parent ? parent._offset : 0);\n    let iterationDuration = NaN;\n    let iterationDelay = NaN;\n    let animationAnimationLength = 0;\n    let shouldTriggerRender = 0;\n    for (let targetIndex = 0; targetIndex < targetsLength; targetIndex++) {\n      const target = parsedTargets[targetIndex];\n      const ti = index || targetIndex;\n      const tl = length || targetsLength;\n      let lastTransformGroupIndex = NaN;\n      let lastTransformGroupLength = NaN;\n      for (let p in params) {\n        if (isKey(p)) {\n          const tweenType = getTweenType(target, p);\n          const propName = sanitizePropertyName(p, target, tweenType);\n          let propValue = params[p];\n          const isPropValueArray = isArr(propValue);\n          if (fastSet && !isPropValueArray) {\n            fastSetValuesArray[0] = propValue;\n            fastSetValuesArray[1] = propValue;\n            propValue = fastSetValuesArray;\n          }\n\n          // TODO: Allow nested keyframes inside ObjectValue value (prop: { to: [.5, 1, .75, 2, 3] })\n          // Normalize property values to valid keyframe syntax:\n          // [x, y] to [{to: [x, y]}] or {to: x} to [{to: x}] or keep keys syntax [{}, {}, {}...]\n          // const keyframes = isArr(propValue) ? propValue.length === 2 && !isObj(propValue[0]) ? [{ to: propValue }] : propValue : [propValue];\n          if (isPropValueArray) {\n            const arrayLength = /** @type {Array} */propValue.length;\n            const isNotObjectValue = !isObj(propValue[0]);\n            // Convert [x, y] to [{to: [x, y]}]\n            if (arrayLength === 2 && isNotObjectValue) {\n              keyObjectTarget.to = /** @type {TweenParamValue} */ /** @type {unknown} */propValue;\n              keyframesTargetArray[0] = keyObjectTarget;\n              keyframes = keyframesTargetArray;\n              // Convert [x, y, z] to [[x, y], z]\n            } else if (arrayLength > 2 && isNotObjectValue) {\n              keyframes = [];\n              /** @type {Array.<Number>} */\n              propValue.forEach((v, i) => {\n                if (!i) {\n                  fastSetValuesArray[0] = v;\n                } else if (i === 1) {\n                  fastSetValuesArray[1] = v;\n                  keyframes.push(fastSetValuesArray);\n                } else {\n                  keyframes.push(v);\n                }\n              });\n            } else {\n              keyframes = /** @type {Array.<TweenKeyValue>} */propValue;\n            }\n          } else {\n            keyframesTargetArray[0] = propValue;\n            keyframes = keyframesTargetArray;\n          }\n          let siblings = null;\n          let prevTween = null;\n          let firstTweenChangeStartTime = NaN;\n          let lastTweenChangeEndTime = 0;\n          let tweenIndex = 0;\n          for (let l = keyframes.length; tweenIndex < l; tweenIndex++) {\n            const keyframe = keyframes[tweenIndex];\n            if (isObj(keyframe)) {\n              key = keyframe;\n            } else {\n              keyObjectTarget.to = /** @type {TweenParamValue} */keyframe;\n              key = keyObjectTarget;\n            }\n            toFunctionStore.func = null;\n            const computedToValue = getFunctionValue(key.to, target, ti, tl, toFunctionStore);\n            let tweenToValue;\n            // Allows function based values to return an object syntax value ({to: v})\n            if (isObj(computedToValue) && !isUnd(computedToValue.to)) {\n              key = computedToValue;\n              tweenToValue = computedToValue.to;\n            } else {\n              tweenToValue = computedToValue;\n            }\n            const tweenFromValue = getFunctionValue(key.from, target, ti, tl);\n            const keyEasing = key.ease;\n            const hasSpring = !isUnd(keyEasing) && !isUnd(/** @type {Spring} */keyEasing.ease);\n            // Easing are treated differently and don't accept function based value to prevent having to pass a function wrapper that returns an other function all the time\n            const tweenEasing = hasSpring ? /** @type {Spring} */keyEasing.ease : keyEasing || tEasing;\n            // Calculate default individual keyframe duration by dividing the tl of keyframes\n            const tweenDuration = hasSpring ? /** @type {Spring} */keyEasing.duration : getFunctionValue(setValue(key.duration, l > 1 ? getFunctionValue(tDuration, target, ti, tl) / l : tDuration), target, ti, tl);\n            // Default delay value should only be applied to the first tween\n            const tweenDelay = getFunctionValue(setValue(key.delay, !tweenIndex ? tDelay : 0), target, ti, tl);\n            const computedComposition = getFunctionValue(setValue(key.composition, tComposition), target, ti, tl);\n            const tweenComposition = isNum(computedComposition) ? computedComposition : compositionTypes[computedComposition];\n            // Modifiers are treated differently and don't accept function based value to prevent having to pass a function wrapper\n            const tweenModifier = key.modifier || tModifier;\n            const hasFromvalue = !isUnd(tweenFromValue);\n            const hasToValue = !isUnd(tweenToValue);\n            const isFromToArray = isArr(tweenToValue);\n            const isFromToValue = isFromToArray || hasFromvalue && hasToValue;\n            const tweenStartTime = prevTween ? lastTweenChangeEndTime + tweenDelay : tweenDelay;\n            const absoluteStartTime = absoluteOffsetTime + tweenStartTime;\n\n            // Force a onRender callback if the animation contains at least one from value and autoplay is set to false\n            if (!shouldTriggerRender && (hasFromvalue || isFromToArray)) shouldTriggerRender = 1;\n            let prevSibling = prevTween;\n            if (tweenComposition !== compositionTypes.none) {\n              if (!siblings) siblings = getTweenSiblings(target, propName);\n              let nextSibling = siblings._head;\n              // Iterate trough all the next siblings until we find a sibling with an equal or inferior start time\n              while (nextSibling && !nextSibling._isOverridden && nextSibling._absoluteStartTime <= absoluteStartTime) {\n                prevSibling = nextSibling;\n                nextSibling = nextSibling._nextRep;\n                // Overrides all the next siblings if the next sibling starts at the same time of after as the new tween start time\n                if (nextSibling && nextSibling._absoluteStartTime >= absoluteStartTime) {\n                  while (nextSibling) {\n                    overrideTween(nextSibling);\n                    // This will ends both the current while loop and the upper one once all the next sibllings have been overriden\n                    nextSibling = nextSibling._nextRep;\n                  }\n                }\n              }\n            }\n\n            // Decompose values\n            if (isFromToValue) {\n              decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[0], target, ti, tl) : tweenFromValue, fromTargetObject);\n              decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[1], target, ti, tl, toFunctionStore) : tweenToValue, toTargetObject);\n              if (fromTargetObject.t === valueTypes.NUMBER) {\n                if (prevSibling) {\n                  if (prevSibling._valueType === valueTypes.UNIT) {\n                    fromTargetObject.t = valueTypes.UNIT;\n                    fromTargetObject.u = prevSibling._unit;\n                  }\n                } else {\n                  decomposeRawValue(getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles), decomposedOriginalValue);\n                  if (decomposedOriginalValue.t === valueTypes.UNIT) {\n                    fromTargetObject.t = valueTypes.UNIT;\n                    fromTargetObject.u = decomposedOriginalValue.u;\n                  }\n                }\n              }\n            } else {\n              if (hasToValue) {\n                decomposeRawValue(tweenToValue, toTargetObject);\n              } else {\n                if (prevTween) {\n                  decomposeTweenValue(prevTween, toTargetObject);\n                } else {\n                  // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline\n                  decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value : getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles), toTargetObject);\n                }\n              }\n              if (hasFromvalue) {\n                decomposeRawValue(tweenFromValue, fromTargetObject);\n              } else {\n                if (prevTween) {\n                  decomposeTweenValue(prevTween, fromTargetObject);\n                } else {\n                  decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value :\n                  // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline\n                  getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles), fromTargetObject);\n                }\n              }\n            }\n\n            // Apply operators\n            if (fromTargetObject.o) {\n              fromTargetObject.n = getRelativeValue(!prevSibling ? decomposeRawValue(getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles), decomposedOriginalValue).n : prevSibling._toNumber, fromTargetObject.n, fromTargetObject.o);\n            }\n            if (toTargetObject.o) {\n              toTargetObject.n = getRelativeValue(fromTargetObject.n, toTargetObject.n, toTargetObject.o);\n            }\n\n            // Values omogenisation in cases of type difference between \"from\" and \"to\"\n            if (fromTargetObject.t !== toTargetObject.t) {\n              if (fromTargetObject.t === valueTypes.COMPLEX || toTargetObject.t === valueTypes.COMPLEX) {\n                const complexValue = fromTargetObject.t === valueTypes.COMPLEX ? fromTargetObject : toTargetObject;\n                const notComplexValue = fromTargetObject.t === valueTypes.COMPLEX ? toTargetObject : fromTargetObject;\n                notComplexValue.t = valueTypes.COMPLEX;\n                notComplexValue.s = cloneArray(complexValue.s);\n                notComplexValue.d = complexValue.d.map(() => notComplexValue.n);\n              } else if (fromTargetObject.t === valueTypes.UNIT || toTargetObject.t === valueTypes.UNIT) {\n                const unitValue = fromTargetObject.t === valueTypes.UNIT ? fromTargetObject : toTargetObject;\n                const notUnitValue = fromTargetObject.t === valueTypes.UNIT ? toTargetObject : fromTargetObject;\n                notUnitValue.t = valueTypes.UNIT;\n                notUnitValue.u = unitValue.u;\n              } else if (fromTargetObject.t === valueTypes.COLOR || toTargetObject.t === valueTypes.COLOR) {\n                const colorValue = fromTargetObject.t === valueTypes.COLOR ? fromTargetObject : toTargetObject;\n                const notColorValue = fromTargetObject.t === valueTypes.COLOR ? toTargetObject : fromTargetObject;\n                notColorValue.t = valueTypes.COLOR;\n                notColorValue.s = colorValue.s;\n                notColorValue.d = [0, 0, 0, 1];\n              }\n            }\n\n            // Unit conversion\n            if (fromTargetObject.u !== toTargetObject.u) {\n              let valueToConvert = toTargetObject.u ? fromTargetObject : toTargetObject;\n              valueToConvert = convertValueUnit(/** @type {DOMTarget} */target, valueToConvert, toTargetObject.u ? toTargetObject.u : fromTargetObject.u, false);\n              // TODO:\n              // convertValueUnit(target, to.u ? from : to, to.u ? to.u : from.u);\n            }\n\n            // Fill in non existing complex values\n            if (toTargetObject.d && fromTargetObject.d && toTargetObject.d.length !== fromTargetObject.d.length) {\n              const longestValue = fromTargetObject.d.length > toTargetObject.d.length ? fromTargetObject : toTargetObject;\n              const shortestValue = longestValue === fromTargetObject ? toTargetObject : fromTargetObject;\n              // TODO: Check if n should be used instead of 0 for default complex values\n              shortestValue.d = longestValue.d.map((_, i) => isUnd(shortestValue.d[i]) ? 0 : shortestValue.d[i]);\n              shortestValue.s = cloneArray(longestValue.s);\n            }\n\n            // Tween factory\n\n            // Rounding is necessary here to minimize floating point errors\n            const tweenUpdateDuration = round(+tweenDuration || minValue, 12);\n\n            /** @type {Tween} */\n            const tween = {\n              parent: this,\n              id: tweenId++,\n              property: propName,\n              target: target,\n              _value: null,\n              _func: toFunctionStore.func,\n              _ease: parseEasings(tweenEasing),\n              _fromNumbers: cloneArray(fromTargetObject.d),\n              _toNumbers: cloneArray(toTargetObject.d),\n              _strings: cloneArray(toTargetObject.s),\n              _fromNumber: fromTargetObject.n,\n              _toNumber: toTargetObject.n,\n              _numbers: cloneArray(fromTargetObject.d),\n              // For additive tween and animatables\n              _number: fromTargetObject.n,\n              // For additive tween and animatables\n              _unit: toTargetObject.u,\n              _modifier: tweenModifier,\n              _currentTime: 0,\n              _startTime: tweenStartTime,\n              _delay: +tweenDelay,\n              _updateDuration: tweenUpdateDuration,\n              _changeDuration: tweenUpdateDuration,\n              _absoluteStartTime: absoluteStartTime,\n              // NOTE: Investigate bit packing to stores ENUM / BOOL\n              _tweenType: tweenType,\n              _valueType: toTargetObject.t,\n              _composition: tweenComposition,\n              _isOverlapped: 0,\n              _isOverridden: 0,\n              _renderTransforms: 0,\n              _prevRep: null,\n              // For replaced tween\n              _nextRep: null,\n              // For replaced tween\n              _prevAdd: null,\n              // For additive tween\n              _nextAdd: null,\n              // For additive tween\n              _prev: null,\n              _next: null\n            };\n            if (tweenComposition !== compositionTypes.none) {\n              composeTween(tween, siblings);\n            }\n            if (isNaN(firstTweenChangeStartTime)) {\n              firstTweenChangeStartTime = tween._startTime;\n            }\n            // Rounding is necessary here to minimize floating point errors\n            lastTweenChangeEndTime = round(tweenStartTime + tweenUpdateDuration, 12);\n            prevTween = tween;\n            animationAnimationLength++;\n            addChild(this, tween);\n          }\n\n          // Update animation timings with the added tweens properties\n\n          if (isNaN(iterationDelay) || firstTweenChangeStartTime < iterationDelay) {\n            iterationDelay = firstTweenChangeStartTime;\n          }\n          if (isNaN(iterationDuration) || lastTweenChangeEndTime > iterationDuration) {\n            iterationDuration = lastTweenChangeEndTime;\n          }\n\n          // TODO: Find a way to inline tween._renderTransforms = 1 here\n          if (tweenType === tweenTypes.TRANSFORM) {\n            lastTransformGroupIndex = animationAnimationLength - tweenIndex;\n            lastTransformGroupLength = animationAnimationLength;\n          }\n        }\n      }\n\n      // Set _renderTransforms to last transform property to correctly render the transforms list\n      if (!isNaN(lastTransformGroupIndex)) {\n        let i = 0;\n        forEachChildren(this, (/** @type {Tween} */tween) => {\n          if (i >= lastTransformGroupIndex && i < lastTransformGroupLength) {\n            tween._renderTransforms = 1;\n            if (tween._composition === compositionTypes.blend) {\n              forEachChildren(additive.animation, (/** @type {Tween} */additiveTween) => {\n                if (additiveTween.id === tween.id) {\n                  additiveTween._renderTransforms = 1;\n                }\n              });\n            }\n          }\n          i++;\n        });\n      }\n    }\n    if (!targetsLength) {\n      console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);\n    }\n    if (iterationDelay) {\n      forEachChildren(this, (/** @type {Tween} */tween) => {\n        // If (startTime - delay) equals 0, this means the tween is at the begining of the animation so we need to trim the delay too\n        if (!(tween._startTime - tween._delay)) {\n          tween._delay -= iterationDelay;\n        }\n        tween._startTime -= iterationDelay;\n      });\n      iterationDuration -= iterationDelay;\n    } else {\n      iterationDelay = 0;\n    }\n\n    // Prevents iterationDuration to be NaN if no valid animatable props have been provided\n    // Prevents _iterationCount to be NaN if no valid animatable props have been provided\n    if (!iterationDuration) {\n      iterationDuration = minValue;\n      this.iterationCount = 0;\n    }\n    /** @type {TargetsArray} */\n    this.targets = parsedTargets;\n    /** @type {Number} */\n    this.duration = iterationDuration === minValue ? minValue : clampInfinity((iterationDuration + this._loopDelay) * this.iterationCount - this._loopDelay) || minValue;\n    /** @type {Callback<this>} */\n    this.onRender = onRender || animDefaults.onRender;\n    /** @type {EasingFunction} */\n    this._ease = animEase;\n    /** @type {Number} */\n    this._delay = iterationDelay;\n    // NOTE: I'm keeping delay values separated from offsets in timelines because delays can override previous tweens and it could be confusing to debug a timeline with overridden tweens and no associated visible delays.\n    // this._delay = parent ? 0 : iterationDelay;\n    // this._offset += parent ? iterationDelay : 0;\n    /** @type {Number} */\n    this.iterationDuration = iterationDuration;\n    /** @type {{}} */\n    this._inlineStyles = animInlineStyles;\n    if (!this._autoplay && shouldTriggerRender) this.onRender(this);\n  }\n\n  /**\n   * @param  {Number} newDuration\n   * @return {this}\n   */\n  stretch(newDuration) {\n    const currentDuration = this.duration;\n    if (currentDuration === normalizeTime(newDuration)) return this;\n    const timeScale = newDuration / currentDuration;\n    // NOTE: Find a better way to handle the stretch of an animation after stretch = 0\n    forEachChildren(this, (/** @type {Tween} */tween) => {\n      // Rounding is necessary here to minimize floating point errors\n      tween._updateDuration = normalizeTime(tween._updateDuration * timeScale);\n      tween._changeDuration = normalizeTime(tween._changeDuration * timeScale);\n      tween._currentTime *= timeScale;\n      tween._startTime *= timeScale;\n      tween._absoluteStartTime *= timeScale;\n    });\n    return super.stretch(newDuration);\n  }\n\n  /**\n   * @return {this}\n   */\n  refresh() {\n    forEachChildren(this, (/** @type {Tween} */tween) => {\n      const tweenFunc = tween._func;\n      if (tweenFunc) {\n        const ogValue = getOriginalAnimatableValue(tween.target, tween.property, tween._tweenType);\n        decomposeRawValue(ogValue, decomposedOriginalValue);\n        decomposeRawValue(tweenFunc(), toTargetObject);\n        tween._fromNumbers = cloneArray(decomposedOriginalValue.d);\n        tween._fromNumber = decomposedOriginalValue.n;\n        tween._toNumbers = cloneArray(toTargetObject.d);\n        tween._strings = cloneArray(toTargetObject.s);\n        // Make sure to apply relative operators https://github.com/juliangarnier/anime/issues/1025\n        tween._toNumber = toTargetObject.o ? getRelativeValue(decomposedOriginalValue.n, toTargetObject.n, toTargetObject.o) : toTargetObject.n;\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Cancel the animation and revert all the values affected by this animation to their original state\n   * @return {this}\n   */\n  revert() {\n    super.revert();\n    return cleanInlineStyles(this);\n  }\n\n  /**\n   * @param  {Callback<this>} [callback]\n   * @return {Promise}\n   */\n  then(callback) {\n    return super.then(callback);\n  }\n}\n\n/**\n * @param {TargetsParam} targets\n * @param {AnimationParams} parameters\n * @return {JSAnimation}\n */\nconst animate = (targets, parameters) => new JSAnimation(targets, parameters, null, 0, false).init();\n\n/**\n * Converts an easing function into a valid CSS linear() timing function string\n * @param {EasingFunction} fn\n * @param {number} [samples=100]\n * @returns {string} CSS linear() timing function\n */\nconst easingToLinear = (fn, samples = 100) => {\n  const points = [];\n  for (let i = 0; i <= samples; i++) points.push(fn(i / samples));\n  return `linear(${points.join(', ')})`;\n};\nconst WAAPIEasesLookups = {\n  in: 'ease-in',\n  out: 'ease-out',\n  inOut: 'ease-in-out'\n};\nconst WAAPIeases = /*#__PURE__*/(() => {\n  const list = {};\n  for (let type in easeTypes) list[type] = a => easeTypes[type](easeInPower(a));\n  return /** @type {Record<String, EasingFunction>} */list;\n})();\n\n/**\n * @param  {EasingParam} ease\n * @return {String}\n */\nconst parseWAAPIEasing = ease => {\n  let parsedEase = WAAPIEasesLookups[ease];\n  if (parsedEase) return parsedEase;\n  parsedEase = 'linear';\n  if (isStr(ease)) {\n    if (stringStartsWith(ease, 'linear') || stringStartsWith(ease, 'cubic-') || stringStartsWith(ease, 'steps') || stringStartsWith(ease, 'ease')) {\n      parsedEase = ease;\n    } else if (stringStartsWith(ease, 'cubicB')) {\n      parsedEase = toLowerCase(ease);\n    } else {\n      const parsed = parseEaseString(ease, WAAPIeases, WAAPIEasesLookups);\n      if (isFnc(parsed)) parsedEase = parsed === none ? 'linear' : easingToLinear(parsed);\n    }\n    WAAPIEasesLookups[ease] = parsedEase;\n  } else if (isFnc(ease)) {\n    const easing = easingToLinear(ease);\n    if (easing) parsedEase = easing;\n  } else if (/** @type {Spring} */ease.ease) {\n    parsedEase = easingToLinear(/** @type {Spring} */ease.ease);\n  }\n  return parsedEase;\n};\n\n/**\n * @typedef {String|Number|Array<String>|Array<Number>} WAAPITweenValue\n */\n\n/**\n * @callback WAAPIFunctionvalue\n * @param {DOMTarget} target - The animated target\n * @param {Number} index - The target index\n * @param {Number} length - The total number of animated targets\n * @return {WAAPITweenValue}\n */\n\n/**\n * @typedef {WAAPITweenValue|WAAPIFunctionvalue|Array<String|Number|WAAPIFunctionvalue>} WAAPIKeyframeValue\n */\n\n/**\n * @typedef {(animation: WAAPIAnimation) => void} WAAPICallback\n */\n\n/**\n * @typedef {Object} WAAPITweenOptions\n * @property {WAAPIKeyframeValue} [to]\n * @property {WAAPIKeyframeValue} [from]\n * @property {Number|WAAPIFunctionvalue} [duration]\n * @property {Number|WAAPIFunctionvalue} [delay]\n * @property {EasingParam} [ease]\n * @property {CompositeOperation} [composition]\n */\n\n/**\n * @typedef {Object} WAAPIAnimationOptions\n * @property {Number|Boolean} [loop]\n * @property {Boolean} [Reversed]\n * @property {Boolean} [Alternate]\n * @property {Boolean|ScrollObserver} [autoplay]\n * @property {Number} [playbackRate]\n * @property {Number|WAAPIFunctionvalue} [duration]\n * @property {Number|WAAPIFunctionvalue} [delay]\n * @property {EasingParam} [ease]\n * @property {CompositeOperation} [composition]\n * @property {WAAPICallback} [onComplete]\n */\n\n/**\n * @typedef {Record<String, WAAPIKeyframeValue | WAAPIAnimationOptions | Boolean | ScrollObserver | WAAPICallback | EasingParam | WAAPITweenOptions> & WAAPIAnimationOptions} WAAPIAnimationParams\n */\n\nconst transformsShorthands = ['x', 'y', 'z'];\nconst commonDefaultPXProperties = ['perspective', 'width', 'height', 'margin', 'padding', 'top', 'right', 'bottom', 'left', 'borderWidth', 'fontSize', 'borderRadius', ...transformsShorthands];\nconst validIndividualTransforms = /*#__PURE__*/(() => [...transformsShorthands, ...validTransforms.filter(t => ['X', 'Y', 'Z'].some(axis => t.endsWith(axis)))])();\nlet transformsPropertiesRegistered = null;\nconst WAAPIAnimationsLookups = {\n  _head: null,\n  _tail: null\n};\n\n/**\n * @param {DOMTarget} $el\n * @param {String} [property]\n * @param {WAAPIAnimation} [parent]\n */\nconst removeWAAPIAnimation = ($el, property, parent) => {\n  let nextLookup = WAAPIAnimationsLookups._head;\n  while (nextLookup) {\n    const next = nextLookup._next;\n    const matchTarget = nextLookup.$el === $el;\n    const matchProperty = !property || nextLookup.property === property;\n    const matchParent = !parent || nextLookup.parent === parent;\n    if (matchTarget && matchProperty && matchParent) {\n      const anim = nextLookup.animation;\n      try {\n        anim.commitStyles();\n      } catch {}\n      anim.cancel();\n      removeChild(WAAPIAnimationsLookups, nextLookup);\n      const lookupParent = nextLookup.parent;\n      if (lookupParent) {\n        lookupParent._completed++;\n        if (lookupParent.animations.length === lookupParent._completed) {\n          lookupParent.completed = true;\n          if (!lookupParent.muteCallbacks) {\n            lookupParent.paused = true;\n            lookupParent.onComplete(lookupParent);\n            lookupParent._resolve(lookupParent);\n          }\n        }\n      }\n    }\n    nextLookup = next;\n  }\n};\n\n/**\n * @param {WAAPIAnimation} parent\n * @param {DOMTarget} $el\n * @param {String} property\n * @param {PropertyIndexedKeyframes} keyframes\n * @param {KeyframeAnimationOptions} params\n * @retun {Animation}\n */\nconst addWAAPIAnimation = (parent, $el, property, keyframes, params) => {\n  const animation = $el.animate(keyframes, params);\n  const animTotalDuration = params.delay + +params.duration * params.iterations;\n  animation.playbackRate = parent._speed;\n  if (parent.paused) animation.pause();\n  if (parent.duration < animTotalDuration) {\n    parent.duration = animTotalDuration;\n    parent.controlAnimation = animation;\n  }\n  parent.animations.push(animation);\n  removeWAAPIAnimation($el, property);\n  addChild(WAAPIAnimationsLookups, {\n    parent,\n    animation,\n    $el,\n    property,\n    _next: null,\n    _prev: null\n  });\n  const handleRemove = () => {\n    removeWAAPIAnimation($el, property, parent);\n  };\n  animation.onremove = handleRemove;\n  animation.onfinish = handleRemove;\n  return animation;\n};\n\n/**\n * @param  {String} propName\n * @param  {WAAPIKeyframeValue} value\n * @param  {DOMTarget} $el\n * @param  {Number} i\n * @param  {Number} targetsLength\n * @return {String}\n */\nconst normalizeTweenValue = (propName, value, $el, i, targetsLength) => {\n  let v = getFunctionValue(/** @type {any} */value, $el, i, targetsLength);\n  if (!isNum(v)) return v;\n  if (commonDefaultPXProperties.includes(propName) || stringStartsWith(propName, 'translate')) return `${v}px`;\n  if (stringStartsWith(propName, 'rotate') || stringStartsWith(propName, 'skew')) return `${v}deg`;\n  return `${v}`;\n};\n\n/**\n * @param  {DOMTarget} $el\n * @param  {String} propName\n * @param  {WAAPIKeyframeValue} from\n * @param  {WAAPIKeyframeValue} to\n * @param  {Number} i\n * @param  {Number} targetsLength\n * @return {WAAPITweenValue}\n */\nconst parseIndividualTweenValue = ($el, propName, from, to, i, targetsLength) => {\n  /** @type {WAAPITweenValue} */\n  let tweenValue = '0';\n  const computedTo = !isUnd(to) ? normalizeTweenValue(propName, to, $el, i, targetsLength) : getComputedStyle($el)[propName];\n  if (!isUnd(from)) {\n    const computedFrom = normalizeTweenValue(propName, from, $el, i, targetsLength);\n    tweenValue = [computedFrom, computedTo];\n  } else {\n    tweenValue = isArr(to) ? to.map((/** @type {any} */v) => normalizeTweenValue(propName, v, $el, i, targetsLength)) : computedTo;\n  }\n  return tweenValue;\n};\nclass WAAPIAnimation {\n  /**\n   * @param {DOMTargetsParam} targets\n   * @param {WAAPIAnimationParams} params\n   */\n  constructor(targets, params) {\n    if (scope.current) scope.current.register(this);\n\n    // Skip the registration and fallback to no animation in case CSS.registerProperty is not supported\n    if (isNil(transformsPropertiesRegistered)) {\n      if (isBrowser && (isUnd(CSS) || !Object.hasOwnProperty.call(CSS, 'registerProperty'))) {\n        transformsPropertiesRegistered = false;\n      } else {\n        validTransforms.forEach(t => {\n          const isSkew = stringStartsWith(t, 'skew');\n          const isScale = stringStartsWith(t, 'scale');\n          const isRotate = stringStartsWith(t, 'rotate');\n          const isTranslate = stringStartsWith(t, 'translate');\n          const isAngle = isRotate || isSkew;\n          const syntax = isAngle ? '<angle>' : isScale ? \"<number>\" : isTranslate ? \"<length-percentage>\" : \"*\";\n          try {\n            CSS.registerProperty({\n              name: '--' + t,\n              syntax,\n              inherits: false,\n              initialValue: isTranslate ? '0px' : isAngle ? '0deg' : isScale ? '1' : '0'\n            });\n          } catch {}\n        });\n        transformsPropertiesRegistered = true;\n      }\n    }\n    const parsedTargets = registerTargets(targets);\n    const targetsLength = parsedTargets.length;\n    if (!targetsLength) {\n      console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);\n    }\n    const ease = setValue(params.ease, parseWAAPIEasing(globals.defaults.ease));\n    const spring = /** @type {Spring} */ease.ease && ease;\n    const autoplay = setValue(params.autoplay, globals.defaults.autoplay);\n    const scroll = autoplay && /** @type {ScrollObserver} */autoplay.link ? autoplay : false;\n    const alternate = params.alternate && /** @type {Boolean} */params.alternate === true;\n    const reversed = params.reversed && /** @type {Boolean} */params.reversed === true;\n    const loop = setValue(params.loop, globals.defaults.loop);\n    const iterations = /** @type {Number} */loop === true || loop === Infinity ? Infinity : isNum(loop) ? loop + 1 : 1;\n    /** @type {PlaybackDirection} */\n    const direction = alternate ? reversed ? 'alternate-reverse' : 'alternate' : reversed ? 'reverse' : 'normal';\n    /** @type {FillMode} */\n    const fill = 'forwards';\n    /** @type {String} */\n    const easing = parseWAAPIEasing(ease);\n    const timeScale = globals.timeScale === 1 ? 1 : K;\n\n    /** @type {DOMTargetsArray}] */\n    this.targets = parsedTargets;\n    /** @type {Array<globalThis.Animation>}] */\n    this.animations = [];\n    /** @type {globalThis.Animation}] */\n    this.controlAnimation = null;\n    /** @type {Callback<this>} */\n    this.onComplete = params.onComplete || noop;\n    /** @type {Number} */\n    this.duration = 0;\n    /** @type {Boolean} */\n    this.muteCallbacks = false;\n    /** @type {Boolean} */\n    this.completed = false;\n    /** @type {Boolean} */\n    this.paused = !autoplay || scroll !== false;\n    /** @type {Boolean} */\n    this.reversed = reversed;\n    /** @type {Boolean|ScrollObserver} */\n    this.autoplay = autoplay;\n    /** @type {Number} */\n    this._speed = setValue(params.playbackRate, globals.defaults.playbackRate);\n    /** @type {Function} */\n    this._resolve = noop; // Used by .then()\n    /** @type {Number} */\n    this._completed = 0;\n    /** @type {Array<Object>}] */\n    this._inlineStyles = parsedTargets.map($el => $el.getAttribute('style'));\n    parsedTargets.forEach(($el, i) => {\n      const cachedTransforms = $el[transformsSymbol];\n      const hasIndividualTransforms = validIndividualTransforms.some(t => params.hasOwnProperty(t));\n\n      /** @type {Number} */\n      const duration = (spring ? /** @type {Spring} */spring.duration : getFunctionValue(setValue(params.duration, globals.defaults.duration), $el, i, targetsLength)) * timeScale;\n      /** @type {Number} */\n      const delay = getFunctionValue(setValue(params.delay, globals.defaults.delay), $el, i, targetsLength) * timeScale;\n      /** @type {CompositeOperation} */\n      const composite = /** @type {CompositeOperation} */setValue(params.composition, 'replace');\n      for (let name in params) {\n        if (!isKey(name)) continue;\n        /** @type {PropertyIndexedKeyframes} */\n        const keyframes = {};\n        /** @type {KeyframeAnimationOptions} */\n        const tweenParams = {\n          iterations,\n          direction,\n          fill,\n          easing,\n          duration,\n          delay,\n          composite\n        };\n        const propertyValue = params[name];\n        const individualTransformProperty = hasIndividualTransforms ? validTransforms.includes(name) ? name : shortTransforms.get(name) : false;\n        let parsedPropertyValue;\n        if (isObj(propertyValue)) {\n          const tweenOptions = /** @type {WAAPITweenOptions} */propertyValue;\n          const tweenOptionsEase = setValue(tweenOptions.ease, ease);\n          const tweenOptionsSpring = /** @type {Spring} */tweenOptionsEase.ease && tweenOptionsEase;\n          const to = /** @type {WAAPITweenOptions} */tweenOptions.to;\n          const from = /** @type {WAAPITweenOptions} */tweenOptions.from;\n          /** @type {Number} */\n          tweenParams.duration = (tweenOptionsSpring ? /** @type {Spring} */tweenOptionsSpring.duration : getFunctionValue(setValue(tweenOptions.duration, duration), $el, i, targetsLength)) * timeScale;\n          /** @type {Number} */\n          tweenParams.delay = getFunctionValue(setValue(tweenOptions.delay, delay), $el, i, targetsLength) * timeScale;\n          /** @type {CompositeOperation} */\n          tweenParams.composite = /** @type {CompositeOperation} */setValue(tweenOptions.composition, composite);\n          /** @type {String} */\n          tweenParams.easing = parseWAAPIEasing(tweenOptionsEase);\n          parsedPropertyValue = parseIndividualTweenValue($el, name, from, to, i, targetsLength);\n          if (individualTransformProperty) {\n            keyframes[`--${individualTransformProperty}`] = parsedPropertyValue;\n            cachedTransforms[individualTransformProperty] = parsedPropertyValue;\n          } else {\n            keyframes[name] = parseIndividualTweenValue($el, name, from, to, i, targetsLength);\n          }\n          addWAAPIAnimation(this, $el, name, keyframes, tweenParams);\n          if (!isUnd(from)) {\n            if (!individualTransformProperty) {\n              $el.style[name] = keyframes[name][0];\n            } else {\n              const key = `--${individualTransformProperty}`;\n              $el.style.setProperty(key, keyframes[key][0]);\n            }\n          }\n        } else {\n          parsedPropertyValue = isArr(propertyValue) ? propertyValue.map((/** @type {any} */v) => normalizeTweenValue(name, v, $el, i, targetsLength)) : normalizeTweenValue(name, /** @type {any} */propertyValue, $el, i, targetsLength);\n          if (individualTransformProperty) {\n            keyframes[`--${individualTransformProperty}`] = parsedPropertyValue;\n            cachedTransforms[individualTransformProperty] = parsedPropertyValue;\n          } else {\n            keyframes[name] = parsedPropertyValue;\n          }\n          addWAAPIAnimation(this, $el, name, keyframes, tweenParams);\n        }\n      }\n      if (hasIndividualTransforms) {\n        let transforms = emptyString;\n        for (let t in cachedTransforms) {\n          transforms += `${transformsFragmentStrings[t]}var(--${t})) `;\n        }\n        $el.style.transform = transforms;\n      }\n    });\n    if (scroll) {\n      /** @type {ScrollObserver} */this.autoplay.link(this);\n    }\n  }\n\n  /**\n   * @callback forEachCallback\n   * @param {globalThis.Animation} animation\n   */\n\n  /**\n   * @param  {forEachCallback|String} callback\n   * @return {this}\n   */\n  forEach(callback) {\n    const cb = isStr(callback) ? a => a[callback]() : callback;\n    this.animations.forEach(cb);\n    return this;\n  }\n  get speed() {\n    return this._speed;\n  }\n\n  /** @param {Number} speed */\n  set speed(speed) {\n    this._speed = +speed;\n    this.forEach(anim => anim.playbackRate = speed);\n  }\n  get currentTime() {\n    const controlAnimation = this.controlAnimation;\n    const timeScale = globals.timeScale;\n    return this.completed ? this.duration : controlAnimation ? +controlAnimation.currentTime * (timeScale === 1 ? 1 : timeScale) : 0;\n  }\n\n  /** @param {Number} time */\n  set currentTime(time) {\n    const t = time * (globals.timeScale === 1 ? 1 : K);\n    this.forEach(anim => {\n      // Make sure the animation playState is not 'paused' in order to properly trigger an onfinish callback.\n      // The \"paused\" play state supersedes the \"finished\" play state; if the animation is both paused and finished, the \"paused\" state is the one that will be reported.\n      // https://developer.mozilla.org/en-US/docs/Web/API/Animation/finish_event\n      if (t >= this.duration) anim.play();\n      anim.currentTime = t;\n    });\n  }\n  get progress() {\n    return this.currentTime / this.duration;\n  }\n\n  /** @param {Number} progress */\n  set progress(progress) {\n    this.forEach(anim => anim.currentTime = progress * this.duration || 0);\n  }\n  resume() {\n    if (!this.paused) return this;\n    this.paused = false;\n    // TODO: Store the current time, and seek back to the last position\n    return this.forEach('play');\n  }\n  pause() {\n    if (this.paused) return this;\n    this.paused = true;\n    return this.forEach('pause');\n  }\n  alternate() {\n    this.reversed = !this.reversed;\n    this.forEach('reverse');\n    if (this.paused) this.forEach('pause');\n    return this;\n  }\n  play() {\n    if (this.reversed) this.alternate();\n    return this.resume();\n  }\n  reverse() {\n    if (!this.reversed) this.alternate();\n    return this.resume();\n  }\n\n  /**\n   * @param {Number} time\n   * @param {Boolean} muteCallbacks\n   */\n  seek(time, muteCallbacks = false) {\n    if (muteCallbacks) this.muteCallbacks = true;\n    if (time < this.duration) this.completed = false;\n    this.currentTime = time;\n    this.muteCallbacks = false;\n    if (this.paused) this.pause();\n    return this;\n  }\n  restart() {\n    this.completed = false;\n    return this.seek(0, true).resume();\n  }\n  commitStyles() {\n    return this.forEach('commitStyles');\n  }\n  complete() {\n    return this.seek(this.duration);\n  }\n  cancel() {\n    this.forEach('cancel');\n    return this.pause();\n  }\n  revert() {\n    this.cancel();\n    this.targets.forEach(($el, i) => $el.setAttribute('style', this._inlineStyles[i]));\n    return this;\n  }\n\n  /**\n   * @param  {WAAPICallback} [callback]\n   * @return {Promise}\n   */\n  then(callback = noop) {\n    const then = this.then;\n    const onResolve = () => {\n      this.then = null;\n      callback(this);\n      this.then = then;\n      this._resolve = noop;\n    };\n    return new Promise(r => {\n      this._resolve = () => r(onResolve());\n      if (this.completed) this._resolve();\n      return this;\n    });\n  }\n}\nconst waapi = {\n  /**\n   * @param {DOMTargetsParam} targets\n   * @param {WAAPIAnimationParams} params\n   * @return {WAAPIAnimation}\n   */\n  animate: (targets, params) => new WAAPIAnimation(targets, params),\n  convertEase: easingToLinear\n};\n\n/**\n * @param  {Callback<Timer>} [callback]\n * @return {Timer}\n */\nconst sync = (callback = noop) => {\n  return new Timer({\n    duration: 1 * globals.timeScale,\n    onComplete: callback\n  }, null, 0).resume();\n};\n\n/**\n * @overload\n * @param  {DOMTargetSelector} targetSelector\n * @param  {String}            propName\n * @return {String}\n *\n * @overload\n * @param  {JSTargetsParam} targetSelector\n * @param  {String}         propName\n * @return {Number|String}\n *\n * @overload\n * @param  {DOMTargetsParam} targetSelector\n * @param  {String}          propName\n * @param  {String}          unit\n * @return {String}\n *\n * @overload\n * @param  {TargetsParam} targetSelector\n * @param  {String}       propName\n * @param  {Boolean}      unit\n * @return {Number}\n *\n * @param  {TargetsParam}   targetSelector\n * @param  {String}         propName\n * @param  {String|Boolean} [unit]\n */\nfunction getTargetValue(targetSelector, propName, unit) {\n  const targets = registerTargets(targetSelector);\n  if (!targets.length) return;\n  const [target] = targets;\n  const tweenType = getTweenType(target, propName);\n  const normalizePropName = sanitizePropertyName(propName, target, tweenType);\n  let originalValue = getOriginalAnimatableValue(target, normalizePropName);\n  if (isUnd(unit)) {\n    return originalValue;\n  } else {\n    decomposeRawValue(originalValue, decomposedOriginalValue);\n    if (decomposedOriginalValue.t === valueTypes.NUMBER || decomposedOriginalValue.t === valueTypes.UNIT) {\n      if (unit === false) {\n        return decomposedOriginalValue.n;\n      } else {\n        const convertedValue = convertValueUnit(/** @type {DOMTarget} */target, decomposedOriginalValue, /** @type {String} */unit, false);\n        return `${round(convertedValue.n, globals.precision)}${convertedValue.u}`;\n      }\n    }\n  }\n}\n\n/**\n * @param  {TargetsParam}    targets\n * @param  {AnimationParams} parameters\n * @return {JSAnimation}\n */\nconst setTargetValues = (targets, parameters) => {\n  if (isUnd(parameters)) return;\n  parameters.duration = minValue;\n  // Do not overrides currently active tweens by default\n  parameters.composition = setValue(parameters.composition, compositionTypes.none);\n  // Skip init() and force rendering by playing the animation\n  return new JSAnimation(targets, parameters, null, 0, true).resume();\n};\n\n/**\n * @param  {TargetsArray} targetsArray\n * @param  {JSAnimation}    animation\n * @param  {String}       [propertyName]\n * @return {Boolean}\n */\nconst removeTargetsFromAnimation = (targetsArray, animation, propertyName) => {\n  let tweensMatchesTargets = false;\n  forEachChildren(animation, (/**@type {Tween} */tween) => {\n    const tweenTarget = tween.target;\n    if (targetsArray.includes(tweenTarget)) {\n      const tweenName = tween.property;\n      const tweenType = tween._tweenType;\n      const normalizePropName = sanitizePropertyName(propertyName, tweenTarget, tweenType);\n      if (!normalizePropName || normalizePropName && normalizePropName === tweenName) {\n        // Make sure to flag the previous CSS transform tween to renderTransform\n        if (tween.parent._tail === tween && tween._tweenType === tweenTypes.TRANSFORM && tween._prev && tween._prev._tweenType === tweenTypes.TRANSFORM) {\n          tween._prev._renderTransforms = 1;\n        }\n        // Removes the tween from the selected animation\n        removeChild(animation, tween);\n        // Detach the tween from its siblings to make sure blended tweens are correctlly removed\n        removeTweenSliblings(tween);\n        tweensMatchesTargets = true;\n      }\n    }\n  }, true);\n  return tweensMatchesTargets;\n};\n\n/**\n * @param  {TargetsParam} targets\n * @param  {Renderable|WAAPIAnimation} [renderable]\n * @param  {String}                    [propertyName]\n * @return {TargetsArray}\n */\nconst remove = (targets, renderable, propertyName) => {\n  const targetsArray = parseTargets(targets);\n  const parent = /** @type {Renderable|typeof engine} **/renderable ? renderable : engine;\n  const waapiAnimation = renderable && /** @type {WAAPIAnimation} */renderable.controlAnimation && (/** @type {WAAPIAnimation} */renderable);\n  for (let i = 0, l = targetsArray.length; i < l; i++) {\n    const $el = /** @type {DOMTarget}  */targetsArray[i];\n    removeWAAPIAnimation($el, propertyName, waapiAnimation);\n  }\n  let removeMatches;\n  if (parent._hasChildren) {\n    let iterationDuration = 0;\n    forEachChildren(parent, (/** @type {Renderable} */child) => {\n      if (!child._hasChildren) {\n        removeMatches = removeTargetsFromAnimation(targetsArray, /** @type {JSAnimation} */child, propertyName);\n        // Remove the child from its parent if no tweens and no children left after the removal\n        if (removeMatches && !child._head) {\n          child.cancel();\n          removeChild(parent, child);\n        } else {\n          // Calculate the new iterationDuration value to handle onComplete with last child in render()\n          const childTLOffset = child._offset + child._delay;\n          const childDur = childTLOffset + child.duration;\n          if (childDur > iterationDuration) {\n            iterationDuration = childDur;\n          }\n        }\n      }\n      // Make sure to also remove engine's children targets\n      // NOTE: Avoid recursion?\n      if (child._head) {\n        remove(targets, child, propertyName);\n      } else {\n        child._hasChildren = false;\n      }\n    }, true);\n    // Update iterationDuration value to handle onComplete with last child in render()\n    if (!isUnd(/** @type {Renderable} */parent.iterationDuration)) {\n      /** @type {Renderable} */parent.iterationDuration = iterationDuration;\n    }\n  } else {\n    removeMatches = removeTargetsFromAnimation(targetsArray, /** @type {JSAnimation} */parent, propertyName);\n  }\n  if (removeMatches && !parent._head) {\n    parent._hasChildren = false;\n    // Cancel the parent if there are no tweens and no children left after the removal\n    // We have to check if the .cancel() method exist to handle cases where the parent is the engine itself\n    if (/** @type {Renderable} */parent.cancel) /** @type {Renderable} */parent.cancel();\n  }\n  return targetsArray;\n};\n\n/**\n * @param  {(...args: any[]) => Tickable} constructor\n * @return {(...args: any[]) => Tickable}\n */\nconst keepTime = createRefreshable;\n\n/**\n * @param  {String|Array} items\n * @return {any}\n */\nconst randomPick = items => items[random(0, items.length - 1)];\n\n/**\n * @param  {Number|String} v\n * @param  {Number} decimalLength\n * @return {String}\n */\nconst roundPad = (v, decimalLength) => (+v).toFixed(decimalLength);\n\n/**\n * @param  {Number} v\n * @param  {Number} totalLength\n * @param  {String} padString\n * @return {String}\n */\nconst padStart = (v, totalLength, padString) => `${v}`.padStart(totalLength, padString);\n\n/**\n * @param  {Number} v\n * @param  {Number} totalLength\n * @param  {String} padString\n * @return {String}\n */\nconst padEnd = (v, totalLength, padString) => `${v}`.padEnd(totalLength, padString);\n\n/**\n * @param  {Number} v\n * @param  {Number} min\n * @param  {Number} max\n * @return {Number}\n */\nconst wrap = (v, min, max) => ((v - min) % (max - min) + (max - min)) % (max - min) + min;\n\n/**\n * @param  {Number} value\n * @param  {Number} inLow\n * @param  {Number} inHigh\n * @param  {Number} outLow\n * @param  {Number} outHigh\n * @return {Number}\n */\nconst mapRange = (value, inLow, inHigh, outLow, outHigh) => outLow + (value - inLow) / (inHigh - inLow) * (outHigh - outLow);\n\n/**\n * @param  {Number} degrees\n * @return {Number}\n */\nconst degToRad = degrees => degrees * PI / 180;\n\n/**\n * @param  {Number} radians\n * @return {Number}\n */\nconst radToDeg = radians => radians * 180 / PI;\n\n/**\n * https://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\n * @param  {Number} start\n * @param  {Number} end\n * @param  {Number} amount\n * @param  {Renderable|Boolean} [renderable]\n * @return {Number}\n */\nconst lerp = (start, end, amount, renderable) => {\n  let dt = K / globals.defaults.frameRate;\n  if (renderable !== false) {\n    const ticker = /** @type Renderable */\n    renderable || engine._hasChildren && engine;\n    if (ticker && ticker.deltaTime) {\n      dt = ticker.deltaTime;\n    }\n  }\n  const t = 1 - Math.exp(-amount * dt * .1);\n  return !amount ? start : amount === 1 ? end : (1 - t) * start + t * end;\n};\n\n// Chain-able utilities\n\n/**\n * @callback UtilityFunction\n * @param {...*} args\n * @return {Number|String}\n *\n * @param {UtilityFunction} fn\n * @param {Number} [last=0]\n * @return {function(...(Number|String)): function(Number|String): (Number|String)}\n */\nconst curry = (fn, last = 0) => (...args) => last ? v => fn(...args, v) : v => fn(v, ...args);\n\n/**\n * @param {Function} fn\n * @return {function(...(Number|String))}\n */\nconst chain = fn => {\n  return (...args) => {\n    const result = fn(...args);\n    return new Proxy(noop, {\n      apply: (_, __, [v]) => result(v),\n      get: (_, prop) => chain(/**@param {...Number|String} nextArgs */(...nextArgs) => {\n        const nextResult = utils[prop](...nextArgs);\n        return (/**@type {Number|String} */v) => nextResult(result(v));\n      })\n    });\n  };\n};\n\n/**\n * @param {UtilityFunction} fn\n * @param {Number} [right]\n * @return {function(...(Number|String)): UtilityFunction}\n */\nconst makeChainable = (fn, right = 0) => (...args) => (args.length < fn.length ? chain(curry(fn, right)) : fn)(...args);\n\n/**\n * @callback ChainedUtilsResult\n * @param {Number} value\n * @return {Number}\n *\n * @typedef {Object} ChainableUtils\n * @property {ChainedClamp} clamp\n * @property {ChainedRound} round\n * @property {ChainedSnap} snap\n * @property {ChainedWrap} wrap\n * @property {ChainedInterpolate} interpolate\n * @property {ChainedMapRange} mapRange\n * @property {ChainedRoundPad} roundPad\n * @property {ChainedPadStart} padStart\n * @property {ChainedPadEnd} padEnd\n * @property {ChainedDegToRad} degToRad\n * @property {ChainedRadToDeg} radToDeg\n *\n * @typedef {ChainableUtils & ChainedUtilsResult} ChainableUtil\n *\n * @callback ChainedClamp\n * @param {Number} min\n * @param {Number} max\n * @return {ChainableUtil}\n *\n * @callback ChainedRound\n * @param {Number} decimalLength\n * @return {ChainableUtil}\n *\n * @callback ChainedSnap\n * @param {Number} increment\n * @return {ChainableUtil}\n *\n * @callback ChainedWrap\n * @param {Number} min\n * @param {Number} max\n * @return {ChainableUtil}\n *\n * @callback ChainedInterpolate\n * @param {Number} start\n * @param {Number} end\n * @return {ChainableUtil}\n *\n * @callback ChainedMapRange\n * @param {Number} inLow\n * @param {Number} inHigh\n * @param {Number} outLow\n * @param {Number} outHigh\n * @return {ChainableUtil}\n *\n * @callback ChainedRoundPad\n * @param {Number} decimalLength\n * @return {ChainableUtil}\n *\n * @callback ChainedPadStart\n * @param {Number} totalLength\n * @param {String} padString\n * @return {ChainableUtil}\n *\n * @callback ChainedPadEnd\n * @param {Number} totalLength\n * @param {String} padString\n * @return {ChainableUtil}\n *\n * @callback ChainedDegToRad\n * @return {ChainableUtil}\n *\n * @callback ChainedRadToDeg\n * @return {ChainableUtil}\n */\n\nconst utils = {\n  $: registerTargets,\n  get: getTargetValue,\n  set: setTargetValues,\n  remove,\n  cleanInlineStyles,\n  random,\n  randomPick,\n  shuffle,\n  lerp,\n  sync,\n  keepTime,\n  clamp: (/** @type {typeof clamp & ChainedClamp} */makeChainable(clamp)),\n  round: (/** @type {typeof round & ChainedRound} */makeChainable(round)),\n  snap: (/** @type {typeof snap & ChainedSnap} */makeChainable(snap)),\n  wrap: (/** @type {typeof wrap & ChainedWrap} */makeChainable(wrap)),\n  interpolate: (/** @type {typeof interpolate & ChainedInterpolate} */makeChainable(interpolate, 1)),\n  mapRange: (/** @type {typeof mapRange & ChainedMapRange} */makeChainable(mapRange)),\n  roundPad: (/** @type {typeof roundPad & ChainedRoundPad} */makeChainable(roundPad)),\n  padStart: (/** @type {typeof padStart & ChainedPadStart} */makeChainable(padStart)),\n  padEnd: (/** @type {typeof padEnd & ChainedPadEnd} */makeChainable(padEnd)),\n  degToRad: (/** @type {typeof degToRad & ChainedDegToRad} */makeChainable(degToRad)),\n  radToDeg: (/** @type {typeof radToDeg & ChainedRadToDeg} */makeChainable(radToDeg))\n};\n\n/**\n * @typedef {Number|String|Function} TimePosition\n */\n\n/**\n * Timeline's children offsets positions parser\n * @param  {Timeline} timeline\n * @param  {String} timePosition\n * @return {Number}\n */\nconst getPrevChildOffset = (timeline, timePosition) => {\n  if (stringStartsWith(timePosition, '<')) {\n    const goToPrevAnimationOffset = timePosition[1] === '<';\n    const prevAnimation = /** @type {Tickable} */timeline._tail;\n    const prevOffset = prevAnimation ? prevAnimation._offset + prevAnimation._delay : 0;\n    return goToPrevAnimationOffset ? prevOffset : prevOffset + prevAnimation.duration;\n  }\n};\n\n/**\n * @param  {Timeline} timeline\n * @param  {TimePosition} [timePosition]\n * @return {Number}\n */\nconst parseTimelinePosition = (timeline, timePosition) => {\n  let tlDuration = timeline.iterationDuration;\n  if (tlDuration === minValue) tlDuration = 0;\n  if (isUnd(timePosition)) return tlDuration;\n  if (isNum(+timePosition)) return +timePosition;\n  const timePosStr = /** @type {String} */timePosition;\n  const tlLabels = timeline ? timeline.labels : null;\n  const hasLabels = !isNil(tlLabels);\n  const prevOffset = getPrevChildOffset(timeline, timePosStr);\n  const hasSibling = !isUnd(prevOffset);\n  const matchedRelativeOperator = relativeValuesExecRgx.exec(timePosStr);\n  if (matchedRelativeOperator) {\n    const fullOperator = matchedRelativeOperator[0];\n    const split = timePosStr.split(fullOperator);\n    const labelOffset = hasLabels && split[0] ? tlLabels[split[0]] : tlDuration;\n    const parsedOffset = hasSibling ? prevOffset : hasLabels ? labelOffset : tlDuration;\n    const parsedNumericalOffset = +split[1];\n    return getRelativeValue(parsedOffset, parsedNumericalOffset, fullOperator[0]);\n  } else {\n    return hasSibling ? prevOffset : hasLabels ? !isUnd(tlLabels[timePosStr]) ? tlLabels[timePosStr] : tlDuration : tlDuration;\n  }\n};\n\n/**\n * @param {Timeline} tl\n * @return {Number}\n */\nfunction getTimelineTotalDuration(tl) {\n  return clampInfinity((tl.iterationDuration + tl._loopDelay) * tl.iterationCount - tl._loopDelay) || minValue;\n}\n\n/**\n * @overload\n * @param  {TimerParams} childParams\n * @param  {Timeline} tl\n * @param  {Number} timePosition\n * @return {Timeline}\n *\n * @overload\n * @param  {AnimationParams} childParams\n * @param  {Timeline} tl\n * @param  {Number} timePosition\n * @param  {TargetsParam} targets\n * @param  {Number} [index]\n * @param  {Number} [length]\n * @return {Timeline}\n *\n * @param  {TimerParams|AnimationParams} childParams\n * @param  {Timeline} tl\n * @param  {Number} timePosition\n * @param  {TargetsParam} [targets]\n * @param  {Number} [index]\n * @param  {Number} [length]\n */\nfunction addTlChild(childParams, tl, timePosition, targets, index, length) {\n  const isSetter = isNum(childParams.duration) && /** @type {Number} */childParams.duration <= minValue;\n  // Offset the tl position with -minValue for 0 duration animations or .set() calls in order to align their end value with the defined position\n  const adjustedPosition = isSetter ? timePosition - minValue : timePosition;\n  tick(tl, adjustedPosition, 1, 1, tickModes.AUTO);\n  const tlChild = targets ? new JSAnimation(targets, /** @type {AnimationParams} */childParams, tl, adjustedPosition, false, index, length) : new Timer(/** @type {TimerParams} */childParams, tl, adjustedPosition);\n  tlChild.init(1);\n  // TODO: Might be better to insert at a position relative to startTime?\n  addChild(tl, tlChild);\n  forEachChildren(tl, (/** @type {Renderable} */child) => {\n    const childTLOffset = child._offset + child._delay;\n    const childDur = childTLOffset + child.duration;\n    if (childDur > tl.iterationDuration) tl.iterationDuration = childDur;\n  });\n  tl.duration = getTimelineTotalDuration(tl);\n  return tl;\n}\nclass Timeline extends Timer {\n  /**\n   * @param {TimelineParams} [parameters]\n   */\n  constructor(parameters = {}) {\n    super(/** @type {TimerParams&TimelineParams} */parameters, null, 0);\n    /** @type {Number} */\n    this.duration = 0; // TL duration starts at 0 and grows when adding children\n    /** @type {Record<String, Number>} */\n    this.labels = {};\n    const defaultsParams = parameters.defaults;\n    const globalDefaults = globals.defaults;\n    /** @type {DefaultsParams} */\n    this.defaults = defaultsParams ? mergeObjects(defaultsParams, globalDefaults) : globalDefaults;\n    /** @type {Callback<this>} */\n    this.onRender = parameters.onRender || globalDefaults.onRender;\n    const tlPlaybackEase = setValue(parameters.playbackEase, globalDefaults.playbackEase);\n    this._ease = tlPlaybackEase ? parseEasings(tlPlaybackEase) : null;\n    /** @type {Number} */\n    this.iterationDuration = 0;\n  }\n\n  /**\n   * @overload\n   * @param {TargetsParam} a1\n   * @param {AnimationParams} a2\n   * @param {TimePosition} [a3]\n   * @return {this}\n   *\n   * @overload\n   * @param {TimerParams} a1\n   * @param {TimePosition} [a2]\n   * @return {this}\n   *\n   * @param {TargetsParam|TimerParams} a1\n   * @param {AnimationParams|TimePosition} a2\n   * @param {TimePosition} [a3]\n   */\n  add(a1, a2, a3) {\n    const isAnim = isObj(a2);\n    const isTimer = isObj(a1);\n    if (isAnim || isTimer) {\n      this._hasChildren = true;\n      if (isAnim) {\n        const childParams = /** @type {AnimationParams} */a2;\n        // Check for function for children stagger positions\n        if (isFnc(a3)) {\n          const staggeredPosition = /** @type {Function} */a3;\n          const parsedTargetsArray = parseTargets(/** @type {TargetsParam} */a1);\n          // Store initial duration before adding new children that will change the duration\n          const tlDuration = this.duration;\n          // Store initial _iterationDuration before adding new children that will change the duration\n          const tlIterationDuration = this.iterationDuration;\n          // Store the original id in order to add specific indexes to the new animations ids\n          const id = childParams.id;\n          let i = 0;\n          const parsedLength = parsedTargetsArray.length;\n          parsedTargetsArray.forEach((/** @type {Target} */target) => {\n            // Create a new parameter object for each staggered children\n            const staggeredChildParams = {\n              ...childParams\n            };\n            // Reset the duration of the timeline iteration before each stagger to prevent wrong start value calculation\n            this.duration = tlDuration;\n            this.iterationDuration = tlIterationDuration;\n            if (!isUnd(id)) staggeredChildParams.id = id + '-' + i;\n            addTlChild(staggeredChildParams, this, staggeredPosition(target, i, parsedLength, this), target, i, parsedLength);\n            i++;\n          });\n        } else {\n          addTlChild(childParams, this, parseTimelinePosition(this, a3), /** @type {TargetsParam} */a1);\n        }\n      } else {\n        // It's a Timer\n        addTlChild(/** @type TimerParams */a1, this, parseTimelinePosition(this, /** @type TimePosition */a2));\n      }\n      return this.init(1); // 1 = internalRender\n    }\n  }\n\n  /**\n   * @overload\n   * @param {Tickable} [synced]\n   * @param {TimePosition} [position]\n   * @return {this}\n   *\n   * @overload\n   * @param {globalThis.Animation} [synced]\n   * @param {TimePosition} [position]\n   * @return {this}\n   *\n   * @overload\n   * @param {WAAPIAnimation} [synced]\n   * @param {TimePosition} [position]\n   * @return {this}\n   *\n   * @param {Tickable|WAAPIAnimation|globalThis.Animation} [synced]\n   * @param {TimePosition} [position]\n   */\n  sync(synced, position) {\n    if (isUnd(synced) || synced && isUnd(synced.pause)) return this;\n    synced.pause();\n    const duration = +(/** @type {globalThis.Animation} */synced.effect ? /** @type {globalThis.Animation} */synced.effect.getTiming().duration : /** @type {Tickable} */synced.duration);\n    return this.add(synced, {\n      currentTime: [0, duration],\n      duration,\n      ease: 'linear'\n    }, position);\n  }\n\n  /**\n   * @param  {TargetsParam} targets\n   * @param  {AnimationParams} parameters\n   * @param  {TimePosition} [position]\n   * @return {this}\n   */\n  set(targets, parameters, position) {\n    if (isUnd(parameters)) return this;\n    parameters.duration = minValue;\n    parameters.composition = compositionTypes.replace;\n    return this.add(targets, parameters, position);\n  }\n\n  /**\n   * @param {Callback<Timer>} callback\n   * @param {TimePosition} [position]\n   * @return {this}\n   */\n  call(callback, position) {\n    if (isUnd(callback) || callback && !isFnc(callback)) return this;\n    return this.add({\n      duration: 0,\n      onComplete: () => callback(this)\n    }, position);\n  }\n\n  /**\n   * @param {String} labelName\n   * @param {TimePosition} [position]\n   * @return {this}\n   *\n   */\n  label(labelName, position) {\n    if (isUnd(labelName) || labelName && !isStr(labelName)) return this;\n    this.labels[labelName] = parseTimelinePosition(this, /** @type TimePosition */position);\n    return this;\n  }\n\n  /**\n   * @param  {TargetsParam} targets\n   * @param  {String} [propertyName]\n   * @return {this}\n   */\n  remove(targets, propertyName) {\n    remove(targets, this, propertyName);\n    return this;\n  }\n\n  /**\n   * @param  {Number} newDuration\n   * @return {this}\n   */\n  stretch(newDuration) {\n    const currentDuration = this.duration;\n    if (currentDuration === normalizeTime(newDuration)) return this;\n    const timeScale = newDuration / currentDuration;\n    const labels = this.labels;\n    forEachChildren(this, (/** @type {JSAnimation} */child) => child.stretch(child.duration * timeScale));\n    for (let labelName in labels) labels[labelName] *= timeScale;\n    return super.stretch(newDuration);\n  }\n\n  /**\n   * @return {this}\n   */\n  refresh() {\n    forEachChildren(this, (/** @type {JSAnimation} */child) => {\n      if (child.refresh) child.refresh();\n    });\n    return this;\n  }\n\n  /**\n   * @return {this}\n   */\n  revert() {\n    super.revert();\n    forEachChildren(this, (/** @type {JSAnimation} */child) => child.revert, true);\n    return cleanInlineStyles(this);\n  }\n\n  /**\n   * @param  {Callback<this>} [callback]\n   * @return {Promise}\n   */\n  then(callback) {\n    return super.then(callback);\n  }\n}\n\n/**\n * @param {TimelineParams} [parameters]\n * @return {Timeline}\n */\nconst createTimeline = parameters => new Timeline(parameters).init();\nclass Animatable {\n  /**\n   * @param {TargetsParam} targets\n   * @param {AnimatableParams} parameters\n   */\n  constructor(targets, parameters) {\n    if (scope.current) scope.current.register(this);\n    /** @type {AnimationParams} */\n    const globalParams = {};\n    const properties = {};\n    this.targets = [];\n    this.animations = {};\n    if (isUnd(targets) || isUnd(parameters)) return;\n    for (let propName in parameters) {\n      const paramValue = parameters[propName];\n      if (isKey(propName)) {\n        properties[propName] = paramValue;\n      } else {\n        globalParams[propName] = paramValue;\n      }\n    }\n    for (let propName in properties) {\n      const propValue = properties[propName];\n      const isObjValue = isObj(propValue);\n      /** @type {TweenParamsOptions} */\n      let propParams = {};\n      let to = '+=0';\n      if (isObjValue) {\n        const unit = propValue.unit;\n        if (isStr(unit)) to += unit;\n      } else {\n        propParams.duration = propValue;\n      }\n      propParams[propName] = isObjValue ? mergeObjects({\n        to\n      }, propValue) : to;\n      const animParams = mergeObjects(globalParams, propParams);\n      animParams.composition = compositionTypes.replace;\n      animParams.autoplay = false;\n      const animation = this.animations[propName] = new JSAnimation(targets, animParams, null, 0, false).init();\n      if (!this.targets.length) this.targets.push(...animation.targets);\n      /** @type {AnimatableProperty} */\n      this[propName] = (to, duration, ease) => {\n        const tween = /** @type {Tween} */animation._head;\n        if (isUnd(to) && tween) {\n          const numbers = tween._numbers;\n          if (numbers && numbers.length) {\n            return numbers;\n          } else {\n            return tween._modifier(tween._number);\n          }\n        } else {\n          forEachChildren(animation, (/** @type {Tween} */tween) => {\n            if (isArr(to)) {\n              for (let i = 0, l = /** @type {Array} */to.length; i < l; i++) {\n                if (!isUnd(tween._numbers[i])) {\n                  tween._fromNumbers[i] = /** @type {Number} */tween._modifier(tween._numbers[i]);\n                  tween._toNumbers[i] = to[i];\n                }\n              }\n            } else {\n              tween._fromNumber = /** @type {Number} */tween._modifier(tween._number);\n              tween._toNumber = /** @type {Number} */to;\n            }\n            if (!isUnd(ease)) tween._ease = parseEasings(ease);\n            tween._currentTime = 0;\n          });\n          if (!isUnd(duration)) animation.stretch(duration);\n          animation.reset(1).resume();\n          return this;\n        }\n      };\n    }\n  }\n  revert() {\n    for (let propName in this.animations) {\n      this[propName] = noop;\n      this.animations[propName].revert();\n    }\n    this.animations = {};\n    this.targets.length = 0;\n    return this;\n  }\n}\n\n/**\n * @param {TargetsParam} targets\n * @param {AnimatableParams} parameters\n * @return {AnimatableObject}\n */\nconst createAnimatable = (targets, parameters) => (/** @type {AnimatableObject} */new Animatable(targets, parameters));\n\n/*\n * Spring ease solver adapted from https://webkit.org/demos/spring/spring.js\n * Webkit Copyright © 2016 Apple Inc\n */\n\n/**\n * @typedef {Object} SpringParams\n * @property {Number} [mass=1] - Mass, default 1\n * @property {Number} [stiffness=100] - Stiffness, default 100\n * @property {Number} [damping=10] - Damping, default 10\n * @property {Number} [velocity=0] - Initial velocity, default 0\n */\n\nclass Spring {\n  /**\n   * @param {SpringParams} [parameters]\n   */\n  constructor(parameters = {}) {\n    this.timeStep = .02; // Interval fed to the solver to calculate duration\n    this.restThreshold = .0005; // Values below this threshold are considered resting position\n    this.restDuration = 200; // Duration in ms used to check if the spring is resting after reaching restThreshold\n    this.maxDuration = 60000; // The maximum allowed spring duration in ms (default 1 min)\n    this.maxRestSteps = this.restDuration / this.timeStep / K; // How many steps allowed after reaching restThreshold before stopping the duration calculation\n    this.maxIterations = this.maxDuration / this.timeStep / K; // Calculate the maximum iterations allowed based on maxDuration\n    this.m = clamp(setValue(parameters.mass, 1), 0, K);\n    this.s = clamp(setValue(parameters.stiffness, 100), 1, K);\n    this.d = clamp(setValue(parameters.damping, 10), .1, K);\n    this.v = clamp(setValue(parameters.velocity, 0), -1e3, K);\n    this.w0 = 0;\n    this.zeta = 0;\n    this.wd = 0;\n    this.b = 0;\n    this.solverDuration = 0;\n    this.duration = 0;\n    this.compute();\n    /** @type {EasingFunction} */\n    this.ease = t => t === 0 || t === 1 ? t : this.solve(t * this.solverDuration);\n  }\n\n  /** @type {EasingFunction} */\n  solve(time) {\n    const {\n      zeta,\n      w0,\n      wd,\n      b\n    } = this;\n    let t = time;\n    if (zeta < 1) {\n      t = exp(-t * zeta * w0) * (1 * cos(wd * t) + b * sin(wd * t));\n    } else {\n      t = (1 + b * t) * exp(-t * w0);\n    }\n    return 1 - t;\n  }\n  compute() {\n    const {\n      maxRestSteps,\n      maxIterations,\n      restThreshold,\n      timeStep,\n      m,\n      d,\n      s,\n      v\n    } = this;\n    const w0 = this.w0 = clamp(sqrt(s / m), minValue, K);\n    const zeta = this.zeta = d / (2 * sqrt(s * m));\n    const wd = this.wd = zeta < 1 ? w0 * sqrt(1 - zeta * zeta) : 0;\n    this.b = zeta < 1 ? (zeta * w0 + -v) / wd : -v + w0;\n    let solverTime = 0;\n    let restSteps = 0;\n    let iterations = 0;\n    while (restSteps < maxRestSteps && iterations < maxIterations) {\n      if (abs(1 - this.solve(solverTime)) < restThreshold) {\n        restSteps++;\n      } else {\n        restSteps = 0;\n      }\n      this.solverDuration = solverTime;\n      solverTime += timeStep;\n      iterations++;\n    }\n    this.duration = round(this.solverDuration * K, 0) * globals.timeScale;\n  }\n  get mass() {\n    return this.m;\n  }\n  set mass(v) {\n    this.m = clamp(setValue(v, 1), 0, K);\n    this.compute();\n  }\n  get stiffness() {\n    return this.s;\n  }\n  set stiffness(v) {\n    this.s = clamp(setValue(v, 100), 1, K);\n    this.compute();\n  }\n  get damping() {\n    return this.d;\n  }\n  set damping(v) {\n    this.d = clamp(setValue(v, 10), .1, K);\n    this.compute();\n  }\n  get velocity() {\n    return this.v;\n  }\n  set velocity(v) {\n    this.v = clamp(setValue(v, 0), -1e3, K);\n    this.compute();\n  }\n}\n\n/**\n * @param {SpringParams} [parameters]\n * @returns {Spring}\n */\nconst createSpring = parameters => new Spring(parameters);\n\n/**\n * @param {Event} e\n */\nconst preventDefault = e => {\n  if (e.cancelable) e.preventDefault();\n};\nclass DOMProxy {\n  /** @param {Object} el */\n  constructor(el) {\n    this.el = el;\n    this.zIndex = 0;\n    this.parentElement = null;\n    this.classList = {\n      add: noop,\n      remove: noop\n    };\n  }\n  get x() {\n    return this.el.x || 0;\n  }\n  set x(v) {\n    this.el.x = v;\n  }\n  get y() {\n    return this.el.y || 0;\n  }\n  set y(v) {\n    this.el.y = v;\n  }\n  get width() {\n    return this.el.width || 0;\n  }\n  set width(v) {\n    this.el.width = v;\n  }\n  get height() {\n    return this.el.height || 0;\n  }\n  set height(v) {\n    this.el.height = v;\n  }\n  getBoundingClientRect() {\n    return {\n      top: this.y,\n      right: this.x,\n      bottom: this.y + this.height,\n      left: this.x + this.width\n    };\n  }\n}\nclass Transforms {\n  /**\n   * @param {DOMTarget|DOMProxy} $el\n   */\n  constructor($el) {\n    this.$el = $el;\n    this.inlineTransforms = [];\n    this.point = new DOMPoint();\n    this.inversedMatrix = this.getMatrix().inverse();\n  }\n\n  /**\n   * @param {Number} x\n   * @param {Number} y\n   * @return {DOMPoint}\n   */\n  normalizePoint(x, y) {\n    this.point.x = x;\n    this.point.y = y;\n    return this.point.matrixTransform(this.inversedMatrix);\n  }\n\n  /**\n   * @callback TraverseParentsCallback\n   * @param {DOMTarget} $el\n   * @param {Number} i\n   */\n\n  /**\n   * @param {TraverseParentsCallback} cb\n   */\n  traverseUp(cb) {\n    let $el = /** @type {DOMTarget|Document} */this.$el.parentElement,\n      i = 0;\n    while ($el && $el !== doc) {\n      cb(/** @type {DOMTarget} */$el, i);\n      $el = /** @type {DOMTarget} */$el.parentElement;\n      i++;\n    }\n  }\n  getMatrix() {\n    const matrix = new DOMMatrix();\n    this.traverseUp($el => {\n      const transformValue = getComputedStyle($el).transform;\n      if (transformValue) {\n        const elMatrix = new DOMMatrix(transformValue);\n        matrix.preMultiplySelf(elMatrix);\n      }\n    });\n    return matrix;\n  }\n  remove() {\n    this.traverseUp(($el, i) => {\n      this.inlineTransforms[i] = $el.style.transform;\n      $el.style.transform = 'none';\n    });\n  }\n  revert() {\n    this.traverseUp(($el, i) => {\n      const ct = this.inlineTransforms[i];\n      if (ct === '') {\n        $el.style.removeProperty('transform');\n      } else {\n        $el.style.transform = ct;\n      }\n    });\n  }\n}\n\n/**\n * @template {Array<Number>|DOMTargetSelector|String|Number|Boolean|Function|DraggableCursorParams} T\n * @param {T | ((draggable: Draggable) => T)} value\n * @param {Draggable} draggable\n * @return {T}\n */\nconst parseDraggableFunctionParameter = (value, draggable) => value && isFnc(value) ? /** @type {Function} */value(draggable) : value;\nlet zIndex = 0;\nclass Draggable {\n  /**\n   * @param {TargetsParam} target\n   * @param {DraggableParams} [parameters]\n   */\n  constructor(target, parameters = {}) {\n    if (!target) return;\n    if (scope.current) scope.current.register(this);\n    const paramX = parameters.x;\n    const paramY = parameters.y;\n    const trigger = parameters.trigger;\n    const modifier = parameters.modifier;\n    const ease = parameters.releaseEase;\n    const customEase = ease && parseEasings(ease);\n    const hasSpring = !isUnd(ease) && !isUnd(/** @type {Spring} */ease.ease);\n    const xProp = /** @type {String} */isObj(paramX) && !isUnd(/** @type {Object} */paramX.mapTo) ? /** @type {Object} */paramX.mapTo : 'translateX';\n    const yProp = /** @type {String} */isObj(paramY) && !isUnd(/** @type {Object} */paramY.mapTo) ? /** @type {Object} */paramY.mapTo : 'translateY';\n    const container = parseDraggableFunctionParameter(parameters.container, this);\n    this.containerArray = isArr(container) ? container : null;\n    this.$container = /** @type {HTMLElement} */container && !this.containerArray ? parseTargets(/** @type {DOMTarget} */container)[0] : doc.body;\n    this.useWin = this.$container === doc.body;\n    /** @type {Window | HTMLElement} */\n    this.$scrollContainer = this.useWin ? win : this.$container;\n    this.$target = /** @type {HTMLElement} */isObj(target) ? new DOMProxy(target) : parseTargets(target)[0];\n    this.$trigger = /** @type {HTMLElement} */parseTargets(trigger ? trigger : target)[0];\n    this.fixed = getTargetValue(this.$target, 'position') === 'fixed';\n    // Refreshable parameters\n    this.isFinePointer = true;\n    /** @type {[Number, Number, Number, Number]} */\n    this.containerPadding = [0, 0, 0, 0];\n    /** @type {Number} */\n    this.containerFriction = 0;\n    /** @type {Number} */\n    this.releaseContainerFriction = 0;\n    /** @type {Number|Array<Number>} */\n    this.snapX = 0;\n    /** @type {Number|Array<Number>} */\n    this.snapY = 0;\n    /** @type {Number} */\n    this.scrollSpeed = 0;\n    /** @type {Number} */\n    this.scrollThreshold = 0;\n    /** @type {Number} */\n    this.dragSpeed = 0;\n    /** @type {Number} */\n    this.maxVelocity = 0;\n    /** @type {Number} */\n    this.minVelocity = 0;\n    /** @type {Number} */\n    this.velocityMultiplier = 0;\n    /** @type {Boolean|DraggableCursorParams} */\n    this.cursor = false;\n    /** @type {Spring} */\n    this.releaseXSpring = hasSpring ? (/** @type {Spring} */ease) : createSpring({\n      mass: setValue(parameters.releaseMass, 1),\n      stiffness: setValue(parameters.releaseStiffness, 80),\n      damping: setValue(parameters.releaseDamping, 20)\n    });\n    /** @type {Spring} */\n    this.releaseYSpring = hasSpring ? (/** @type {Spring} */ease) : createSpring({\n      mass: setValue(parameters.releaseMass, 1),\n      stiffness: setValue(parameters.releaseStiffness, 80),\n      damping: setValue(parameters.releaseDamping, 20)\n    });\n    /** @type {EasingFunction} */\n    this.releaseEase = customEase || eases.outQuint;\n    /** @type {Boolean} */\n    this.hasReleaseSpring = hasSpring;\n    /** @type {Callback<this>} */\n    this.onGrab = parameters.onGrab || noop;\n    /** @type {Callback<this>} */\n    this.onDrag = parameters.onDrag || noop;\n    /** @type {Callback<this>} */\n    this.onRelease = parameters.onRelease || noop;\n    /** @type {Callback<this>} */\n    this.onUpdate = parameters.onUpdate || noop;\n    /** @type {Callback<this>} */\n    this.onSettle = parameters.onSettle || noop;\n    /** @type {Callback<this>} */\n    this.onSnap = parameters.onSnap || noop;\n    /** @type {Callback<this>} */\n    this.onResize = parameters.onResize || noop;\n    /** @type {Callback<this>} */\n    this.onAfterResize = parameters.onAfterResize || noop;\n    /** @type {[Number, Number]} */\n    this.disabled = [0, 0];\n    /** @type {AnimatableParams} */\n    const animatableParams = {};\n    if (modifier) animatableParams.modifier = modifier;\n    if (isUnd(paramX) || paramX === true) {\n      animatableParams[xProp] = 0;\n    } else if (isObj(paramX)) {\n      const paramXObject = /** @type {DraggableAxisParam} */paramX;\n      const animatableXParams = {};\n      if (paramXObject.modifier) animatableXParams.modifier = paramXObject.modifier;\n      if (paramXObject.composition) animatableXParams.composition = paramXObject.composition;\n      animatableParams[xProp] = animatableXParams;\n    } else if (paramX === false) {\n      animatableParams[xProp] = 0;\n      this.disabled[0] = 1;\n    }\n    if (isUnd(paramY) || paramY === true) {\n      animatableParams[yProp] = 0;\n    } else if (isObj(paramY)) {\n      const paramYObject = /** @type {DraggableAxisParam} */paramY;\n      const animatableYParams = {};\n      if (paramYObject.modifier) animatableYParams.modifier = paramYObject.modifier;\n      if (paramYObject.composition) animatableYParams.composition = paramYObject.composition;\n      animatableParams[yProp] = animatableYParams;\n    } else if (paramY === false) {\n      animatableParams[yProp] = 0;\n      this.disabled[1] = 1;\n    }\n    /** @type {AnimatableObject} */\n    this.animate = /** @type {AnimatableObject} */new Animatable(this.$target, animatableParams);\n    // Internal props\n    this.xProp = xProp;\n    this.yProp = yProp;\n    this.destX = 0;\n    this.destY = 0;\n    this.deltaX = 0;\n    this.deltaY = 0;\n    this.scroll = {\n      x: 0,\n      y: 0\n    };\n    /** @type {[Number, Number, Number, Number]} */\n    this.coords = [this.x, this.y, 0, 0]; // x, y, temp x, temp y\n    /** @type {[Number, Number]} */\n    this.snapped = [0, 0]; // x, y\n    /** @type {[Number, Number, Number, Number, Number, Number, Number, Number]} */\n    this.pointer = [0, 0, 0, 0, 0, 0, 0, 0]; // x1, y1, x2, y2, temp x1, temp y1, temp x2, temp y2\n    /** @type {[Number, Number]} */\n    this.scrollView = [0, 0]; // w, h\n    /** @type {[Number, Number, Number, Number]} */\n    this.dragArea = [0, 0, 0, 0]; // x, y, w, h\n    /** @type {[Number, Number, Number, Number]} */\n    this.containerBounds = [-1e12, maxValue, maxValue, -1e12]; // t, r, b, l\n    /** @type {[Number, Number, Number, Number]} */\n    this.scrollBounds = [0, 0, 0, 0]; // t, r, b, l\n    /** @type {[Number, Number, Number, Number]} */\n    this.targetBounds = [0, 0, 0, 0]; // t, r, b, l\n    /** @type {[Number, Number]} */\n    this.window = [0, 0]; // w, h\n    /** @type {[Number, Number, Number]} */\n    this.velocityStack = [0, 0, 0];\n    /** @type {Number} */\n    this.velocityStackIndex = 0;\n    /** @type {Number} */\n    this.velocityTime = now();\n    /** @type {Number} */\n    this.velocity = 0;\n    /** @type {Number} */\n    this.angle = 0;\n    /** @type {JSAnimation} */\n    this.cursorStyles = null;\n    /** @type {JSAnimation} */\n    this.triggerStyles = null;\n    /** @type {JSAnimation} */\n    this.bodyStyles = null;\n    /** @type {JSAnimation} */\n    this.targetStyles = null;\n    /** @type {JSAnimation} */\n    this.touchActionStyles = null;\n    this.transforms = new Transforms(this.$target);\n    this.overshootCoords = {\n      x: 0,\n      y: 0\n    };\n    this.overshootXTicker = new Timer({\n      autoplay: false\n    }, null, 0).init();\n    this.overshootYTicker = new Timer({\n      autoplay: false\n    }, null, 0).init();\n    this.updateTicker = new Timer({\n      autoplay: false\n    }, null, 0).init();\n    this.overshootXTicker.onUpdate = () => {\n      if (this.disabled[0]) return;\n      this.updated = true;\n      this.manual = true;\n      this.animate[this.xProp](this.overshootCoords.x, 0);\n    };\n    this.overshootXTicker.onComplete = () => {\n      if (this.disabled[0]) return;\n      this.manual = false;\n      this.animate[this.xProp](this.overshootCoords.x, 0);\n    };\n    this.overshootYTicker.onUpdate = () => {\n      if (this.disabled[1]) return;\n      this.updated = true;\n      this.manual = true;\n      this.animate[this.yProp](this.overshootCoords.y, 0);\n    };\n    this.overshootYTicker.onComplete = () => {\n      if (this.disabled[1]) return;\n      this.manual = false;\n      this.animate[this.yProp](this.overshootCoords.y, 0);\n    };\n    this.updateTicker.onUpdate = () => this.update();\n    this.contained = !isUnd(container);\n    this.manual = false;\n    this.grabbed = false;\n    this.dragged = false;\n    this.updated = false;\n    this.released = false;\n    this.canScroll = false;\n    this.enabled = false;\n    this.initialized = false;\n    this.activeProp = this.disabled[1] ? xProp : yProp;\n    this.animate.animations[this.activeProp].onRender = () => {\n      const hasUpdated = this.updated;\n      const hasMoved = this.grabbed && hasUpdated;\n      const hasReleased = !hasMoved && this.released;\n      const x = this.x;\n      const y = this.y;\n      const dx = x - this.coords[2];\n      const dy = y - this.coords[3];\n      this.deltaX = dx;\n      this.deltaY = dy;\n      this.coords[2] = x;\n      this.coords[3] = y;\n      // Check if dx or dy are not 0 to check if the draggable has actually moved https://github.com/juliangarnier/anime/issues/1032\n      if (hasUpdated && (dx || dy)) {\n        this.onUpdate(this);\n      }\n      if (!hasReleased) {\n        this.updated = false;\n      } else {\n        this.computeVelocity(dx, dy);\n        this.angle = atan2(dy, dx);\n      }\n    };\n    this.animate.animations[this.activeProp].onComplete = () => {\n      if (!this.grabbed && this.released) {\n        // Set eleased to false before calling onSettle to avoid recursion\n        this.released = false;\n      }\n      if (!this.manual) {\n        this.deltaX = 0;\n        this.deltaY = 0;\n        this.velocity = 0;\n        this.velocityStack[0] = 0;\n        this.velocityStack[1] = 0;\n        this.velocityStack[2] = 0;\n        this.velocityStackIndex = 0;\n        this.onSettle(this);\n      }\n    };\n    this.resizeTicker = new Timer({\n      autoplay: false,\n      duration: 150 * globals.timeScale,\n      onComplete: () => {\n        this.onResize(this);\n        this.refresh();\n        this.onAfterResize(this);\n      }\n    }).init();\n    this.parameters = parameters;\n    this.resizeObserver = new ResizeObserver(() => {\n      if (this.initialized) {\n        this.resizeTicker.restart();\n      } else {\n        this.initialized = true;\n      }\n    });\n    this.enable();\n    this.refresh();\n    this.resizeObserver.observe(this.$container);\n    if (!isObj(target)) this.resizeObserver.observe(this.$target);\n  }\n\n  /**\n   * @param  {Number} dx\n   * @param  {Number} dy\n   * @return {Number}\n   */\n  computeVelocity(dx, dy) {\n    const prevTime = this.velocityTime;\n    const curTime = now();\n    const elapsed = curTime - prevTime;\n    if (elapsed < 17) return this.velocity;\n    this.velocityTime = curTime;\n    const velocityStack = this.velocityStack;\n    const vMul = this.velocityMultiplier;\n    const minV = this.minVelocity;\n    const maxV = this.maxVelocity;\n    const vi = this.velocityStackIndex;\n    velocityStack[vi] = round(clamp(sqrt(dx * dx + dy * dy) / elapsed * vMul, minV, maxV), 5);\n    const velocity = max(velocityStack[0], velocityStack[1], velocityStack[2]);\n    this.velocity = velocity;\n    this.velocityStackIndex = (vi + 1) % 3;\n    return velocity;\n  }\n\n  /**\n   * @param {Number}  x\n   * @param {Boolean} [muteUpdateCallback]\n   * @return {this}\n   */\n  setX(x, muteUpdateCallback = false) {\n    if (this.disabled[0]) return;\n    const v = round(x, 5);\n    this.overshootXTicker.pause();\n    this.manual = true;\n    this.updated = !muteUpdateCallback;\n    this.destX = v;\n    this.snapped[0] = snap(v, this.snapX);\n    this.animate[this.xProp](v, 0);\n    this.manual = false;\n    return this;\n  }\n\n  /**\n   * @param {Number}  y\n   * @param {Boolean} [muteUpdateCallback]\n   * @return {this}\n   */\n  setY(y, muteUpdateCallback = false) {\n    if (this.disabled[1]) return;\n    const v = round(y, 5);\n    this.overshootYTicker.pause();\n    this.manual = true;\n    this.updated = !muteUpdateCallback;\n    this.destY = v;\n    this.snapped[1] = snap(v, this.snapY);\n    this.animate[this.yProp](v, 0);\n    this.manual = false;\n    return this;\n  }\n  get x() {\n    return round(/** @type {Number} */this.animate[this.xProp](), globals.precision);\n  }\n  set x(x) {\n    this.setX(x, false);\n  }\n  get y() {\n    return round(/** @type {Number} */this.animate[this.yProp](), globals.precision);\n  }\n  set y(y) {\n    this.setY(y, false);\n  }\n  get progressX() {\n    return mapRange(this.x, this.containerBounds[3], this.containerBounds[1], 0, 1);\n  }\n  set progressX(x) {\n    this.setX(mapRange(x, 0, 1, this.containerBounds[3], this.containerBounds[1]), false);\n  }\n  get progressY() {\n    return mapRange(this.y, this.containerBounds[0], this.containerBounds[2], 0, 1);\n  }\n  set progressY(y) {\n    this.setY(mapRange(y, 0, 1, this.containerBounds[0], this.containerBounds[2]), false);\n  }\n  updateScrollCoords() {\n    const sx = round(this.useWin ? win.scrollX : this.$container.scrollLeft, 0);\n    const sy = round(this.useWin ? win.scrollY : this.$container.scrollTop, 0);\n    const [cpt, cpr, cpb, cpl] = this.containerPadding;\n    const threshold = this.scrollThreshold;\n    this.scroll.x = sx;\n    this.scroll.y = sy;\n    this.scrollBounds[0] = sy - this.targetBounds[0] + cpt - threshold;\n    this.scrollBounds[1] = sx - this.targetBounds[1] - cpr + threshold;\n    this.scrollBounds[2] = sy - this.targetBounds[2] - cpb + threshold;\n    this.scrollBounds[3] = sx - this.targetBounds[3] + cpl - threshold;\n  }\n  updateBoundingValues() {\n    const $container = this.$container;\n    const cx = this.x;\n    const cy = this.y;\n    const cx2 = this.coords[2];\n    const cy2 = this.coords[3];\n    // Prevents interfering with the scroll area in cases the target is outside of the container\n    // Make sure the temp coords are also adjuset to prevents wrong delta calculation on updates\n    this.coords[2] = 0;\n    this.coords[3] = 0;\n    this.setX(0, true);\n    this.setY(0, true);\n    this.transforms.remove();\n    const iw = this.window[0] = win.innerWidth;\n    const ih = this.window[1] = win.innerHeight;\n    const uw = this.useWin;\n    const sw = $container.scrollWidth;\n    const sh = $container.scrollHeight;\n    const fx = this.fixed;\n    const transformContainerRect = $container.getBoundingClientRect();\n    const [cpt, cpr, cpb, cpl] = this.containerPadding;\n    this.dragArea[0] = uw ? 0 : transformContainerRect.left;\n    this.dragArea[1] = uw ? 0 : transformContainerRect.top;\n    this.scrollView[0] = uw ? clamp(sw, iw, sw) : sw;\n    this.scrollView[1] = uw ? clamp(sh, ih, sh) : sh;\n    this.updateScrollCoords();\n    const {\n      width,\n      height,\n      left,\n      top,\n      right,\n      bottom\n    } = $container.getBoundingClientRect();\n    this.dragArea[2] = round(uw ? clamp(width, iw, iw) : width, 0);\n    this.dragArea[3] = round(uw ? clamp(height, ih, ih) : height, 0);\n    const containerOverflow = getTargetValue($container, 'overflow');\n    const visibleOverflow = containerOverflow === 'visible';\n    const hiddenOverflow = containerOverflow === 'hidden';\n    this.canScroll = fx ? false : this.contained && ($container === doc.body && visibleOverflow || !hiddenOverflow && !visibleOverflow) && (sw > this.dragArea[2] + cpl - cpr || sh > this.dragArea[3] + cpt - cpb) && (!this.containerArray || this.containerArray && !isArr(this.containerArray));\n    if (this.contained) {\n      const sx = this.scroll.x;\n      const sy = this.scroll.y;\n      const canScroll = this.canScroll;\n      const targetRect = this.$target.getBoundingClientRect();\n      const hiddenLeft = canScroll ? uw ? 0 : $container.scrollLeft : 0;\n      const hiddenTop = canScroll ? uw ? 0 : $container.scrollTop : 0;\n      const hiddenRight = canScroll ? this.scrollView[0] - hiddenLeft - width : 0;\n      const hiddenBottom = canScroll ? this.scrollView[1] - hiddenTop - height : 0;\n      this.targetBounds[0] = round(targetRect.top + sy - (uw ? 0 : top), 0);\n      this.targetBounds[1] = round(targetRect.right + sx - (uw ? iw : right), 0);\n      this.targetBounds[2] = round(targetRect.bottom + sy - (uw ? ih : bottom), 0);\n      this.targetBounds[3] = round(targetRect.left + sx - (uw ? 0 : left), 0);\n      if (this.containerArray) {\n        this.containerBounds[0] = this.containerArray[0] + cpt;\n        this.containerBounds[1] = this.containerArray[1] - cpr;\n        this.containerBounds[2] = this.containerArray[2] - cpb;\n        this.containerBounds[3] = this.containerArray[3] + cpl;\n      } else {\n        this.containerBounds[0] = -round(targetRect.top - (fx ? clamp(top, 0, ih) : top) + hiddenTop - cpt, 0);\n        this.containerBounds[1] = -round(targetRect.right - (fx ? clamp(right, 0, iw) : right) - hiddenRight + cpr, 0);\n        this.containerBounds[2] = -round(targetRect.bottom - (fx ? clamp(bottom, 0, ih) : bottom) - hiddenBottom + cpb, 0);\n        this.containerBounds[3] = -round(targetRect.left - (fx ? clamp(left, 0, iw) : left) + hiddenLeft - cpl, 0);\n      }\n    }\n    this.transforms.revert();\n    // Restore coordinates\n    this.coords[2] = cx2;\n    this.coords[3] = cy2;\n    this.setX(cx, true);\n    this.setY(cy, true);\n  }\n\n  /**\n   * Returns 0 if not OB, 1 if x is OB, 2 if y is OB, 3 if both x and y are OB\n   *\n   * @param  {Array} bounds\n   * @param  {Number} x\n   * @param  {Number} y\n   * @return {Number}\n   */\n  isOutOfBounds(bounds, x, y) {\n    if (!this.contained) return 0;\n    const [bt, br, bb, bl] = bounds;\n    const [dx, dy] = this.disabled;\n    const obx = !dx && x < bl || !dx && x > br;\n    const oby = !dy && y < bt || !dy && y > bb;\n    return obx && !oby ? 1 : !obx && oby ? 2 : obx && oby ? 3 : 0;\n  }\n  refresh() {\n    const params = this.parameters;\n    const paramX = params.x;\n    const paramY = params.y;\n    const container = parseDraggableFunctionParameter(params.container, this);\n    const cp = parseDraggableFunctionParameter(params.containerPadding, this) || 0;\n    const containerPadding = /** @type {[Number, Number, Number, Number]} */isArr(cp) ? cp : [cp, cp, cp, cp];\n    const cx = this.x;\n    const cy = this.y;\n    const parsedCursorStyles = parseDraggableFunctionParameter(params.cursor, this);\n    const cursorStyles = {\n      onHover: 'grab',\n      onGrab: 'grabbing'\n    };\n    if (parsedCursorStyles) {\n      const {\n        onHover,\n        onGrab\n      } = /** @type {DraggableCursorParams} */parsedCursorStyles;\n      if (onHover) cursorStyles.onHover = onHover;\n      if (onGrab) cursorStyles.onGrab = onGrab;\n    }\n    this.containerArray = isArr(container) ? container : null;\n    this.$container = /** @type {HTMLElement} */container && !this.containerArray ? parseTargets(/** @type {DOMTarget} */container)[0] : doc.body;\n    this.useWin = this.$container === doc.body;\n    /** @type {Window | HTMLElement} */\n    this.$scrollContainer = this.useWin ? win : this.$container;\n    this.isFinePointer = matchMedia('(pointer:fine)').matches;\n    this.containerPadding = setValue(containerPadding, [0, 0, 0, 0]);\n    this.containerFriction = clamp(setValue(parseDraggableFunctionParameter(params.containerFriction, this), .8), 0, 1);\n    this.releaseContainerFriction = clamp(setValue(parseDraggableFunctionParameter(params.releaseContainerFriction, this), this.containerFriction), 0, 1);\n    this.snapX = parseDraggableFunctionParameter(isObj(paramX) && !isUnd(paramX.snap) ? paramX.snap : params.snap, this);\n    this.snapY = parseDraggableFunctionParameter(isObj(paramY) && !isUnd(paramY.snap) ? paramY.snap : params.snap, this);\n    this.scrollSpeed = setValue(parseDraggableFunctionParameter(params.scrollSpeed, this), 1.5);\n    this.scrollThreshold = setValue(parseDraggableFunctionParameter(params.scrollThreshold, this), 20);\n    this.dragSpeed = setValue(parseDraggableFunctionParameter(params.dragSpeed, this), 1);\n    this.minVelocity = setValue(parseDraggableFunctionParameter(params.minVelocity, this), 0);\n    this.maxVelocity = setValue(parseDraggableFunctionParameter(params.maxVelocity, this), 50);\n    this.velocityMultiplier = setValue(parseDraggableFunctionParameter(params.velocityMultiplier, this), 1);\n    this.cursor = parsedCursorStyles === false ? false : cursorStyles;\n    this.updateBoundingValues();\n\n    // const ob = this.isOutOfBounds(this.containerBounds, this.x, this.y);\n    // if (ob === 1 || ob === 3) this.progressX = px;\n    // if (ob === 2 || ob === 3) this.progressY = py;\n\n    // if (this.initialized && this.contained) {\n    //   if (this.progressX !== px) this.progressX = px;\n    //   if (this.progressY !== py) this.progressY = py;\n    // }\n\n    const [bt, br, bb, bl] = this.containerBounds;\n    this.setX(clamp(cx, bl, br), true);\n    this.setY(clamp(cy, bt, bb), true);\n  }\n  update() {\n    this.updateScrollCoords();\n    if (this.canScroll) {\n      const [cpt, cpr, cpb, cpl] = this.containerPadding;\n      const [sw, sh] = this.scrollView;\n      const daw = this.dragArea[2];\n      const dah = this.dragArea[3];\n      const csx = this.scroll.x;\n      const csy = this.scroll.y;\n      const nsw = this.$container.scrollWidth;\n      const nsh = this.$container.scrollHeight;\n      const csw = this.useWin ? clamp(nsw, this.window[0], nsw) : nsw;\n      const csh = this.useWin ? clamp(nsh, this.window[1], nsh) : nsh;\n      const swd = sw - csw;\n      const shd = sh - csh;\n      // Handle cases where the scrollarea dimensions changes during drag\n      if (this.dragged && swd > 0) {\n        this.coords[0] -= swd;\n        this.scrollView[0] = csw;\n      }\n      if (this.dragged && shd > 0) {\n        this.coords[1] -= shd;\n        this.scrollView[1] = csh;\n      }\n      // Handle autoscroll when target is at the edges of the scroll bounds\n      const s = this.scrollSpeed * 10;\n      const threshold = this.scrollThreshold;\n      const [x, y] = this.coords;\n      const [st, sr, sb, sl] = this.scrollBounds;\n      const t = round(clamp((y - st + cpt) / threshold, -1, 0) * s, 0);\n      const r = round(clamp((x - sr - cpr) / threshold, 0, 1) * s, 0);\n      const b = round(clamp((y - sb - cpb) / threshold, 0, 1) * s, 0);\n      const l = round(clamp((x - sl + cpl) / threshold, -1, 0) * s, 0);\n      if (t || b || l || r) {\n        const [nx, ny] = this.disabled;\n        let scrollX = csx;\n        let scrollY = csy;\n        if (!nx) {\n          scrollX = round(clamp(csx + (l || r), 0, sw - daw), 0);\n          this.coords[0] -= csx - scrollX;\n        }\n        if (!ny) {\n          scrollY = round(clamp(csy + (t || b), 0, sh - dah), 0);\n          this.coords[1] -= csy - scrollY;\n        }\n        // Note: Safari mobile requires to use different scroll methods depending if using the window or not\n        if (this.useWin) {\n          this.$scrollContainer.scrollBy(-(csx - scrollX), -(csy - scrollY));\n        } else {\n          this.$scrollContainer.scrollTo(scrollX, scrollY);\n        }\n      }\n    }\n    const [ct, cr, cb, cl] = this.containerBounds;\n    const [px1, py1, px2, py2, px3, py3] = this.pointer;\n    this.coords[0] += (px1 - px3) * this.dragSpeed;\n    this.coords[1] += (py1 - py3) * this.dragSpeed;\n    this.pointer[4] = px1;\n    this.pointer[5] = py1;\n    const [cx, cy] = this.coords;\n    const [sx, sy] = this.snapped;\n    const cf = (1 - this.containerFriction) * this.dragSpeed;\n    this.setX(cx > cr ? cr + (cx - cr) * cf : cx < cl ? cl + (cx - cl) * cf : cx, false);\n    this.setY(cy > cb ? cb + (cy - cb) * cf : cy < ct ? ct + (cy - ct) * cf : cy, false);\n    this.computeVelocity(px1 - px3, py1 - py3);\n    this.angle = atan2(py1 - py2, px1 - px2);\n    const [nsx, nsy] = this.snapped;\n    if (nsx !== sx && this.snapX || nsy !== sy && this.snapY) {\n      this.onSnap(this);\n    }\n  }\n  stop() {\n    this.updateTicker.pause();\n    this.overshootXTicker.pause();\n    this.overshootYTicker.pause();\n    // Pauses the in bounds onRelease animations\n    for (let prop in this.animate.animations) this.animate.animations[prop].pause();\n    remove(this, null, 'x');\n    remove(this, null, 'y');\n    remove(this, null, 'progressX');\n    remove(this, null, 'progressY');\n    remove(this.scroll); // Removes any active animations on the container scroll\n    remove(this.overshootCoords); // Removes active overshoot animations\n    return this;\n  }\n\n  /**\n   * @param {Number} [duration]\n   * @param {Number} [gap]\n   * @param {EasingParam} [ease]\n   * @return {this}\n   */\n  scrollInView(duration, gap = 0, ease = eases.inOutQuad) {\n    this.updateScrollCoords();\n    const x = this.destX;\n    const y = this.destY;\n    const scroll = this.scroll;\n    const scrollBounds = this.scrollBounds;\n    const canScroll = this.canScroll;\n    if (!this.containerArray && this.isOutOfBounds(scrollBounds, x, y)) {\n      const [st, sr, sb, sl] = scrollBounds;\n      const t = round(clamp(y - st, -1e12, 0), 0);\n      const r = round(clamp(x - sr, 0, maxValue), 0);\n      const b = round(clamp(y - sb, 0, maxValue), 0);\n      const l = round(clamp(x - sl, -1e12, 0), 0);\n      new JSAnimation(scroll, {\n        x: round(scroll.x + (l ? l - gap : r ? r + gap : 0), 0),\n        y: round(scroll.y + (t ? t - gap : b ? b + gap : 0), 0),\n        duration: isUnd(duration) ? 350 * globals.timeScale : duration,\n        ease,\n        onUpdate: () => {\n          this.canScroll = false;\n          this.$scrollContainer.scrollTo(scroll.x, scroll.y);\n        }\n      }).init().then(() => {\n        this.canScroll = canScroll;\n      });\n    }\n    return this;\n  }\n  handleHover() {\n    if (this.isFinePointer && this.cursor && !this.cursorStyles) {\n      this.cursorStyles = setTargetValues(this.$trigger, {\n        cursor: /** @type {DraggableCursorParams} */this.cursor.onHover\n      });\n    }\n  }\n\n  /**\n   * @param  {Number} [duration]\n   * @param  {Number} [gap]\n   * @param  {EasingParam} [ease]\n   * @return {this}\n   */\n  animateInView(duration, gap = 0, ease = eases.inOutQuad) {\n    this.stop();\n    this.updateBoundingValues();\n    const x = this.x;\n    const y = this.y;\n    const [cpt, cpr, cpb, cpl] = this.containerPadding;\n    const bt = this.scroll.y - this.targetBounds[0] + cpt + gap;\n    const br = this.scroll.x - this.targetBounds[1] - cpr - gap;\n    const bb = this.scroll.y - this.targetBounds[2] - cpb - gap;\n    const bl = this.scroll.x - this.targetBounds[3] + cpl + gap;\n    const ob = this.isOutOfBounds([bt, br, bb, bl], x, y);\n    if (ob) {\n      const [disabledX, disabledY] = this.disabled;\n      const destX = clamp(snap(x, this.snapX), bl, br);\n      const destY = clamp(snap(y, this.snapY), bt, bb);\n      const dur = isUnd(duration) ? 350 * globals.timeScale : duration;\n      if (!disabledX && (ob === 1 || ob === 3)) this.animate[this.xProp](destX, dur, ease);\n      if (!disabledY && (ob === 2 || ob === 3)) this.animate[this.yProp](destY, dur, ease);\n    }\n    return this;\n  }\n\n  /**\n   * @param {MouseEvent|TouchEvent} e\n   */\n  handleDown(e) {\n    const $eTarget = /** @type {HTMLElement} */e.target;\n    if (this.grabbed || /** @type {HTMLInputElement}  */$eTarget.type === 'range') return;\n    e.stopPropagation();\n    this.grabbed = true;\n    this.released = false;\n    this.stop();\n    this.updateBoundingValues();\n    const touches = /** @type {TouchEvent} */e.changedTouches;\n    const eventX = touches ? touches[0].clientX : /** @type {MouseEvent} */e.clientX;\n    const eventY = touches ? touches[0].clientY : /** @type {MouseEvent} */e.clientY;\n    const {\n      x,\n      y\n    } = this.transforms.normalizePoint(eventX, eventY);\n    const [ct, cr, cb, cl] = this.containerBounds;\n    const cf = (1 - this.containerFriction) * this.dragSpeed;\n    const cx = this.x;\n    const cy = this.y;\n    this.coords[0] = this.coords[2] = !cf ? cx : cx > cr ? cr + (cx - cr) / cf : cx < cl ? cl + (cx - cl) / cf : cx;\n    this.coords[1] = this.coords[3] = !cf ? cy : cy > cb ? cb + (cy - cb) / cf : cy < ct ? ct + (cy - ct) / cf : cy;\n    this.pointer[0] = x;\n    this.pointer[1] = y;\n    this.pointer[2] = x;\n    this.pointer[3] = y;\n    this.pointer[4] = x;\n    this.pointer[5] = y;\n    this.pointer[6] = x;\n    this.pointer[7] = y;\n    this.deltaX = 0;\n    this.deltaY = 0;\n    this.velocity = 0;\n    this.velocityStack[0] = 0;\n    this.velocityStack[1] = 0;\n    this.velocityStack[2] = 0;\n    this.velocityStackIndex = 0;\n    this.angle = 0;\n    if (this.targetStyles) {\n      this.targetStyles.revert();\n      this.targetStyles = null;\n    }\n    const z = /** @type {Number} */getTargetValue(this.$target, 'zIndex', false);\n    zIndex = (z > zIndex ? z : zIndex) + 1;\n    this.targetStyles = setTargetValues(this.$target, {\n      zIndex\n    });\n    if (this.triggerStyles) {\n      this.triggerStyles.revert();\n      this.triggerStyles = null;\n    }\n    if (this.cursorStyles) {\n      this.cursorStyles.revert();\n      this.cursorStyles = null;\n    }\n    if (this.isFinePointer && this.cursor) {\n      this.bodyStyles = setTargetValues(doc.body, {\n        cursor: /** @type {DraggableCursorParams} */this.cursor.onGrab\n      });\n    }\n    this.scrollInView(100, 0, eases.out(3));\n    this.onGrab(this);\n    doc.addEventListener('touchmove', this);\n    doc.addEventListener('touchend', this);\n    doc.addEventListener('touchcancel', this);\n    doc.addEventListener('mousemove', this);\n    doc.addEventListener('mouseup', this);\n    doc.addEventListener('selectstart', this);\n  }\n\n  /**\n   * @param {MouseEvent|TouchEvent} e\n   */\n  handleMove(e) {\n    if (!this.grabbed) return;\n    const touches = /** @type {TouchEvent} */e.changedTouches;\n    const eventX = touches ? touches[0].clientX : /** @type {MouseEvent} */e.clientX;\n    const eventY = touches ? touches[0].clientY : /** @type {MouseEvent} */e.clientY;\n    const {\n      x,\n      y\n    } = this.transforms.normalizePoint(eventX, eventY);\n    const movedX = x - this.pointer[6];\n    const movedY = y - this.pointer[7];\n    let $parent = /** @type {HTMLElement} */e.target;\n    let isAtTop = false;\n    let isAtBottom = false;\n    let canTouchScroll = false;\n    while (touches && $parent && $parent !== this.$trigger) {\n      const overflowY = getTargetValue($parent, 'overflow-y');\n      if (overflowY !== 'hidden' && overflowY !== 'visible') {\n        const {\n          scrollTop,\n          scrollHeight,\n          clientHeight\n        } = $parent;\n        if (scrollHeight > clientHeight) {\n          canTouchScroll = true;\n          isAtTop = scrollTop <= 3;\n          isAtBottom = scrollTop >= scrollHeight - clientHeight - 3;\n          break;\n        }\n      }\n      $parent = /** @type {HTMLElement} */$parent.parentNode;\n    }\n    if (canTouchScroll && (!isAtTop && !isAtBottom || isAtTop && movedY < 0 || isAtBottom && movedY > 0)) {\n      this.pointer[0] = x;\n      this.pointer[1] = y;\n      this.pointer[2] = x;\n      this.pointer[3] = y;\n      this.pointer[4] = x;\n      this.pointer[5] = y;\n      this.pointer[6] = x;\n      this.pointer[7] = y;\n    } else {\n      preventDefault(e);\n\n      // Needed to prevents click on handleUp\n      if (!this.triggerStyles) this.triggerStyles = setTargetValues(this.$trigger, {\n        pointerEvents: 'none'\n      });\n      // Needed to prevent page scroll while dragging on touch devvice\n      this.$trigger.addEventListener('touchstart', preventDefault, {\n        passive: false\n      });\n      this.$trigger.addEventListener('touchmove', preventDefault, {\n        passive: false\n      });\n      this.$trigger.addEventListener('touchend', preventDefault);\n      if (!this.disabled[0] && abs(movedX) > 3 || !this.disabled[1] && abs(movedY) > 3) {\n        this.updateTicker.resume();\n        this.pointer[2] = this.pointer[0];\n        this.pointer[3] = this.pointer[1];\n        this.pointer[0] = x;\n        this.pointer[1] = y;\n        this.dragged = true;\n        this.released = false;\n        this.onDrag(this);\n      }\n    }\n  }\n  handleUp() {\n    if (!this.grabbed) return;\n    this.updateTicker.pause();\n    if (this.triggerStyles) {\n      this.triggerStyles.revert();\n      this.triggerStyles = null;\n    }\n    if (this.bodyStyles) {\n      this.bodyStyles.revert();\n      this.bodyStyles = null;\n    }\n    const [disabledX, disabledY] = this.disabled;\n    const [px1, py1, px2, py2, px3, py3] = this.pointer;\n    const [ct, cr, cb, cl] = this.containerBounds;\n    const [sx, sy] = this.snapped;\n    const springX = this.releaseXSpring;\n    const springY = this.releaseYSpring;\n    const releaseEase = this.releaseEase;\n    const hasReleaseSpring = this.hasReleaseSpring;\n    const overshootCoords = this.overshootCoords;\n    const cx = this.x;\n    const cy = this.y;\n    const pv = this.computeVelocity(px1 - px3, py1 - py3);\n    const pa = this.angle = atan2(py1 - py2, px1 - px2);\n    const ds = pv * 150;\n    const cf = (1 - this.releaseContainerFriction) * this.dragSpeed;\n    const nx = cx + cos(pa) * ds;\n    const ny = cy + sin(pa) * ds;\n    const bx = nx > cr ? cr + (nx - cr) * cf : nx < cl ? cl + (nx - cl) * cf : nx;\n    const by = ny > cb ? cb + (ny - cb) * cf : ny < ct ? ct + (ny - ct) * cf : ny;\n    const dx = this.destX = clamp(round(snap(bx, this.snapX), 5), cl, cr);\n    const dy = this.destY = clamp(round(snap(by, this.snapY), 5), ct, cb);\n    const ob = this.isOutOfBounds(this.containerBounds, nx, ny);\n    let durationX = 0;\n    let durationY = 0;\n    let easeX = releaseEase;\n    let easeY = releaseEase;\n    let longestReleaseDuration = 0;\n    overshootCoords.x = cx;\n    overshootCoords.y = cy;\n    if (!disabledX) {\n      const directionX = dx === cr ? cx > cr ? -1 : 1 : cx < cl ? -1 : 1;\n      const distanceX = round(cx - dx, 0);\n      springX.velocity = disabledY && hasReleaseSpring ? distanceX ? ds * directionX / abs(distanceX) : 0 : pv;\n      const {\n        ease,\n        duration,\n        restDuration\n      } = springX;\n      durationX = cx === dx ? 0 : hasReleaseSpring ? duration : duration - restDuration * globals.timeScale;\n      if (hasReleaseSpring) easeX = ease;\n      if (durationX > longestReleaseDuration) longestReleaseDuration = durationX;\n    }\n    if (!disabledY) {\n      const directionY = dy === cb ? cy > cb ? -1 : 1 : cy < ct ? -1 : 1;\n      const distanceY = round(cy - dy, 0);\n      springY.velocity = disabledX && hasReleaseSpring ? distanceY ? ds * directionY / abs(distanceY) : 0 : pv;\n      const {\n        ease,\n        duration,\n        restDuration\n      } = springY;\n      durationY = cy === dy ? 0 : hasReleaseSpring ? duration : duration - restDuration * globals.timeScale;\n      if (hasReleaseSpring) easeY = ease;\n      if (durationY > longestReleaseDuration) longestReleaseDuration = durationY;\n    }\n    if (!hasReleaseSpring && ob && cf && (durationX || durationY)) {\n      const composition = compositionTypes.blend;\n      new JSAnimation(overshootCoords, {\n        x: {\n          to: bx,\n          duration: durationX * .65\n        },\n        y: {\n          to: by,\n          duration: durationY * .65\n        },\n        ease: releaseEase,\n        composition\n      }).init();\n      new JSAnimation(overshootCoords, {\n        x: {\n          to: dx,\n          duration: durationX\n        },\n        y: {\n          to: dy,\n          duration: durationY\n        },\n        ease: releaseEase,\n        composition\n      }).init();\n      this.overshootXTicker.stretch(durationX).restart();\n      this.overshootYTicker.stretch(durationY).restart();\n    } else {\n      if (!disabledX) this.animate[this.xProp](dx, durationX, easeX);\n      if (!disabledY) this.animate[this.yProp](dy, durationY, easeY);\n    }\n    this.scrollInView(longestReleaseDuration, this.scrollThreshold, releaseEase);\n    let hasSnapped = false;\n    if (dx !== sx) {\n      this.snapped[0] = dx;\n      if (this.snapX) hasSnapped = true;\n    }\n    if (dy !== sy && this.snapY) {\n      this.snapped[1] = dy;\n      if (this.snapY) hasSnapped = true;\n    }\n    if (hasSnapped) this.onSnap(this);\n    this.grabbed = false;\n    this.dragged = false;\n    this.updated = true;\n    this.released = true;\n\n    // It's important to trigger the callback after the release animations to be able to cancel them\n    this.onRelease(this);\n    this.$trigger.removeEventListener('touchstart', preventDefault);\n    this.$trigger.removeEventListener('touchmove', preventDefault);\n    this.$trigger.removeEventListener('touchend', preventDefault);\n    doc.removeEventListener('touchmove', this);\n    doc.removeEventListener('touchend', this);\n    doc.removeEventListener('touchcancel', this);\n    doc.removeEventListener('mousemove', this);\n    doc.removeEventListener('mouseup', this);\n    doc.removeEventListener('selectstart', this);\n  }\n  reset() {\n    this.stop();\n    this.resizeTicker.pause();\n    this.grabbed = false;\n    this.dragged = false;\n    this.updated = false;\n    this.released = false;\n    this.canScroll = false;\n    this.setX(0, true);\n    this.setY(0, true);\n    this.coords[0] = 0;\n    this.coords[1] = 0;\n    this.pointer[0] = 0;\n    this.pointer[1] = 0;\n    this.pointer[2] = 0;\n    this.pointer[3] = 0;\n    this.pointer[4] = 0;\n    this.pointer[5] = 0;\n    this.pointer[6] = 0;\n    this.pointer[7] = 0;\n    this.velocity = 0;\n    this.velocityStack[0] = 0;\n    this.velocityStack[1] = 0;\n    this.velocityStack[2] = 0;\n    this.velocityStackIndex = 0;\n    this.angle = 0;\n    return this;\n  }\n  enable() {\n    if (!this.enabled) {\n      this.enabled = true;\n      this.$target.classList.remove('is-disabled');\n      this.touchActionStyles = setTargetValues(this.$trigger, {\n        touchAction: this.disabled[0] ? 'pan-x' : this.disabled[1] ? 'pan-y' : 'none'\n      });\n      this.$trigger.addEventListener('touchstart', this, {\n        passive: true\n      });\n      this.$trigger.addEventListener('mousedown', this, {\n        passive: true\n      });\n      this.$trigger.addEventListener('mouseenter', this);\n    }\n    return this;\n  }\n  disable() {\n    this.enabled = false;\n    this.grabbed = false;\n    this.dragged = false;\n    this.updated = false;\n    this.released = false;\n    this.canScroll = false;\n    this.touchActionStyles.revert();\n    if (this.cursorStyles) {\n      this.cursorStyles.revert();\n      this.cursorStyles = null;\n    }\n    if (this.triggerStyles) {\n      this.triggerStyles.revert();\n      this.triggerStyles = null;\n    }\n    if (this.bodyStyles) {\n      this.bodyStyles.revert();\n      this.bodyStyles = null;\n    }\n    if (this.targetStyles) {\n      this.targetStyles.revert();\n      this.targetStyles = null;\n    }\n    this.$target.classList.add('is-disabled');\n    this.$trigger.removeEventListener('touchstart', this);\n    this.$trigger.removeEventListener('mousedown', this);\n    this.$trigger.removeEventListener('mouseenter', this);\n    doc.removeEventListener('touchmove', this);\n    doc.removeEventListener('touchend', this);\n    doc.removeEventListener('touchcancel', this);\n    doc.removeEventListener('mousemove', this);\n    doc.removeEventListener('mouseup', this);\n    doc.removeEventListener('selectstart', this);\n    return this;\n  }\n  revert() {\n    this.reset();\n    this.disable();\n    this.$target.classList.remove('is-disabled');\n    this.updateTicker.revert();\n    this.overshootXTicker.revert();\n    this.overshootYTicker.revert();\n    this.resizeTicker.revert();\n    this.animate.revert();\n    this.resizeObserver.disconnect();\n    return this;\n  }\n\n  /**\n   * @param {Event} e\n   */\n  handleEvent(e) {\n    switch (e.type) {\n      case 'mousedown':\n        this.handleDown(/** @type {MouseEvent} */e);\n        break;\n      case 'touchstart':\n        this.handleDown(/** @type {TouchEvent} */e);\n        break;\n      case 'mousemove':\n        this.handleMove(/** @type {MouseEvent} */e);\n        break;\n      case 'touchmove':\n        this.handleMove(/** @type {TouchEvent} */e);\n        break;\n      case 'mouseup':\n        this.handleUp();\n        break;\n      case 'touchend':\n        this.handleUp();\n        break;\n      case 'touchcancel':\n        this.handleUp();\n        break;\n      case 'mouseenter':\n        this.handleHover();\n        break;\n      case 'selectstart':\n        preventDefault(e);\n        break;\n    }\n  }\n}\n\n/**\n * @param {TargetsParam} target\n * @param {DraggableParams} [parameters]\n * @return {Draggable}\n */\nconst createDraggable = (target, parameters) => new Draggable(target, parameters);\nclass Scope {\n  /** @param {ScopeParams} [parameters] */\n  constructor(parameters = {}) {\n    if (scope.current) scope.current.register(this);\n    const rootParam = parameters.root;\n    /** @type {Document|DOMTarget} */\n    let root = doc;\n    if (rootParam) {\n      root = /** @type {ReactRef} */rootParam.current || /** @type {AngularRef} */rootParam.nativeElement || parseTargets(/** @type {DOMTargetSelector} */rootParam)[0] || doc;\n    }\n    const scopeDefaults = parameters.defaults;\n    const globalDefault = globals.defaults;\n    const mediaQueries = parameters.mediaQueries;\n    /** @type {DefaultsParams} */\n    this.defaults = scopeDefaults ? mergeObjects(scopeDefaults, globalDefault) : globalDefault;\n    /** @type {Document|DOMTarget} */\n    this.root = root;\n    /** @type {Array<ScopeConstructorCallback>} */\n    this.constructors = [];\n    /** @type {Array<ScopeCleanupCallback>} */\n    this.revertConstructors = [];\n    /** @type {Array<Revertible>} */\n    this.revertibles = [];\n    /** @type {Array<ScopeConstructorCallback | ((scope: this) => Tickable)>} */\n    this.constructorsOnce = [];\n    /** @type {Array<ScopeCleanupCallback>} */\n    this.revertConstructorsOnce = [];\n    /** @type {Array<Revertible>} */\n    this.revertiblesOnce = [];\n    /** @type {Boolean} */\n    this.once = false;\n    /** @type {Number} */\n    this.onceIndex = 0;\n    /** @type {Record<String, ScopeMethod>} */\n    this.methods = {};\n    /** @type {Record<String, Boolean>} */\n    this.matches = {};\n    /** @type {Record<String, MediaQueryList>} */\n    this.mediaQueryLists = {};\n    /** @type {Record<String, any>} */\n    this.data = {};\n    if (mediaQueries) {\n      for (let mq in mediaQueries) {\n        const _mq = win.matchMedia(mediaQueries[mq]);\n        this.mediaQueryLists[mq] = _mq;\n        _mq.addEventListener('change', this);\n      }\n    }\n  }\n\n  /**\n   * @param {Revertible} revertible\n   */\n  register(revertible) {\n    const store = this.once ? this.revertiblesOnce : this.revertibles;\n    store.push(revertible);\n  }\n\n  /**\n   * @template T\n   * @param {ScopedCallback<T>} cb\n   * @return {T}\n   */\n  execute(cb) {\n    let activeScope = scope.current;\n    let activeRoot = scope.root;\n    let activeDefaults = globals.defaults;\n    scope.current = this;\n    scope.root = this.root;\n    globals.defaults = this.defaults;\n    const mqs = this.mediaQueryLists;\n    for (let mq in mqs) this.matches[mq] = mqs[mq].matches;\n    const returned = cb(this);\n    scope.current = activeScope;\n    scope.root = activeRoot;\n    globals.defaults = activeDefaults;\n    return returned;\n  }\n\n  /**\n   * @return {this}\n   */\n  refresh() {\n    this.onceIndex = 0;\n    this.execute(() => {\n      let i = this.revertibles.length;\n      let y = this.revertConstructors.length;\n      while (i--) this.revertibles[i].revert();\n      while (y--) this.revertConstructors[y](this);\n      this.revertibles.length = 0;\n      this.revertConstructors.length = 0;\n      this.constructors.forEach((/** @type {ScopeConstructorCallback} */constructor) => {\n        const revertConstructor = constructor(this);\n        if (isFnc(revertConstructor)) {\n          this.revertConstructors.push(revertConstructor);\n        }\n      });\n    });\n    return this;\n  }\n\n  /**\n   * @overload\n   * @param {String} a1\n   * @param {ScopeMethod} a2\n   * @return {this}\n   *\n   * @overload\n   * @param {ScopeConstructorCallback} a1\n   * @return {this}\n   *\n   * @param {String|ScopeConstructorCallback} a1\n   * @param {ScopeMethod} [a2]\n   */\n  add(a1, a2) {\n    this.once = false;\n    if (isFnc(a1)) {\n      const constructor = /** @type {ScopeConstructorCallback} */a1;\n      this.constructors.push(constructor);\n      this.execute(() => {\n        const revertConstructor = constructor(this);\n        if (isFnc(revertConstructor)) {\n          this.revertConstructors.push(revertConstructor);\n        }\n      });\n    } else {\n      this.methods[(/** @type {String} */a1)] = (/** @type {any} */...args) => this.execute(() => a2(...args));\n    }\n    return this;\n  }\n\n  /**\n   * @param {ScopeConstructorCallback} scopeConstructorCallback\n   * @return {this}\n   */\n  addOnce(scopeConstructorCallback) {\n    this.once = true;\n    if (isFnc(scopeConstructorCallback)) {\n      const currentIndex = this.onceIndex++;\n      const tracked = this.constructorsOnce[currentIndex];\n      if (tracked) return this;\n      const constructor = /** @type {ScopeConstructorCallback} */scopeConstructorCallback;\n      this.constructorsOnce[currentIndex] = constructor;\n      this.execute(() => {\n        const revertConstructor = constructor(this);\n        if (isFnc(revertConstructor)) {\n          this.revertConstructorsOnce.push(revertConstructor);\n        }\n      });\n    }\n    return this;\n  }\n\n  /**\n   * @param  {(scope: this) => Tickable} cb\n   * @return {Tickable}\n   */\n  keepTime(cb) {\n    this.once = true;\n    const currentIndex = this.onceIndex++;\n    const tracked = /** @type {(scope: this) => Tickable} */this.constructorsOnce[currentIndex];\n    if (isFnc(tracked)) return tracked(this);\n    const constructor = /** @type {(scope: this) => Tickable} */createRefreshable(cb);\n    this.constructorsOnce[currentIndex] = constructor;\n    let trackedTickable;\n    this.execute(() => {\n      trackedTickable = constructor(this);\n    });\n    return trackedTickable;\n  }\n\n  /**\n   * @param {Event} e\n   */\n  handleEvent(e) {\n    switch (e.type) {\n      case 'change':\n        this.refresh();\n        break;\n    }\n  }\n  revert() {\n    const revertibles = this.revertibles;\n    const revertConstructors = this.revertConstructors;\n    const revertiblesOnce = this.revertiblesOnce;\n    const revertConstructorsOnce = this.revertConstructorsOnce;\n    const mqs = this.mediaQueryLists;\n    let i = revertibles.length;\n    let j = revertConstructors.length;\n    let k = revertiblesOnce.length;\n    let l = revertConstructorsOnce.length;\n    while (i--) revertibles[i].revert();\n    while (j--) revertConstructors[j](this);\n    while (k--) revertiblesOnce[k].revert();\n    while (l--) revertConstructorsOnce[l](this);\n    for (let mq in mqs) mqs[mq].removeEventListener('change', this);\n    revertibles.length = 0;\n    revertConstructors.length = 0;\n    this.constructors.length = 0;\n    revertiblesOnce.length = 0;\n    revertConstructorsOnce.length = 0;\n    this.constructorsOnce.length = 0;\n    this.onceIndex = 0;\n    this.matches = {};\n    this.methods = {};\n    this.mediaQueryLists = {};\n    this.data = {};\n  }\n}\n\n/**\n * @param {ScopeParams} [params]\n * @return {Scope}\n */\nconst createScope = params => new Scope(params);\n\n/**\n * @typedef {String|Number} ScrollThresholdValue\n */\n\n/**\n * @return {Number}\n */\nconst getMaxViewHeight = () => {\n  const $el = doc.createElement('div');\n  doc.body.appendChild($el);\n  $el.style.height = '100lvh';\n  const height = $el.offsetHeight;\n  doc.body.removeChild($el);\n  return height;\n};\n\n/**\n * @template {ScrollThresholdValue|String|Number|Boolean|Function|Object} T\n * @param {T | ((observer: ScrollObserver) => T)} value\n * @param {ScrollObserver} scroller\n * @return {T}\n */\nconst parseScrollObserverFunctionParameter = (value, scroller) => value && isFnc(value) ? /** @type {Function} */value(scroller) : value;\nconst scrollContainers = new Map();\nclass ScrollContainer {\n  /**\n   * @param {HTMLElement} $el\n   */\n  constructor($el) {\n    /** @type {HTMLElement} */\n    this.element = $el;\n    /** @type {Boolean} */\n    this.useWin = this.element === doc.body;\n    /** @type {Number} */\n    this.winWidth = 0;\n    /** @type {Number} */\n    this.winHeight = 0;\n    /** @type {Number} */\n    this.width = 0;\n    /** @type {Number} */\n    this.height = 0;\n    /** @type {Number} */\n    this.left = 0;\n    /** @type {Number} */\n    this.top = 0;\n    /** @type {Number} */\n    this.zIndex = 0;\n    /** @type {Number} */\n    this.scrollX = 0;\n    /** @type {Number} */\n    this.scrollY = 0;\n    /** @type {Number} */\n    this.prevScrollX = 0;\n    /** @type {Number} */\n    this.prevScrollY = 0;\n    /** @type {Number} */\n    this.scrollWidth = 0;\n    /** @type {Number} */\n    this.scrollHeight = 0;\n    /** @type {Number} */\n    this.velocity = 0;\n    /** @type {Boolean} */\n    this.backwardX = false;\n    /** @type {Boolean} */\n    this.backwardY = false;\n    /** @type {Timer} */\n    this.scrollTicker = new Timer({\n      autoplay: false,\n      onBegin: () => this.dataTimer.resume(),\n      onUpdate: () => {\n        const backwards = this.backwardX || this.backwardY;\n        forEachChildren(this, (/** @type {ScrollObserver} */child) => child.handleScroll(), backwards);\n      },\n      onComplete: () => this.dataTimer.pause()\n    }).init();\n    /** @type {Timer} */\n    this.dataTimer = new Timer({\n      autoplay: false,\n      frameRate: 30,\n      onUpdate: self => {\n        const dt = self.deltaTime;\n        const px = this.prevScrollX;\n        const py = this.prevScrollY;\n        const nx = this.scrollX;\n        const ny = this.scrollY;\n        const dx = px - nx;\n        const dy = py - ny;\n        this.prevScrollX = nx;\n        this.prevScrollY = ny;\n        if (dx) this.backwardX = px > nx;\n        if (dy) this.backwardY = py > ny;\n        this.velocity = round(dt > 0 ? Math.sqrt(dx * dx + dy * dy) / dt : 0, 5);\n      }\n    }).init();\n    /** @type {Timer} */\n    this.resizeTicker = new Timer({\n      autoplay: false,\n      duration: 250 * globals.timeScale,\n      onComplete: () => {\n        this.updateWindowBounds();\n        this.refreshScrollObservers();\n        this.handleScroll();\n      }\n    }).init();\n    /** @type {Timer} */\n    this.wakeTicker = new Timer({\n      autoplay: false,\n      duration: 500 * globals.timeScale,\n      onBegin: () => {\n        this.scrollTicker.resume();\n      },\n      onComplete: () => {\n        this.scrollTicker.pause();\n      }\n    }).init();\n    /** @type {ScrollObserver} */\n    this._head = null;\n    /** @type {ScrollObserver} */\n    this._tail = null;\n    this.updateScrollCoords();\n    this.updateWindowBounds();\n    this.updateBounds();\n    this.refreshScrollObservers();\n    this.handleScroll();\n    this.resizeObserver = new ResizeObserver(() => this.resizeTicker.restart());\n    this.resizeObserver.observe(this.element);\n    (this.useWin ? win : this.element).addEventListener('scroll', this, false);\n  }\n  updateScrollCoords() {\n    const useWin = this.useWin;\n    const $el = this.element;\n    this.scrollX = round(useWin ? win.scrollX : $el.scrollLeft, 0);\n    this.scrollY = round(useWin ? win.scrollY : $el.scrollTop, 0);\n  }\n  updateWindowBounds() {\n    this.winWidth = win.innerWidth;\n    this.winHeight = getMaxViewHeight();\n  }\n  updateBounds() {\n    const style = getComputedStyle(this.element);\n    const $el = this.element;\n    this.scrollWidth = $el.scrollWidth + parseFloat(style.marginLeft) + parseFloat(style.marginRight);\n    this.scrollHeight = $el.scrollHeight + parseFloat(style.marginTop) + parseFloat(style.marginBottom);\n    this.updateWindowBounds();\n    let width, height;\n    if (this.useWin) {\n      width = this.winWidth;\n      height = this.winHeight;\n    } else {\n      const elRect = $el.getBoundingClientRect();\n      width = elRect.width;\n      height = elRect.height;\n      this.top = elRect.top;\n      this.left = elRect.left;\n    }\n    this.width = width;\n    this.height = height;\n  }\n  refreshScrollObservers() {\n    forEachChildren(this, (/** @type {ScrollObserver} */child) => {\n      if (child._debug) {\n        child.removeDebug();\n      }\n    });\n    this.updateBounds();\n    forEachChildren(this, (/** @type {ScrollObserver} */child) => {\n      child.refresh();\n      if (child._debug) {\n        child.debug();\n      }\n    });\n  }\n  refresh() {\n    this.updateWindowBounds();\n    this.updateBounds();\n    this.refreshScrollObservers();\n    this.handleScroll();\n  }\n  handleScroll() {\n    this.updateScrollCoords();\n    this.wakeTicker.restart();\n  }\n\n  /**\n   * @param {Event} e\n   */\n  handleEvent(e) {\n    switch (e.type) {\n      case 'scroll':\n        this.handleScroll();\n        break;\n    }\n  }\n  revert() {\n    this.scrollTicker.cancel();\n    this.dataTimer.cancel();\n    this.resizeTicker.cancel();\n    this.wakeTicker.cancel();\n    this.resizeObserver.disconnect();\n    (this.useWin ? win : this.element).removeEventListener('scroll', this);\n    scrollContainers.delete(this.element);\n  }\n}\n\n/**\n * @param {TargetsParam} target\n * @return {ScrollContainer}\n */\nconst registerAndGetScrollContainer = target => {\n  const $el = /** @type {HTMLElement} */target ? parseTargets(target)[0] || doc.body : doc.body;\n  let scrollContainer = scrollContainers.get($el);\n  if (!scrollContainer) {\n    scrollContainer = new ScrollContainer($el);\n    scrollContainers.set($el, scrollContainer);\n  }\n  return scrollContainer;\n};\n\n/**\n * @param {HTMLElement} $el\n * @param {Number|string} v\n * @param {Number} size\n * @param {Number} [under]\n * @param {Number} [over]\n * @return {Number}\n */\nconst convertValueToPx = ($el, v, size, under, over) => {\n  const clampMin = v === 'min';\n  const clampMax = v === 'max';\n  const value = v === 'top' || v === 'left' || v === 'start' || clampMin ? 0 : v === 'bottom' || v === 'right' || v === 'end' || clampMax ? '100%' : v === 'center' ? '50%' : v;\n  const {\n    n,\n    u\n  } = decomposeRawValue(value, decomposedOriginalValue);\n  let px = n;\n  if (u === '%') {\n    px = n / 100 * size;\n  } else if (u) {\n    px = convertValueUnit($el, decomposedOriginalValue, 'px', true).n;\n  }\n  if (clampMax && under < 0) px += under;\n  if (clampMin && over > 0) px += over;\n  return px;\n};\n\n/**\n * @param {HTMLElement} $el\n * @param {ScrollThresholdValue} v\n * @param {Number} size\n * @param {Number} [under]\n * @param {Number} [over]\n * @return {Number}\n */\nconst parseBoundValue = ($el, v, size, under, over) => {\n  /** @type {Number} */\n  let value;\n  if (isStr(v)) {\n    const matchedOperator = relativeValuesExecRgx.exec(/** @type {String} */v);\n    if (matchedOperator) {\n      const splitter = matchedOperator[0];\n      const operator = splitter[0];\n      const splitted = /** @type {String} */v.split(splitter);\n      const clampMin = splitted[0] === 'min';\n      const clampMax = splitted[0] === 'max';\n      const valueAPx = convertValueToPx($el, splitted[0], size, under, over);\n      const valueBPx = convertValueToPx($el, splitted[1], size, under, over);\n      if (clampMin) {\n        const min = getRelativeValue(convertValueToPx($el, 'min', size), valueBPx, operator);\n        value = min < valueAPx ? valueAPx : min;\n      } else if (clampMax) {\n        const max = getRelativeValue(convertValueToPx($el, 'max', size), valueBPx, operator);\n        value = max > valueAPx ? valueAPx : max;\n      } else {\n        value = getRelativeValue(valueAPx, valueBPx, operator);\n      }\n    } else {\n      value = convertValueToPx($el, v, size, under, over);\n    }\n  } else {\n    value = /** @type {Number} */v;\n  }\n  return round(value, 0);\n};\n\n/**\n * @param {JSAnimation} linked\n * @return {HTMLElement}\n */\nconst getAnimationDomTarget = linked => {\n  let $linkedTarget;\n  const linkedTargets = linked.targets;\n  for (let i = 0, l = linkedTargets.length; i < l; i++) {\n    const target = linkedTargets[i];\n    if (target[isDomSymbol]) {\n      $linkedTarget = /** @type {HTMLElement} */target;\n      break;\n    }\n  }\n  return $linkedTarget;\n};\nlet scrollerIndex = 0;\nconst debugColors$1 = ['#FF4B4B', '#FF971B', '#FFC730', '#F9F640', '#7AFF5A', '#18FF74', '#17E09B', '#3CFFEC', '#05DBE9', '#33B3F1', '#638CF9', '#C563FE', '#FF4FCF', '#F93F8A'];\n\n/**\n * @typedef {Object} ScrollThresholdParam\n * @property {ScrollThresholdValue} [target]\n * @property {ScrollThresholdValue} [container]\n */\n\n/**\n * @callback ScrollObserverAxisCallback\n * @param {ScrollObserver} self\n * @return {'x'|'y'}\n */\n\n/**\n * @callback ScrollThresholdCallback\n * @param {ScrollObserver} self\n * @return {ScrollThresholdValue|ScrollThresholdParam}\n */\n\n/**\n * @typedef {Object} ScrollObserverParams\n * @property {Number|String} [id]\n * @property {Boolean|Number|String|EasingParam} [sync]\n * @property {TargetsParam} [container]\n * @property {TargetsParam} [target]\n * @property {'x'|'y'|ScrollObserverAxisCallback|((observer: ScrollObserver) => 'x'|'y'|ScrollObserverAxisCallback)} [axis]\n * @property {ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback|((observer: ScrollObserver) => ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback)} [enter]\n * @property {ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback|((observer: ScrollObserver) => ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback)} [leave]\n * @property {Boolean|((observer: ScrollObserver) => Boolean)} [repeat]\n * @property {Boolean} [debug]\n * @property {Callback<ScrollObserver>} [onEnter]\n * @property {Callback<ScrollObserver>} [onLeave]\n * @property {Callback<ScrollObserver>} [onEnterForward]\n * @property {Callback<ScrollObserver>} [onLeaveForward]\n * @property {Callback<ScrollObserver>} [onEnterBackward]\n * @property {Callback<ScrollObserver>} [onLeaveBackward]\n * @property {Callback<ScrollObserver>} [onUpdate]\n * @property {Callback<ScrollObserver>} [onSyncComplete]\n */\n\nclass ScrollObserver {\n  /**\n   * @param {ScrollObserverParams} parameters\n   */\n  constructor(parameters = {}) {\n    if (scope.current) scope.current.register(this);\n    const syncMode = setValue(parameters.sync, 'play pause');\n    const ease = syncMode ? parseEasings(/** @type {EasingParam} */syncMode) : null;\n    const isLinear = syncMode && (syncMode === 'linear' || syncMode === none);\n    const isEase = syncMode && !(ease === none && !isLinear);\n    const isSmooth = syncMode && (isNum(syncMode) || syncMode === true || isLinear);\n    const isMethods = syncMode && isStr(syncMode) && !isEase && !isSmooth;\n    const syncMethods = isMethods ? /** @type {String} */syncMode.split(' ').map((/** @type {String} */m) => () => {\n      const linked = this.linked;\n      return linked && linked[m] ? linked[m]() : null;\n    }) : null;\n    const biDirSync = isMethods && syncMethods.length > 2;\n    /** @type {Number} */\n    this.index = scrollerIndex++;\n    /** @type {String|Number} */\n    this.id = !isUnd(parameters.id) ? parameters.id : this.index;\n    /** @type {ScrollContainer} */\n    this.container = registerAndGetScrollContainer(parameters.container);\n    /** @type {HTMLElement} */\n    this.target = null;\n    /** @type {Tickable|WAAPIAnimation} */\n    this.linked = null;\n    /** @type {Boolean} */\n    this.repeat = null;\n    /** @type {Boolean} */\n    this.horizontal = null;\n    /** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */\n    this.enter = null;\n    /** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */\n    this.leave = null;\n    /** @type {Boolean} */\n    this.sync = isEase || isSmooth || !!syncMethods;\n    /** @type {EasingFunction} */\n    this.syncEase = isEase ? ease : null;\n    /** @type {Number} */\n    this.syncSmooth = isSmooth ? syncMode === true || isLinear ? 1 : (/** @type {Number} */syncMode) : null;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncEnter = syncMethods && !biDirSync && syncMethods[0] ? syncMethods[0] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncLeave = syncMethods && !biDirSync && syncMethods[1] ? syncMethods[1] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncEnterForward = syncMethods && biDirSync && syncMethods[0] ? syncMethods[0] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncLeaveForward = syncMethods && biDirSync && syncMethods[1] ? syncMethods[1] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncEnterBackward = syncMethods && biDirSync && syncMethods[2] ? syncMethods[2] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncLeaveBackward = syncMethods && biDirSync && syncMethods[3] ? syncMethods[3] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onEnter = parameters.onEnter || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onLeave = parameters.onLeave || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onEnterForward = parameters.onEnterForward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onLeaveForward = parameters.onLeaveForward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onEnterBackward = parameters.onEnterBackward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onLeaveBackward = parameters.onLeaveBackward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onUpdate = parameters.onUpdate || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncComplete = parameters.onSyncComplete || noop;\n    /** @type {Boolean} */\n    this.reverted = false;\n    /** @type {Boolean} */\n    this.completed = false;\n    /** @type {Boolean} */\n    this.began = false;\n    /** @type {Boolean} */\n    this.isInView = false;\n    /** @type {Boolean} */\n    this.forceEnter = false;\n    /** @type {Boolean} */\n    this.hasEntered = false;\n    // /** @type {Array.<Number>} */\n    // this.offsets = [];\n    /** @type {Number} */\n    this.offset = 0;\n    /** @type {Number} */\n    this.offsetStart = 0;\n    /** @type {Number} */\n    this.offsetEnd = 0;\n    /** @type {Number} */\n    this.distance = 0;\n    /** @type {Number} */\n    this.prevProgress = 0;\n    /** @type {Array} */\n    this.thresholds = ['start', 'end', 'end', 'start'];\n    /** @type {[Number, Number, Number, Number]} */\n    this.coords = [0, 0, 0, 0];\n    /** @type {JSAnimation} */\n    this.debugStyles = null;\n    /** @type {HTMLElement} */\n    this.$debug = null;\n    /** @type {ScrollObserverParams} */\n    this._params = parameters;\n    /** @type {Boolean} */\n    this._debug = setValue(parameters.debug, false);\n    /** @type {ScrollObserver} */\n    this._next = null;\n    /** @type {ScrollObserver} */\n    this._prev = null;\n    addChild(this.container, this);\n    // Wait for the next frame to add to the container in order to handle calls to link()\n    sync(() => {\n      if (this.reverted) return;\n      if (!this.target) {\n        const target = /** @type {HTMLElement} */parseTargets(parameters.target)[0];\n        this.target = target || doc.body;\n        this.refresh();\n      }\n      if (this._debug) this.debug();\n    });\n  }\n\n  /**\n   * @param {Tickable|WAAPIAnimation} linked\n   */\n  link(linked) {\n    if (linked) {\n      // Make sure to pause the linked object in case it's added later\n      linked.pause();\n      this.linked = linked;\n      // Try to use a target of the linked object if no target parameters specified\n      if (!this._params.target) {\n        /** @type {HTMLElement} */\n        let $linkedTarget;\n        if (!isUnd(/** @type {JSAnimation} */linked.targets)) {\n          $linkedTarget = getAnimationDomTarget(/** @type {JSAnimation} */linked);\n        } else {\n          forEachChildren(/** @type {Timeline} */linked, (/** @type {JSAnimation} */child) => {\n            if (child.targets && !$linkedTarget) {\n              $linkedTarget = getAnimationDomTarget(/** @type {JSAnimation} */child);\n            }\n          });\n        }\n        // Fallback to body if no target found\n        this.target = $linkedTarget || doc.body;\n        this.refresh();\n      }\n    }\n    return this;\n  }\n  get velocity() {\n    return this.container.velocity;\n  }\n  get backward() {\n    return this.horizontal ? this.container.backwardX : this.container.backwardY;\n  }\n  get scroll() {\n    return this.horizontal ? this.container.scrollX : this.container.scrollY;\n  }\n  get progress() {\n    const p = (this.scroll - this.offsetStart) / this.distance;\n    return p === Infinity || isNaN(p) ? 0 : round(clamp(p, 0, 1), 6);\n  }\n  refresh() {\n    this.reverted = false;\n    const params = this._params;\n    this.repeat = setValue(parseScrollObserverFunctionParameter(params.repeat, this), true);\n    this.horizontal = setValue(parseScrollObserverFunctionParameter(params.axis, this), 'y') === 'x';\n    this.enter = setValue(parseScrollObserverFunctionParameter(params.enter, this), 'end start');\n    this.leave = setValue(parseScrollObserverFunctionParameter(params.leave, this), 'start end');\n    this.updateBounds();\n    this.handleScroll();\n    return this;\n  }\n  removeDebug() {\n    if (this.$debug) {\n      this.$debug.parentNode.removeChild(this.$debug);\n      this.$debug = null;\n    }\n    if (this.debugStyles) {\n      this.debugStyles.revert();\n      this.$debug = null;\n    }\n    return this;\n  }\n  debug() {\n    this.removeDebug();\n    const container = this.container;\n    const isHori = this.horizontal;\n    const $existingDebug = container.element.querySelector(':scope > .animejs-onscroll-debug');\n    const $debug = doc.createElement('div');\n    const $thresholds = doc.createElement('div');\n    const $triggers = doc.createElement('div');\n    const color = debugColors$1[this.index % debugColors$1.length];\n    const useWin = container.useWin;\n    const containerWidth = useWin ? container.winWidth : container.width;\n    const containerHeight = useWin ? container.winHeight : container.height;\n    const scrollWidth = container.scrollWidth;\n    const scrollHeight = container.scrollHeight;\n    const size = this.container.width > 360 ? 320 : 260;\n    const offLeft = isHori ? 0 : 10;\n    const offTop = isHori ? 10 : 0;\n    const half = isHori ? 24 : size / 2;\n    const labelHeight = isHori ? half : 15;\n    const labelWidth = isHori ? 60 : half;\n    const labelSize = isHori ? labelWidth : labelHeight;\n    const repeat = isHori ? 'repeat-x' : 'repeat-y';\n    /**\n     * @param {Number} v\n     * @return {String}\n     */\n    const gradientOffset = v => isHori ? '0px ' + v + 'px' : v + 'px' + ' 2px';\n    /**\n     * @param {String} c\n     * @return {String}\n     */\n    const lineCSS = c => `linear-gradient(${isHori ? 90 : 0}deg, ${c} 2px, transparent 1px)`;\n    /**\n     * @param {String} p\n     * @param {Number} l\n     * @param {Number} t\n     * @param {Number} w\n     * @param {Number} h\n     * @return {String}\n     */\n    const baseCSS = (p, l, t, w, h) => `position:${p};left:${l}px;top:${t}px;width:${w}px;height:${h}px;`;\n    $debug.style.cssText = `${baseCSS('absolute', offLeft, offTop, isHori ? scrollWidth : size, isHori ? size : scrollHeight)}\n      pointer-events: none;\n      z-index: ${this.container.zIndex++};\n      display: flex;\n      flex-direction: ${isHori ? 'column' : 'row'};\n      filter: drop-shadow(0px 1px 0px rgba(0,0,0,.75));\n    `;\n    $thresholds.style.cssText = `${baseCSS('sticky', 0, 0, isHori ? containerWidth : half, isHori ? half : containerHeight)}`;\n    if (!$existingDebug) {\n      $thresholds.style.cssText += `background:\n        ${lineCSS('#FFFF')}${gradientOffset(half - 10)} / ${isHori ? '100px 100px' : '100px 100px'} ${repeat},\n        ${lineCSS('#FFF8')}${gradientOffset(half - 10)} / ${isHori ? '10px 10px' : '10px 10px'} ${repeat};\n      `;\n    }\n    $triggers.style.cssText = `${baseCSS('relative', 0, 0, isHori ? scrollWidth : half, isHori ? half : scrollHeight)}`;\n    if (!$existingDebug) {\n      $triggers.style.cssText += `background:\n        ${lineCSS('#FFFF')}${gradientOffset(0)} / ${isHori ? '100px 10px' : '10px 100px'} ${repeat},\n        ${lineCSS('#FFF8')}${gradientOffset(0)} / ${isHori ? '10px 0px' : '0px 10px'} ${repeat};\n      `;\n    }\n    const labels = [' enter: ', ' leave: '];\n    this.coords.forEach((v, i) => {\n      const isView = i > 1;\n      const value = (isView ? 0 : this.offset) + v;\n      const isTail = i % 2;\n      const isFirst = value < labelSize;\n      const isOver = value > (isView ? isHori ? containerWidth : containerHeight : isHori ? scrollWidth : scrollHeight) - labelSize;\n      const isFlip = (isView ? isTail && !isFirst : !isTail && !isFirst) || isOver;\n      const $label = doc.createElement('div');\n      const $text = doc.createElement('div');\n      const dirProp = isHori ? isFlip ? 'right' : 'left' : isFlip ? 'bottom' : 'top';\n      const flipOffset = isFlip ? (isHori ? labelWidth : labelHeight) + (!isView ? isHori ? -1 : -2 : isHori ? -1 : isOver ? 0 : -2) : !isView ? isHori ? 1 : 0 : isHori ? 1 : 0;\n      // $text.innerHTML = `${!isView ? '' : labels[isTail] + ' '}${this.id}: ${this.thresholds[i]} ${isView ? '' : labels[isTail]}`;\n      $text.innerHTML = `${this.id}${labels[isTail]}${this.thresholds[i]}`;\n      $label.style.cssText = `${baseCSS('absolute', 0, 0, labelWidth, labelHeight)}\n        display: flex;\n        flex-direction: ${isHori ? 'column' : 'row'};\n        justify-content: flex-${isView ? 'start' : 'end'};\n        align-items: flex-${isFlip ? 'end' : 'start'};\n        border-${dirProp}: 2px ${isTail ? 'solid' : 'solid'} ${color};\n      `;\n      $text.style.cssText = `\n        overflow: hidden;\n        max-width: ${size / 2 - 10}px;\n        height: ${labelHeight};\n        margin-${isHori ? isFlip ? 'right' : 'left' : isFlip ? 'bottom' : 'top'}: -2px;\n        padding: 1px;\n        font-family: ui-monospace, monospace;\n        font-size: 10px;\n        letter-spacing: -.025em;\n        line-height: 9px;\n        font-weight: 600;\n        text-align: ${isHori && isFlip || !isHori && !isView ? 'right' : 'left'};\n        white-space: pre;\n        text-overflow: ellipsis;\n        color: ${isTail ? color : 'rgba(0,0,0,.75)'};\n        background-color: ${isTail ? 'rgba(0,0,0,.65)' : color};\n        border: 2px solid ${isTail ? color : 'transparent'};\n        border-${isHori ? isFlip ? 'top-left' : 'top-right' : isFlip ? 'top-left' : 'bottom-left'}-radius: 5px;\n        border-${isHori ? isFlip ? 'bottom-left' : 'bottom-right' : isFlip ? 'top-right' : 'bottom-right'}-radius: 5px;\n      `;\n      $label.appendChild($text);\n      let position = value - flipOffset + (isHori ? 1 : 0);\n      $label.style[isHori ? 'left' : 'top'] = `${position}px`;\n      // $label.style[isHori ? 'left' : 'top'] = value - flipOffset + (!isFlip && isFirst && !isView ? 1 : isFlip ? 0 : -2) + 'px';\n      (isView ? $thresholds : $triggers).appendChild($label);\n    });\n    $debug.appendChild($thresholds);\n    $debug.appendChild($triggers);\n    container.element.appendChild($debug);\n    if (!$existingDebug) $debug.classList.add('animejs-onscroll-debug');\n    this.$debug = $debug;\n    const containerPosition = getTargetValue(container.element, 'position');\n    if (containerPosition === 'static') {\n      this.debugStyles = setTargetValues(container.element, {\n        position: 'relative '\n      });\n    }\n  }\n  updateBounds() {\n    if (this._debug) {\n      this.removeDebug();\n    }\n    let stickys;\n    const $target = this.target;\n    const container = this.container;\n    const isHori = this.horizontal;\n    const linked = this.linked;\n    let linkedTime;\n    let $el = $target;\n    // let offsetX = 0;\n    // let offsetY = 0;\n    // let $offsetParent = $el;\n    /** @type {Element} */\n    if (linked) {\n      linkedTime = linked.currentTime;\n      linked.seek(0, true);\n    }\n    /* Old implementation to get offset and targetSize before fixing https://github.com/juliangarnier/anime/issues/1021\n    // const isContainerStatic = getTargetValue(container.element, 'position') === 'static' ? setTargetValues(container.element, { position: 'relative '}) : false;\n    // while ($el && $el !== container.element && $el !== doc.body) {\n    //   const isSticky = getTargetValue($el, 'position') === 'sticky' ?\n    //                    setTargetValues($el, { position: 'static' }) :\n    //                    false;\n    //   if ($el === $offsetParent) {\n    //     offsetX += $el.offsetLeft || 0;\n    //     offsetY += $el.offsetTop || 0;\n    //     $offsetParent = $el.offsetParent;\n    //   }\n    //   $el = /** @type {HTMLElement} */\n    $el.parentElement;\n    //   if (isSticky) {\n    //     if (!stickys) stickys = [];\n    //     stickys.push(isSticky);\n    //   }\n    // }\n    // if (isContainerStatic) isContainerStatic.revert();\n    // const offset = isHori ? offsetX : offsetY;\n    // const targetSize = isHori ? $target.offsetWidth : $target.offsetHeight;\n\n    while ($el && $el !== container.element && $el !== doc.body) {\n      const isSticky = getTargetValue($el, 'position') === 'sticky' ? setTargetValues($el, {\n        position: 'static'\n      }) : false;\n      $el = $el.parentElement;\n      if (isSticky) {\n        if (!stickys) stickys = [];\n        stickys.push(isSticky);\n      }\n    }\n    const rect = $target.getBoundingClientRect();\n    const offset = isHori ? rect.left + container.scrollX - container.left : rect.top + container.scrollY - container.top;\n    const targetSize = isHori ? rect.width : rect.height;\n    const containerSize = isHori ? container.width : container.height;\n    const scrollSize = isHori ? container.scrollWidth : container.scrollHeight;\n    const maxScroll = scrollSize - containerSize;\n    const enter = this.enter;\n    const leave = this.leave;\n\n    /** @type {ScrollThresholdValue} */\n    let enterTarget = 'start';\n    /** @type {ScrollThresholdValue} */\n    let leaveTarget = 'end';\n    /** @type {ScrollThresholdValue} */\n    let enterContainer = 'end';\n    /** @type {ScrollThresholdValue} */\n    let leaveContainer = 'start';\n    if (isStr(enter)) {\n      const splitted = /** @type {String} */enter.split(' ');\n      enterContainer = splitted[0];\n      enterTarget = splitted.length > 1 ? splitted[1] : enterTarget;\n    } else if (isObj(enter)) {\n      const e = /** @type {ScrollThresholdParam} */enter;\n      if (!isUnd(e.container)) enterContainer = e.container;\n      if (!isUnd(e.target)) enterTarget = e.target;\n    } else if (isNum(enter)) {\n      enterContainer = /** @type {Number} */enter;\n    }\n    if (isStr(leave)) {\n      const splitted = /** @type {String} */leave.split(' ');\n      leaveContainer = splitted[0];\n      leaveTarget = splitted.length > 1 ? splitted[1] : leaveTarget;\n    } else if (isObj(leave)) {\n      const t = /** @type {ScrollThresholdParam} */leave;\n      if (!isUnd(t.container)) leaveContainer = t.container;\n      if (!isUnd(t.target)) leaveTarget = t.target;\n    } else if (isNum(leave)) {\n      leaveContainer = /** @type {Number} */leave;\n    }\n    const parsedEnterTarget = parseBoundValue($target, enterTarget, targetSize);\n    const parsedLeaveTarget = parseBoundValue($target, leaveTarget, targetSize);\n    const under = parsedEnterTarget + offset - containerSize;\n    const over = parsedLeaveTarget + offset - maxScroll;\n    const parsedEnterContainer = parseBoundValue($target, enterContainer, containerSize, under, over);\n    const parsedLeaveContainer = parseBoundValue($target, leaveContainer, containerSize, under, over);\n    const offsetStart = parsedEnterTarget + offset - parsedEnterContainer;\n    const offsetEnd = parsedLeaveTarget + offset - parsedLeaveContainer;\n    const scrollDelta = offsetEnd - offsetStart;\n    // this.offsets[0] = offsetX;\n    // this.offsets[1] = offsetY;\n    this.offset = offset;\n    this.offsetStart = offsetStart;\n    this.offsetEnd = offsetEnd;\n    this.distance = scrollDelta <= 0 ? 0 : scrollDelta;\n    this.thresholds = [enterTarget, leaveTarget, enterContainer, leaveContainer];\n    this.coords = [parsedEnterTarget, parsedLeaveTarget, parsedEnterContainer, parsedLeaveContainer];\n    if (stickys) {\n      stickys.forEach(sticky => sticky.revert());\n    }\n    if (linked) {\n      linked.seek(linkedTime, true);\n    }\n    if (this._debug) {\n      this.debug();\n    }\n  }\n  handleScroll() {\n    const linked = this.linked;\n    const sync = this.sync;\n    const syncEase = this.syncEase;\n    const syncSmooth = this.syncSmooth;\n    const shouldSeek = linked && (syncEase || syncSmooth);\n    const isHori = this.horizontal;\n    const container = this.container;\n    const scroll = this.scroll;\n    const isBefore = scroll <= this.offsetStart;\n    const isAfter = scroll >= this.offsetEnd;\n    const isInView = !isBefore && !isAfter;\n    const isOnTheEdge = scroll === this.offsetStart || scroll === this.offsetEnd;\n    const forceEnter = !this.hasEntered && isOnTheEdge;\n    const $debug = this._debug && this.$debug;\n    let hasUpdated = false;\n    let syncCompleted = false;\n    let p = this.progress;\n    if (isBefore && this.began) {\n      this.began = false;\n    }\n    if (p > 0 && !this.began) {\n      this.began = true;\n    }\n    if (shouldSeek) {\n      const lp = linked.progress;\n      if (syncSmooth && isNum(syncSmooth)) {\n        if (/** @type {Number} */syncSmooth < 1) {\n          const step = 0.0001;\n          const snap = lp < p && p === 1 ? step : lp > p && !p ? -1e-4 : 0;\n          p = round(lerp(lp, p, interpolate(.01, .2, /** @type {Number} */syncSmooth), false) + snap, 6);\n        }\n      } else if (syncEase) {\n        p = syncEase(p);\n      }\n      hasUpdated = p !== this.prevProgress;\n      syncCompleted = lp === 1;\n      if (hasUpdated && !syncCompleted && syncSmooth && lp) {\n        container.wakeTicker.restart();\n      }\n    }\n    if ($debug) {\n      const sticky = isHori ? container.scrollY : container.scrollX;\n      $debug.style[isHori ? 'top' : 'left'] = sticky + 10 + 'px';\n    }\n\n    // Trigger enter callbacks if already in view or when entering the view\n    if (isInView && !this.isInView || forceEnter && !this.forceEnter && !this.hasEntered) {\n      if (isInView) this.isInView = true;\n      if (!this.forceEnter || !this.hasEntered) {\n        if ($debug && isInView) $debug.style.zIndex = `${this.container.zIndex++}`;\n        this.onSyncEnter(this);\n        this.onEnter(this);\n        if (this.backward) {\n          this.onSyncEnterBackward(this);\n          this.onEnterBackward(this);\n        } else {\n          this.onSyncEnterForward(this);\n          this.onEnterForward(this);\n        }\n        this.hasEntered = true;\n        if (forceEnter) this.forceEnter = true;\n      } else if (isInView) {\n        this.forceEnter = false;\n      }\n    }\n    if (isInView || !isInView && this.isInView) {\n      hasUpdated = true;\n    }\n    if (hasUpdated) {\n      if (shouldSeek) linked.seek(linked.duration * p);\n      this.onUpdate(this);\n    }\n    if (!isInView && this.isInView) {\n      this.isInView = false;\n      this.onSyncLeave(this);\n      this.onLeave(this);\n      if (this.backward) {\n        this.onSyncLeaveBackward(this);\n        this.onLeaveBackward(this);\n      } else {\n        this.onSyncLeaveForward(this);\n        this.onLeaveForward(this);\n      }\n      if (sync && !syncSmooth) {\n        syncCompleted = true;\n      }\n    }\n    if (p >= 1 && this.began && !this.completed && (sync && syncCompleted || !sync)) {\n      if (sync) {\n        this.onSyncComplete(this);\n      }\n      this.completed = true;\n      if (!this.repeat && !linked || !this.repeat && linked && linked.completed) {\n        this.revert();\n      }\n    }\n    if (p < 1 && this.completed) {\n      this.completed = false;\n    }\n    this.prevProgress = p;\n  }\n  revert() {\n    if (this.reverted) return;\n    const container = this.container;\n    removeChild(container, this);\n    if (!container._head) {\n      container.revert();\n    }\n    if (this._debug) {\n      this.removeDebug();\n    }\n    this.reverted = true;\n    return this;\n  }\n}\n\n/**\n * @param {ScrollObserverParams} [parameters={}]\n * @return {ScrollObserver}\n */\nconst onScroll = (parameters = {}) => new ScrollObserver(parameters);\nconst segmenter = !isUnd(Intl) && Intl.Segmenter;\nconst valueRgx = /\\{value\\}/g;\nconst indexRgx = /\\{i\\}/g;\nconst whiteSpaceGroupRgx = /(\\s+)/;\nconst whiteSpaceRgx = /^\\s+$/;\nconst lineType = 'line';\nconst wordType = 'word';\nconst charType = 'char';\nconst dataLine = `data-line`;\n\n/**\n * @typedef {Object} Segment\n * @property {String} segment\n * @property {Boolean} [isWordLike]\n */\n\n/**\n * @typedef {Object} Segmenter\n * @property {function(String): Iterable<Segment>} segment\n */\n\n/** @type {Segmenter} */\nlet wordSegmenter = null;\n/** @type {Segmenter} */\nlet graphemeSegmenter = null;\nlet $splitTemplate = null;\n\n/**\n * @param  {Segment} seg\n * @return {Boolean}\n */\nconst isSegmentWordLike = seg => {\n  return seg.isWordLike || seg.segment === ' ' ||\n  // Consider spaces as words first, then handle them diffrently later\n  isNum(+seg.segment); // Safari doesn't considers numbers as words\n};\n\n/**\n * @param {HTMLElement} $el\n */\nconst setAriaHidden = $el => $el.setAttribute('aria-hidden', 'true');\n\n/**\n * @param {DOMTarget} $el\n * @param {String} type\n * @return {Array<HTMLElement>}\n */\nconst getAllTopLevelElements = ($el, type) => [...(/** @type {*} */$el.querySelectorAll(`[data-${type}]:not([data-${type}] [data-${type}])`))];\nconst debugColors = {\n  line: '#00D672',\n  word: '#FF4B4B',\n  char: '#5A87FF'\n};\n\n/**\n * @param {HTMLElement} $el\n */\nconst filterEmptyElements = $el => {\n  if (!$el.childElementCount && !$el.textContent.trim()) {\n    const $parent = $el.parentElement;\n    $el.remove();\n    if ($parent) filterEmptyElements($parent);\n  }\n};\n\n/**\n * @param {HTMLElement} $el\n * @param {Number} lineIndex\n * @param {Set<HTMLElement>} bin\n * @returns {Set<HTMLElement>}\n */\nconst filterLineElements = ($el, lineIndex, bin) => {\n  const dataLineAttr = $el.getAttribute(dataLine);\n  if (dataLineAttr !== null && +dataLineAttr !== lineIndex || $el.tagName === 'BR') bin.add($el);\n  let i = $el.childElementCount;\n  while (i--) filterLineElements(/** @type {HTMLElement} */$el.children[i], lineIndex, bin);\n  return bin;\n};\n\n/**\n * @param  {'line'|'word'|'char'} type\n * @param  {splitTemplateParams} params\n * @return {String}\n */\nconst generateTemplate = (type, params = {}) => {\n  let template = ``;\n  const classString = isStr(params.class) ? ` class=\"${params.class}\"` : '';\n  const cloneType = setValue(params.clone, false);\n  const wrapType = setValue(params.wrap, false);\n  const overflow = wrapType ? wrapType === true ? 'clip' : wrapType : cloneType ? 'clip' : false;\n  if (wrapType) template += `<span${overflow ? ` style=\"overflow:${overflow};\"` : ''}>`;\n  template += `<span${classString}${cloneType ? ` style=\"position:relative;\"` : ''} data-${type}=\"{i}\">`;\n  if (cloneType) {\n    const left = cloneType === 'left' ? '-100%' : cloneType === 'right' ? '100%' : '0';\n    const top = cloneType === 'top' ? '-100%' : cloneType === 'bottom' ? '100%' : '0';\n    template += `<span>{value}</span>`;\n    template += `<span inert style=\"position:absolute;top:${top};left:${left};white-space:nowrap;\">{value}</span>`;\n  } else {\n    template += `{value}`;\n  }\n  template += `</span>`;\n  if (wrapType) template += `</span>`;\n  return template;\n};\n\n/**\n * @param  {String|SplitFunctionValue} htmlTemplate\n * @param  {Array<HTMLElement>} store\n * @param  {Node|HTMLElement} node\n * @param  {DocumentFragment} $parentFragment\n * @param  {'line'|'word'|'char'} type\n * @param  {Boolean} debug\n * @param  {Number} lineIndex\n * @param  {Number} [wordIndex]\n * @param  {Number} [charIndex]\n * @return {HTMLElement}\n */\nconst processHTMLTemplate = (htmlTemplate, store, node, $parentFragment, type, debug, lineIndex, wordIndex, charIndex) => {\n  const isLine = type === lineType;\n  const isChar = type === charType;\n  const className = `_${type}_`;\n  const template = isFnc(htmlTemplate) ? htmlTemplate(node) : htmlTemplate;\n  const displayStyle = isLine ? 'block' : 'inline-block';\n  $splitTemplate.innerHTML = template.replace(valueRgx, `<i class=\"${className}\"></i>`).replace(indexRgx, `${isChar ? charIndex : isLine ? lineIndex : wordIndex}`);\n  const $content = $splitTemplate.content;\n  const $highestParent = /** @type {HTMLElement} */$content.firstElementChild;\n  const $split = /** @type {HTMLElement} */$content.querySelector(`[data-${type}]`) || $highestParent;\n  const $replacables = /** @type {NodeListOf<HTMLElement>} */$content.querySelectorAll(`i.${className}`);\n  const replacablesLength = $replacables.length;\n  if (replacablesLength) {\n    $highestParent.style.display = displayStyle;\n    $split.style.display = displayStyle;\n    $split.setAttribute(dataLine, `${lineIndex}`);\n    if (!isLine) {\n      $split.setAttribute('data-word', `${wordIndex}`);\n      if (isChar) $split.setAttribute('data-char', `${charIndex}`);\n    }\n    let i = replacablesLength;\n    while (i--) {\n      const $replace = $replacables[i];\n      const $closestParent = $replace.parentElement;\n      $closestParent.style.display = displayStyle;\n      if (isLine) {\n        $closestParent.innerHTML = /** @type {HTMLElement} */node.innerHTML;\n      } else {\n        $closestParent.replaceChild(node.cloneNode(true), $replace);\n      }\n    }\n    store.push($split);\n    $parentFragment.appendChild($content);\n  } else {\n    console.warn(`The expression \"{value}\" is missing from the provided template.`);\n  }\n  if (debug) $highestParent.style.outline = `1px dotted ${debugColors[type]}`;\n  return $highestParent;\n};\n\n/**\n * A class that splits text into words and wraps them in span elements while preserving the original HTML structure.\n * @class\n */\nclass TextSplitter {\n  /**\n   * @param  {HTMLElement|NodeList|String|Array<HTMLElement>} target\n   * @param  {TextSplitterParams} [parameters]\n   */\n  constructor(target, parameters = {}) {\n    // Only init segmenters when needed\n    if (!wordSegmenter) wordSegmenter = segmenter ? new segmenter([], {\n      granularity: wordType\n    }) : {\n      segment: text => {\n        const segments = [];\n        const words = text.split(whiteSpaceGroupRgx);\n        for (let i = 0, l = words.length; i < l; i++) {\n          const segment = words[i];\n          segments.push({\n            segment,\n            isWordLike: !whiteSpaceRgx.test(segment) // Consider non-whitespace as word-like\n          });\n        }\n        return segments;\n      }\n    };\n    if (!graphemeSegmenter) graphemeSegmenter = segmenter ? new segmenter([], {\n      granularity: 'grapheme'\n    }) : {\n      segment: text => [...text].map(char => ({\n        segment: char\n      }))\n    };\n    if (!$splitTemplate && isBrowser) $splitTemplate = doc.createElement('template');\n    if (scope.current) scope.current.register(this);\n    const {\n      words,\n      chars,\n      lines,\n      accessible,\n      includeSpaces,\n      debug\n    } = parameters;\n    const $target = /** @type {HTMLElement} */(target = isArr(target) ? target[0] : target) && /** @type {Node} */target.nodeType ? target : (getNodeList(target) || [])[0];\n    const lineParams = lines === true ? {} : lines;\n    const wordParams = words === true || isUnd(words) ? {} : words;\n    const charParams = chars === true ? {} : chars;\n    this.debug = setValue(debug, false);\n    this.includeSpaces = setValue(includeSpaces, false);\n    this.accessible = setValue(accessible, true);\n    this.linesOnly = lineParams && !wordParams && !charParams;\n    /** @type {String|false|SplitFunctionValue} */\n    this.lineTemplate = isObj(lineParams) ? generateTemplate(lineType, /** @type {splitTemplateParams} */lineParams) : lineParams;\n    /** @type {String|false|SplitFunctionValue} */\n    this.wordTemplate = isObj(wordParams) || this.linesOnly ? generateTemplate(wordType, /** @type {splitTemplateParams} */wordParams) : wordParams;\n    /** @type {String|false|SplitFunctionValue} */\n    this.charTemplate = isObj(charParams) ? generateTemplate(charType, /** @type {splitTemplateParams} */charParams) : charParams;\n    this.$target = $target;\n    this.html = $target && $target.innerHTML;\n    this.lines = [];\n    this.words = [];\n    this.chars = [];\n    this.effects = [];\n    this.effectsCleanups = [];\n    this.cache = null;\n    this.ready = false;\n    this.width = 0;\n    this.resizeTimeout = null;\n    const handleSplit = () => this.html && (lineParams || wordParams || charParams) && this.split();\n    // Make sure this is declared before calling handleSplit() in case revert() is called inside an effect callback\n    this.resizeObserver = new ResizeObserver(() => {\n      // Use a setTimeout instead of a Timer for better tree shaking\n      clearTimeout(this.resizeTimeout);\n      this.resizeTimeout = setTimeout(() => {\n        const currentWidth = /** @type {HTMLElement} */$target.offsetWidth;\n        if (currentWidth === this.width) return;\n        this.width = currentWidth;\n        handleSplit();\n      }, 150);\n    });\n    // Only declare the font ready promise when splitting by lines and not alreay split\n    if (this.lineTemplate && !this.ready) {\n      doc.fonts.ready.then(handleSplit);\n    } else {\n      handleSplit();\n    }\n    $target ? this.resizeObserver.observe($target) : console.warn('No Text Splitter target found.');\n  }\n\n  /**\n   * @param  {(...args: any[]) => Tickable | (() => void)} effect\n   * @return this\n   */\n  addEffect(effect) {\n    if (!isFnc(effect)) return console.warn('Effect must return a function.');\n    const refreshableEffect = createRefreshable(effect);\n    this.effects.push(refreshableEffect);\n    if (this.ready) this.effectsCleanups[this.effects.length - 1] = refreshableEffect(this);\n    return this;\n  }\n  revert() {\n    clearTimeout(this.resizeTimeout);\n    this.lines.length = this.words.length = this.chars.length = 0;\n    this.resizeObserver.disconnect();\n    // Make sure to revert the effects after disconnecting the resizeObserver to avoid triggering it in the process\n    this.effectsCleanups.forEach(cleanup => isFnc(cleanup) ? cleanup(this) : cleanup.revert && cleanup.revert());\n    this.$target.innerHTML = this.html;\n    return this;\n  }\n\n  /**\n   * Recursively processes a node and its children\n   * @param {Node} node\n   */\n  splitNode(node) {\n    const wordTemplate = this.wordTemplate;\n    const charTemplate = this.charTemplate;\n    const includeSpaces = this.includeSpaces;\n    const debug = this.debug;\n    const nodeType = node.nodeType;\n    if (nodeType === 3) {\n      const nodeText = node.nodeValue;\n      // If the nodeText is only whitespace, leave it as is\n      if (nodeText.trim()) {\n        const tempWords = [];\n        const words = this.words;\n        const chars = this.chars;\n        const wordSegments = wordSegmenter.segment(nodeText);\n        const $wordsFragment = doc.createDocumentFragment();\n        let prevSeg = null;\n        for (const wordSegment of wordSegments) {\n          const segment = wordSegment.segment;\n          const isWordLike = isSegmentWordLike(wordSegment);\n          // Determine if this segment should be a new word, first segment always becomes a new word\n          if (!prevSeg || isWordLike && prevSeg && isSegmentWordLike(prevSeg)) {\n            tempWords.push(segment);\n          } else {\n            // Only concatenate if both current and previous are non-word-like and don't contain spaces\n            const lastWordIndex = tempWords.length - 1;\n            const lastWord = tempWords[lastWordIndex];\n            if (!lastWord.includes(' ') && !segment.includes(' ')) {\n              tempWords[lastWordIndex] += segment;\n            } else {\n              tempWords.push(segment);\n            }\n          }\n          prevSeg = wordSegment;\n        }\n        for (let i = 0, l = tempWords.length; i < l; i++) {\n          const word = tempWords[i];\n          if (!word.trim()) {\n            // Preserve whitespace only if includeSpaces is false and if the current space is not the first node\n            if (i && includeSpaces) continue;\n            $wordsFragment.appendChild(doc.createTextNode(word));\n          } else {\n            const nextWord = tempWords[i + 1];\n            const hasWordFollowingSpace = includeSpaces && nextWord && !nextWord.trim();\n            const wordToProcess = word;\n            const charSegments = charTemplate ? graphemeSegmenter.segment(wordToProcess) : null;\n            const $charsFragment = charTemplate ? doc.createDocumentFragment() : doc.createTextNode(hasWordFollowingSpace ? word + '\\xa0' : word);\n            if (charTemplate) {\n              const charSegmentsArray = [...charSegments];\n              for (let j = 0, jl = charSegmentsArray.length; j < jl; j++) {\n                const charSegment = charSegmentsArray[j];\n                const isLastChar = j === jl - 1;\n                // If this is the last character and includeSpaces is true with a following space, append the space\n                const charText = isLastChar && hasWordFollowingSpace ? charSegment.segment + '\\xa0' : charSegment.segment;\n                const $charNode = doc.createTextNode(charText);\n                processHTMLTemplate(charTemplate, chars, $charNode, /** @type {DocumentFragment} */$charsFragment, charType, debug, -1, words.length, chars.length);\n              }\n            }\n            if (wordTemplate) {\n              processHTMLTemplate(wordTemplate, words, $charsFragment, $wordsFragment, wordType, debug, -1, words.length, chars.length);\n              // Chars elements must be re-parsed in the split() method if both words and chars are parsed\n            } else if (charTemplate) {\n              $wordsFragment.appendChild($charsFragment);\n            } else {\n              $wordsFragment.appendChild(doc.createTextNode(word));\n            }\n            // Skip the next iteration if we included a space\n            if (hasWordFollowingSpace) i++;\n          }\n        }\n        node.parentNode.replaceChild($wordsFragment, node);\n      }\n    } else if (nodeType === 1) {\n      // Converting to an array is necessary to work around childNodes pottential mutation\n      const childNodes = /** @type {Array<Node>} */[...(/** @type {*} */node.childNodes)];\n      for (let i = 0, l = childNodes.length; i < l; i++) this.splitNode(childNodes[i]);\n    }\n  }\n\n  /**\n   * @param {Boolean} clearCache\n   * @return {this}\n   */\n  split(clearCache = false) {\n    const $el = this.$target;\n    const isCached = !!this.cache && !clearCache;\n    const lineTemplate = this.lineTemplate;\n    const wordTemplate = this.wordTemplate;\n    const charTemplate = this.charTemplate;\n    const fontsReady = doc.fonts.status !== 'loading';\n    const canSplitLines = lineTemplate && fontsReady;\n    this.ready = !lineTemplate || fontsReady;\n    if (canSplitLines || clearCache) {\n      // No need to revert effects animations here since it's already taken care by the refreshable\n      this.effectsCleanups.forEach(cleanup => isFnc(cleanup) && cleanup(this));\n    }\n    if (!isCached) {\n      if (clearCache) {\n        $el.innerHTML = this.html;\n        this.words.length = this.chars.length = 0;\n      }\n      this.splitNode($el);\n      this.cache = $el.innerHTML;\n    }\n    if (canSplitLines) {\n      if (isCached) $el.innerHTML = this.cache;\n      this.lines.length = 0;\n      if (wordTemplate) this.words = getAllTopLevelElements($el, wordType);\n    }\n    // Always reparse characters after a line reset or if both words and chars are activated\n    if (charTemplate && (canSplitLines || wordTemplate)) {\n      this.chars = getAllTopLevelElements($el, charType);\n    }\n    // Words are used when lines only and prioritized over chars\n    const elementsArray = this.words.length ? this.words : this.chars;\n    let y,\n      linesCount = 0;\n    for (let i = 0, l = elementsArray.length; i < l; i++) {\n      const $el = elementsArray[i];\n      const {\n        top,\n        height\n      } = $el.getBoundingClientRect();\n      if (y && top - y > height * .5) linesCount++;\n      $el.setAttribute(dataLine, `${linesCount}`);\n      const nested = $el.querySelectorAll(`[${dataLine}]`);\n      let c = nested.length;\n      while (c--) nested[c].setAttribute(dataLine, `${linesCount}`);\n      y = top;\n    }\n    if (canSplitLines) {\n      const linesFragment = doc.createDocumentFragment();\n      const parents = new Set();\n      const clones = [];\n      for (let lineIndex = 0; lineIndex < linesCount + 1; lineIndex++) {\n        const $clone = /** @type {HTMLElement} */$el.cloneNode(true);\n        filterLineElements($clone, lineIndex, new Set()).forEach($el => {\n          const $parent = $el.parentElement;\n          if ($parent) parents.add($parent);\n          $el.remove();\n        });\n        clones.push($clone);\n      }\n      parents.forEach(filterEmptyElements);\n      for (let cloneIndex = 0, clonesLength = clones.length; cloneIndex < clonesLength; cloneIndex++) {\n        processHTMLTemplate(lineTemplate, this.lines, clones[cloneIndex], linesFragment, lineType, this.debug, cloneIndex);\n      }\n      $el.innerHTML = '';\n      $el.appendChild(linesFragment);\n      if (wordTemplate) this.words = getAllTopLevelElements($el, wordType);\n      if (charTemplate) this.chars = getAllTopLevelElements($el, charType);\n    }\n    // Remove the word wrappers and clear the words array if lines split only\n    if (this.linesOnly) {\n      const words = this.words;\n      let w = words.length;\n      while (w--) {\n        const $word = words[w];\n        $word.replaceWith($word.textContent);\n      }\n      words.length = 0;\n    }\n    if (this.accessible && (canSplitLines || !isCached)) {\n      const $accessible = doc.createElement('span');\n      // Make the accessible element visually-hidden (https://www.scottohara.me/blog/2017/04/14/inclusively-hidden.html)\n      $accessible.style.cssText = `position:absolute;overflow:hidden;clip:rect(0 0 0 0);clip-path:inset(50%);width:1px;height:1px;white-space:nowrap;`;\n      // $accessible.setAttribute('tabindex', '-1');\n      $accessible.innerHTML = this.html;\n      $el.insertBefore($accessible, $el.firstChild);\n      this.lines.forEach(setAriaHidden);\n      this.words.forEach(setAriaHidden);\n      this.chars.forEach(setAriaHidden);\n    }\n    this.width = /** @type {HTMLElement} */$el.offsetWidth;\n    if (canSplitLines || clearCache) {\n      this.effects.forEach((effect, i) => this.effectsCleanups[i] = effect(this));\n    }\n    return this;\n  }\n  refresh() {\n    this.split(true);\n  }\n}\n\n/**\n * @param  {HTMLElement|NodeList|String|Array<HTMLElement>} target\n * @param  {TextSplitterParams} [parameters]\n * @return {TextSplitter}\n */\nconst split = (target, parameters) => new TextSplitter(target, parameters);\nconst text = {\n  split\n};\n\n/**\n * @param  {Number|String|[Number|String,Number|String]} val\n * @param  {StaggerParams} params\n * @return {StaggerFunction}\n */\nconst stagger = (val, params = {}) => {\n  let values = [];\n  let maxValue = 0;\n  const from = params.from;\n  const reversed = params.reversed;\n  const ease = params.ease;\n  const hasEasing = !isUnd(ease);\n  const hasSpring = hasEasing && !isUnd(/** @type {Spring} */ease.ease);\n  const staggerEase = hasSpring ? /** @type {Spring} */ease.ease : hasEasing ? parseEasings(ease) : null;\n  const grid = params.grid;\n  const axis = params.axis;\n  const customTotal = params.total;\n  const fromFirst = isUnd(from) || from === 0 || from === 'first';\n  const fromCenter = from === 'center';\n  const fromLast = from === 'last';\n  const fromRandom = from === 'random';\n  const isRange = isArr(val);\n  const useProp = params.use;\n  const val1 = isRange ? parseNumber(val[0]) : parseNumber(val);\n  const val2 = isRange ? parseNumber(val[1]) : 0;\n  const unitMatch = unitsExecRgx.exec((isRange ? val[1] : val) + emptyString);\n  const start = params.start || 0 + (isRange ? val1 : 0);\n  let fromIndex = fromFirst ? 0 : isNum(from) ? from : 0;\n  return (target, i, t, tl) => {\n    const [registeredTarget] = registerTargets(target);\n    const total = isUnd(customTotal) ? t : customTotal;\n    const customIndex = !isUnd(useProp) ? isFnc(useProp) ? useProp(registeredTarget, i, total) : getOriginalAnimatableValue(registeredTarget, useProp) : false;\n    const staggerIndex = isNum(customIndex) || isStr(customIndex) && isNum(+customIndex) ? +customIndex : i;\n    if (fromCenter) fromIndex = (total - 1) / 2;\n    if (fromLast) fromIndex = total - 1;\n    if (!values.length) {\n      for (let index = 0; index < total; index++) {\n        if (!grid) {\n          values.push(abs(fromIndex - index));\n        } else {\n          const fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;\n          const fromY = !fromCenter ? floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;\n          const toX = index % grid[0];\n          const toY = floor(index / grid[0]);\n          const distanceX = fromX - toX;\n          const distanceY = fromY - toY;\n          let value = sqrt(distanceX * distanceX + distanceY * distanceY);\n          if (axis === 'x') value = -distanceX;\n          if (axis === 'y') value = -distanceY;\n          values.push(value);\n        }\n        maxValue = max(...values);\n      }\n      if (staggerEase) values = values.map(val => staggerEase(val / maxValue) * maxValue);\n      if (reversed) values = values.map(val => axis ? val < 0 ? val * -1 : -val : abs(maxValue - val));\n      if (fromRandom) values = shuffle(values);\n    }\n    const spacing = isRange ? (val2 - val1) / maxValue : val1;\n    const offset = tl ? parseTimelinePosition(tl, isUnd(params.start) ? tl.iterationDuration : start) : (/** @type {Number} */start);\n    /** @type {String|Number} */\n    let output = offset + (spacing * round(values[staggerIndex], 2) || 0);\n    if (params.modifier) output = params.modifier(output);\n    if (unitMatch) output = `${output}${unitMatch[2]}`;\n    return output;\n  };\n};\nexport { Animatable, Draggable, JSAnimation, Scope, ScrollObserver, Spring, TextSplitter, Timeline, Timer, WAAPIAnimation, animate, createAnimatable, createDraggable, createScope, createSpring, createTimeline, createTimer, eases, engine, onScroll, scrollContainers, stagger, svg, text, utils, waapi };","map":{"version":3,"names":["isBrowser","window","win","doc","document","tweenTypes","OBJECT","ATTRIBUTE","CSS","TRANSFORM","CSS_VAR","valueTypes","NUMBER","UNIT","COLOR","COMPLEX","tickModes","NONE","AUTO","FORCE","compositionTypes","replace","none","blend","isRegisteredTargetSymbol","Symbol","isDomSymbol","isSvgSymbol","transformsSymbol","morphPointsSymbol","proxyTargetSymbol","minValue","maxValue","K","maxFps","emptyString","shortTransforms","map","Map","set","validTransforms","transformsFragmentStrings","reduce","a","v","noop","hexTestRgx","rgbExecRgx","rgbaExecRgx","hslExecRgx","hslaExecRgx","digitWithExponentRgx","unitsExecRgx","lowerCaseRgx","transformsExecRgx","relativeValuesExecRgx","defaults","id","keyframes","playbackEase","playbackRate","frameRate","loop","reversed","alternate","autoplay","duration","delay","loopDelay","ease","composition","modifier","onBegin","onBeforeUpdate","onUpdate","onLoop","onPause","onComplete","onRender","scope","current","root","globals","precision","timeScale","tickThreshold","globalVersions","version","engine","AnimeJS","push","toLowerCase","str","stringStartsWith","sub","indexOf","now","Date","isArr","Array","isArray","isObj","constructor","Object","isNum","isNaN","isStr","isFnc","isUnd","isNil","isSvg","SVGElement","isHex","test","isRgb","isHsl","isCol","isKey","hasOwnProperty","parseNumber","parseFloat","pow","Math","sqrt","sin","cos","abs","exp","ceil","floor","asin","max","atan2","PI","_round","round","clamp","min","powCache","decimalLength","p","snap","increment","closest","cv","interpolate","start","end","progress","random","m","shuffle","items","length","t","i","clampInfinity","Infinity","normalizeTime","cloneArray","mergeObjects","o1","o2","merged","o1p","forEachChildren","parent","callback","reverse","prevProp","nextProp","next","_head","adjustedNextProp","_tail","currentNext","removeChild","child","prev","addChild","sortMethod","createRefreshable","tracked","args","currentIteration","currentIterationProgress","iterationProgress","_alternate","revert","cleanup","Clock","initTime","deltaTime","_currentTime","_elapsedTime","_startTime","_lastTime","_scheduledTime","_frameDuration","_fps","_speed","_hasChildren","fps","previousFrameDuration","fr","frameDuration","speed","pbr","requestTick","time","scheduledTime","elapsedTime","frameDelta","computeDeltaTime","delta","render","tickable","muteCallbacks","internalRender","tickMode","completed","iterationDuration","iterationCount","_currentIteration","_loopDelay","_reversed","tickableDelay","_delay","tickablePrevAbsoluteTime","tickableEndTime","tickableAbsoluteTime","tickablePrevTime","tickableCurrentTime","isCurrentTimeAboveZero","isCurrentTimeEqualOrAboveDuration","isSetter","forcedTick","isOdd","iterationElapsedTime","hasRendered","isReversed","_ease","iterationTime","isRunningBackwards","backwards","_iterationTime","began","forcedRender","absoluteTime","_offset","tween","tweenTarget","tweenStyle","tweenTargetTransforms","tweenTargetTransformsProperties","tweenTransformsNeedUpdate","tweenComposition","_composition","tweenCurrentTime","tweenChangeDuration","_changeDuration","tweenAbsEndTime","_absoluteStartTime","tweenNextRep","_nextRep","tweenPrevRep","_prevRep","tweenHasComposition","_isOverridden","_isOverlapped","tweenNewTime","tweenProgress","_updateDuration","tweenModifier","_modifier","tweenValueType","_valueType","tweenType","_tweenType","tweenIsObject","tweenIsNumber","tweenPrecision","value","number","_fromNumber","_toNumber","_unit","fn","_fromNumbers","tn","_toNumbers","r","g","b","ns","_numbers","_strings","j","l","n","s","_number","tweenProperty","property","target","setAttribute","style","setProperty","_value","_renderTransforms","key","transform","_next","paused","_resolve","tick","tl","tlIsRunningBackwards","tlChildrenTime","tlCildrenTickTime","tlChildrenHasRendered","tlChildrenHaveCompleted","tlIterationDuration","childDuration","childStartTime","childEndTime","childTime","childTickMode","additive","animation","update","addAdditiveAnimation","lookups","forEach","propertyAnimation","propertyName","tweens","lookupTween","valueType","additiveValues","additiveValue","_prevAdd","engineTickMethod","requestAnimationFrame","setImmediate","engineCancelMethod","cancelAnimationFrame","clearImmediate","Engine","useDefaultMainLoop","pauseOnDocumentHidden","hidden","reqId","engineSpeed","engineFps","activeTickable","nextTickable","_running","_cancelled","cancel","wake","tickEngine","pause","killEngine","resume","resetTime","timeUnit","unit","secondsScale","isSecond","newScale","scaleFactor","addEventListener","parseInlineTransforms","propName","animationInlineStyles","inlineTransforms","inlinedStylesPropertyValue","cachedTransforms","exec","inlinePropertyName","inlinePropertyValue","slice","getNodeList","querySelectorAll","NodeList","HTMLCollection","parseTargets","targets","flattened","flat","parsed","item","nodeList","jl","subItem","isDuplicate","k","kl","from","registerTargets","parsedTargetsArray","parsedTargetsLength","isSvgType","isDom","nodeType","getPath","path","parsedTargets","$parsedSvg","morphTo","path2","$path1","$path2","isPath","tagName","separator","previousPoints","v1","v2","getAttribute","length1","getTotalLength","length2","maxPoints","pointOnPath1","getPointAtLength","pointOnPath2","prefix","x","y","getScaleFactor","$el","getCTM","ctm","scaleX","scaleY","c","d","createDrawableProxy","pathLength","computedStyles","getComputedStyle","strokeLineCap","strokeLinecap","$scalled","vectorEffect","currentCap","proxy","Proxy","get","values","split","os","d1","d2","newCap","Reflect","apply","createDrawable","selector","els","getPathPoint","$path","lookup","getPathProgess","pathProperty","totalLength","inSvg","to","p0","p1","e","f","createMotionPath","translateX","translateY","rotate","cssReservedProperties","isValidSVGAttribute","el","includes","elParentNode","parentNode","svg","rgbToRgba","rgbValue","rgba","hexToRgba","hexValue","hexLength","isShort","toFixed","hue2rgb","q","hslToRgba","hslValue","hsla","h","convertColorStringValuesToRgbaArray","colorString","setValue","targetValue","defaultValue","getFunctionValue","index","total","store","func","computed","getTweenType","prop","getCSSValue","inlineStyles","getPropertyValue","getOriginalAnimatableValue","type","trimStart","getRelativeValue","operator","createDecomposedValueTargetObject","u","o","decomposeRawValue","rawValue","targetObject","num","unitMatch","matchedNumbers","match","Number","decomposeTweenValue","decomposedOriginalValue","_rep","WeakMap","_add","getTweenSiblings","lookupMap","targetLookup","addTweenSortMethod","overrideTween","composeTween","siblings","tweenCompositionType","tweenAbsStartTime","prevSibling","prevParent","prevAbsEndTime","prevPrevSibling","absoluteUpdateStartTime","prevChangeStartTime","prevTLOffset","pausePrevParentAnimation","prevParentTL","pausePrevParentTL","additiveTweenSiblings","additiveAnimation","_prev","toNumber","toNumbers","removeTweenSliblings","replaceTweensLookup","replaceTargetProps","tweenReplaceSiblings","addTweensLookup","addTargetProps","shouldClean","delete","resetTimerProperties","timer","reviveTimer","timerId","Timer","parameters","parentPosition","register","timerInitTime","timerDefaults","timerDelay","timerDuration","timerLoop","timerLoopDelay","timerIterationCount","offsetPosition","startTime","_autoplay","_reverse","cancelled","reset","play","currentTime","seek","iterationCurrentTime","init","linked","link","restart","isPaused","count","iterations","stretch","newDuration","currentDuration","normlizedDuration","ap","complete","then","onResolve","Promise","createTimer","calcBezier","aT","aA1","aA2","binarySubdivide","aX","mX1","mX2","aA","aB","currentX","currentT","cubicBezier","mY1","mY2","steps","fromStart","roundMethod","linear","argsLength","totalPoints","firstArg","lastArg","xPoints","yPoints","arg","splitValue","trim","percent","easeLinear","prevX","prevY","irregular","randomness","previousValue","spacing","segmentEnd","randomVariation","randomValue","halfPI","doublePI","easeInPower","easeInFunctions","Quad","Cubic","Quart","Quint","Sine","Circ","Expo","Bounce","pow2","Back","overshoot","Elastic","amplitude","period","easeTypes","in","easeIn","out","inOut","outIn","parseEaseString","string","easesFunctions","easesLookups","hasParams","parsedFn","eases","list","name","easeType","JSEasesLookups","parseEasings","propertyNamesCache","sanitizePropertyName","cachedPropertyName","lowerCaseName","angleUnitsMap","convertedValuesCache","convertValueUnit","decomposedValue","force","currentUnit","currentNumber","cachedKey","cached","convertedValue","baseline","tempEl","cloneNode","parentEl","body","appendChild","elStyle","width","currentUnitWidth","offsetWidth","newUnitWidth","factor","cleanInlineStyles","renderable","targetStyle","originalInlinedValue","_inlineStyles","keys","removeProperty","removeAttribute","fromTargetObject","toTargetObject","toFunctionStore","keyframesTargetArray","fastSetValuesArray","keyObjectTarget","tweenId","generateKeyframes","properties","propertyNames","concat","filter","propArray","newKey","keyValue","totalDuration","sort","offset","prevKey","keyObj","durProgress","prevEase","currentEase","undefined","shift","JSAnimation","fastSet","targetsLength","kfParams","params","animDefaults","animaPlaybackEase","animEase","hasSpring","tEasing","tDuration","tDelay","tModifier","tComposition","animInlineStyles","absoluteOffsetTime","NaN","iterationDelay","animationAnimationLength","shouldTriggerRender","targetIndex","ti","lastTransformGroupIndex","lastTransformGroupLength","propValue","isPropValueArray","arrayLength","isNotObjectValue","prevTween","firstTweenChangeStartTime","lastTweenChangeEndTime","tweenIndex","keyframe","computedToValue","tweenToValue","tweenFromValue","keyEasing","tweenEasing","tweenDuration","tweenDelay","computedComposition","hasFromvalue","hasToValue","isFromToArray","isFromToValue","tweenStartTime","absoluteStartTime","nextSibling","complexValue","notComplexValue","unitValue","notUnitValue","colorValue","notColorValue","valueToConvert","longestValue","shortestValue","_","tweenUpdateDuration","_func","_nextAdd","additiveTween","console","warn","refresh","tweenFunc","ogValue","animate","easingToLinear","samples","points","join","WAAPIEasesLookups","WAAPIeases","parseWAAPIEasing","parsedEase","easing","transformsShorthands","commonDefaultPXProperties","validIndividualTransforms","some","axis","endsWith","transformsPropertiesRegistered","WAAPIAnimationsLookups","removeWAAPIAnimation","nextLookup","matchTarget","matchProperty","matchParent","anim","commitStyles","lookupParent","_completed","animations","addWAAPIAnimation","animTotalDuration","controlAnimation","handleRemove","onremove","onfinish","normalizeTweenValue","parseIndividualTweenValue","tweenValue","computedTo","computedFrom","WAAPIAnimation","call","isSkew","isScale","isRotate","isTranslate","isAngle","syntax","registerProperty","inherits","initialValue","spring","scroll","direction","fill","hasIndividualTransforms","composite","tweenParams","propertyValue","individualTransformProperty","parsedPropertyValue","tweenOptions","tweenOptionsEase","tweenOptionsSpring","transforms","cb","waapi","convertEase","sync","getTargetValue","targetSelector","normalizePropName","originalValue","setTargetValues","removeTargetsFromAnimation","targetsArray","tweensMatchesTargets","tweenName","remove","waapiAnimation","removeMatches","childTLOffset","childDur","keepTime","randomPick","roundPad","padStart","padString","padEnd","wrap","mapRange","inLow","inHigh","outLow","outHigh","degToRad","degrees","radToDeg","radians","lerp","amount","dt","ticker","curry","last","chain","result","__","nextArgs","nextResult","utils","makeChainable","right","$","getPrevChildOffset","timeline","timePosition","goToPrevAnimationOffset","prevAnimation","prevOffset","parseTimelinePosition","tlDuration","timePosStr","tlLabels","labels","hasLabels","hasSibling","matchedRelativeOperator","fullOperator","labelOffset","parsedOffset","parsedNumericalOffset","getTimelineTotalDuration","addTlChild","childParams","adjustedPosition","tlChild","Timeline","defaultsParams","globalDefaults","tlPlaybackEase","add","a1","a2","a3","isAnim","isTimer","staggeredPosition","parsedLength","staggeredChildParams","synced","position","effect","getTiming","label","labelName","createTimeline","Animatable","globalParams","paramValue","isObjValue","propParams","animParams","numbers","createAnimatable","Spring","timeStep","restThreshold","restDuration","maxDuration","maxRestSteps","maxIterations","mass","stiffness","damping","velocity","w0","zeta","wd","solverDuration","compute","solve","solverTime","restSteps","createSpring","preventDefault","cancelable","DOMProxy","zIndex","parentElement","classList","height","getBoundingClientRect","top","bottom","left","Transforms","point","DOMPoint","inversedMatrix","getMatrix","inverse","normalizePoint","matrixTransform","traverseUp","matrix","DOMMatrix","transformValue","elMatrix","preMultiplySelf","ct","parseDraggableFunctionParameter","draggable","Draggable","paramX","paramY","trigger","releaseEase","customEase","xProp","mapTo","yProp","container","containerArray","$container","useWin","$scrollContainer","$target","$trigger","fixed","isFinePointer","containerPadding","containerFriction","releaseContainerFriction","snapX","snapY","scrollSpeed","scrollThreshold","dragSpeed","maxVelocity","minVelocity","velocityMultiplier","cursor","releaseXSpring","releaseMass","releaseStiffness","releaseDamping","releaseYSpring","outQuint","hasReleaseSpring","onGrab","onDrag","onRelease","onSettle","onSnap","onResize","onAfterResize","disabled","animatableParams","paramXObject","animatableXParams","paramYObject","animatableYParams","destX","destY","deltaX","deltaY","coords","snapped","pointer","scrollView","dragArea","containerBounds","scrollBounds","targetBounds","velocityStack","velocityStackIndex","velocityTime","angle","cursorStyles","triggerStyles","bodyStyles","targetStyles","touchActionStyles","overshootCoords","overshootXTicker","overshootYTicker","updateTicker","updated","manual","contained","grabbed","dragged","released","canScroll","enabled","initialized","activeProp","hasUpdated","hasMoved","hasReleased","dx","dy","computeVelocity","resizeTicker","resizeObserver","ResizeObserver","enable","observe","prevTime","curTime","elapsed","vMul","minV","maxV","vi","setX","muteUpdateCallback","setY","progressX","progressY","updateScrollCoords","sx","scrollX","scrollLeft","sy","scrollY","scrollTop","cpt","cpr","cpb","cpl","threshold","updateBoundingValues","cx","cy","cx2","cy2","iw","innerWidth","ih","innerHeight","uw","sw","scrollWidth","sh","scrollHeight","fx","transformContainerRect","containerOverflow","visibleOverflow","hiddenOverflow","targetRect","hiddenLeft","hiddenTop","hiddenRight","hiddenBottom","isOutOfBounds","bounds","bt","br","bb","bl","obx","oby","cp","parsedCursorStyles","onHover","matchMedia","matches","daw","dah","csx","csy","nsw","nsh","csw","csh","swd","shd","st","sr","sb","sl","nx","ny","scrollBy","scrollTo","cr","cl","px1","py1","px2","py2","px3","py3","cf","nsx","nsy","stop","scrollInView","gap","inOutQuad","handleHover","animateInView","ob","disabledX","disabledY","dur","handleDown","$eTarget","stopPropagation","touches","changedTouches","eventX","clientX","eventY","clientY","z","handleMove","movedX","movedY","$parent","isAtTop","isAtBottom","canTouchScroll","overflowY","clientHeight","pointerEvents","passive","handleUp","springX","springY","pv","pa","ds","bx","by","durationX","durationY","easeX","easeY","longestReleaseDuration","directionX","distanceX","directionY","distanceY","hasSnapped","removeEventListener","touchAction","disable","disconnect","handleEvent","createDraggable","Scope","rootParam","nativeElement","scopeDefaults","globalDefault","mediaQueries","constructors","revertConstructors","revertibles","constructorsOnce","revertConstructorsOnce","revertiblesOnce","once","onceIndex","methods","mediaQueryLists","data","mq","_mq","revertible","execute","activeScope","activeRoot","activeDefaults","mqs","returned","revertConstructor","addOnce","scopeConstructorCallback","currentIndex","trackedTickable","createScope","getMaxViewHeight","createElement","offsetHeight","parseScrollObserverFunctionParameter","scroller","scrollContainers","ScrollContainer","element","winWidth","winHeight","prevScrollX","prevScrollY","backwardX","backwardY","scrollTicker","dataTimer","handleScroll","self","px","py","updateWindowBounds","refreshScrollObservers","wakeTicker","updateBounds","marginLeft","marginRight","marginTop","marginBottom","elRect","_debug","removeDebug","debug","registerAndGetScrollContainer","scrollContainer","convertValueToPx","size","under","over","clampMin","clampMax","parseBoundValue","matchedOperator","splitter","splitted","valueAPx","valueBPx","getAnimationDomTarget","$linkedTarget","linkedTargets","scrollerIndex","debugColors$1","ScrollObserver","syncMode","isLinear","isEase","isSmooth","isMethods","syncMethods","biDirSync","repeat","horizontal","enter","leave","syncEase","syncSmooth","onSyncEnter","onSyncLeave","onSyncEnterForward","onSyncLeaveForward","onSyncEnterBackward","onSyncLeaveBackward","onEnter","onLeave","onEnterForward","onLeaveForward","onEnterBackward","onLeaveBackward","onSyncComplete","reverted","isInView","forceEnter","hasEntered","offsetStart","offsetEnd","distance","prevProgress","thresholds","debugStyles","$debug","_params","backward","isHori","$existingDebug","querySelector","$thresholds","$triggers","color","containerWidth","containerHeight","offLeft","offTop","half","labelHeight","labelWidth","labelSize","gradientOffset","lineCSS","baseCSS","w","cssText","isView","isTail","isFirst","isOver","isFlip","$label","$text","dirProp","flipOffset","innerHTML","containerPosition","stickys","linkedTime","isSticky","rect","targetSize","containerSize","scrollSize","maxScroll","enterTarget","leaveTarget","enterContainer","leaveContainer","parsedEnterTarget","parsedLeaveTarget","parsedEnterContainer","parsedLeaveContainer","scrollDelta","sticky","shouldSeek","isBefore","isAfter","isOnTheEdge","syncCompleted","lp","step","onScroll","segmenter","Intl","Segmenter","valueRgx","indexRgx","whiteSpaceGroupRgx","whiteSpaceRgx","lineType","wordType","charType","dataLine","wordSegmenter","graphemeSegmenter","$splitTemplate","isSegmentWordLike","seg","isWordLike","segment","setAriaHidden","getAllTopLevelElements","debugColors","line","word","char","filterEmptyElements","childElementCount","textContent","filterLineElements","lineIndex","bin","dataLineAttr","children","generateTemplate","template","classString","class","cloneType","clone","wrapType","overflow","processHTMLTemplate","htmlTemplate","node","$parentFragment","wordIndex","charIndex","isLine","isChar","className","displayStyle","$content","content","$highestParent","firstElementChild","$split","$replacables","replacablesLength","display","$replace","$closestParent","replaceChild","outline","TextSplitter","granularity","text","segments","words","chars","lines","accessible","includeSpaces","lineParams","wordParams","charParams","linesOnly","lineTemplate","wordTemplate","charTemplate","html","effects","effectsCleanups","cache","ready","resizeTimeout","handleSplit","clearTimeout","setTimeout","currentWidth","fonts","addEffect","refreshableEffect","splitNode","nodeText","nodeValue","tempWords","wordSegments","$wordsFragment","createDocumentFragment","prevSeg","wordSegment","lastWordIndex","lastWord","createTextNode","nextWord","hasWordFollowingSpace","wordToProcess","charSegments","$charsFragment","charSegmentsArray","charSegment","isLastChar","charText","$charNode","childNodes","clearCache","isCached","fontsReady","status","canSplitLines","elementsArray","linesCount","nested","linesFragment","parents","Set","clones","$clone","cloneIndex","clonesLength","$word","replaceWith","$accessible","insertBefore","firstChild","stagger","val","hasEasing","staggerEase","grid","customTotal","fromFirst","fromCenter","fromLast","fromRandom","isRange","useProp","use","val1","val2","fromIndex","registeredTarget","customIndex","staggerIndex","fromX","fromY","toX","toY","output"],"sources":["D:/todo-app/frontend/node_modules/animejs/lib/anime.esm.js"],"sourcesContent":["/**\n * anime.js - ESM\n * @version v4.1.2\n * @author Julian Garnier\n * @license MIT\n * @copyright (c) 2025 Julian Garnier\n * @see https://animejs.com\n */\n\n// Global types ///////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Object} DefaultsParams\n * @property {Number|String} [id]\n * @property {PercentageKeyframes|DurationKeyframes} [keyframes]\n * @property {EasingParam} [playbackEase]\n * @property {Number} [playbackRate]\n * @property {Number} [frameRate]\n * @property {Number|Boolean} [loop]\n * @property {Boolean} [reversed]\n * @property {Boolean} [alternate]\n * @property {Boolean|ScrollObserver} [autoplay]\n * @property {Number|FunctionValue} [duration]\n * @property {Number|FunctionValue} [delay]\n * @property {Number} [loopDelay]\n * @property {EasingParam} [ease]\n * @property {'none'|'replace'|'blend'|compositionTypes} [composition]\n * @property {(v: any) => any} [modifier]\n * @property {(tickable: Tickable) => void} [onBegin]\n * @property {(tickable: Tickable) => void} [onBeforeUpdate]\n * @property {(tickable: Tickable) => void} [onUpdate]\n * @property {(tickable: Tickable) => void} [onLoop]\n * @property {(tickable: Tickable) => void} [onPause]\n * @property {(tickable: Tickable) => void} [onComplete]\n * @property {(renderable: Renderable) => void} [onRender]\n */\n\n/** @typedef {JSAnimation|Timeline} Renderable */\n/** @typedef {Timer|Renderable} Tickable */\n/** @typedef {Timer&JSAnimation&Timeline} CallbackArgument */\n/** @typedef {Animatable|Tickable|Draggable|ScrollObserver|TextSplitter|Scope} Revertible */\n\n// Stagger types //////////////////////////////////////////////////////////////\n\n/**\n * @callback StaggerFunction\n * @param {Target} [target]\n * @param {Number} [index]\n * @param {Number} [length]\n * @param {Timeline} [tl]\n * @return {Number|String}\n */\n\n/**\n * @typedef  {Object} StaggerParams\n * @property {Number|String} [start]\n * @property {Number|'first'|'center'|'last'|'random'} [from]\n * @property {Boolean} [reversed]\n * @property {Array.<Number>} [grid]\n * @property {('x'|'y')} [axis]\n * @property {String|StaggerFunction} [use]\n * @property {Number} [total]\n * @property {EasingParam} [ease]\n * @property {TweenModifier} [modifier]\n */\n\n// Eases types ////////////////////////////////////////////////////////////////\n\n/**\n * @callback EasingFunction\n * @param {Number} time\n * @return {Number}\n */\n\n/**\n * @typedef {('linear'|'linear(x1, x2 25%, x3)'|'in'|'out'|'inOut'|'inQuad'|'outQuad'|'inOutQuad'|'inCubic'|'outCubic'|'inOutCubic'|'inQuart'|'outQuart'|'inOutQuart'|'inQuint'|'outQuint'|'inOutQuint'|'inSine'|'outSine'|'inOutSine'|'inCirc'|'outCirc'|'inOutCirc'|'inExpo'|'outExpo'|'inOutExpo'|'inBounce'|'outBounce'|'inOutBounce'|'inBack'|'outBack'|'inOutBack'|'inElastic'|'outElastic'|'inOutElastic'|'irregular'|'cubicBezier'|'steps'|'in(p = 1.675)'|'out(p = 1.675)'|'inOut(p = 1.675)'|'inBack(overshoot = 1.70158)'|'outBack(overshoot = 1.70158)'|'inOutBack(overshoot = 1.70158)'|'inElastic(amplitude = 1, period = .3)'|'outElastic(amplitude = 1, period = .3)'|'inOutElastic(amplitude = 1, period = .3)'|'irregular(length = 10, randomness = 1)'|'cubicBezier(x1, y1, x2, y2)'|'steps(steps = 10)')} EaseStringParamNames\n */\n\n// A hack to get both ease names suggestions AND allow any strings\n// https://github.com/microsoft/TypeScript/issues/29729#issuecomment-460346421\n/** @typedef {(String & {})|EaseStringParamNames|EasingFunction|Spring} EasingParam */\n\n/** @typedef {HTMLElement|SVGElement} DOMTarget */\n/** @typedef {Record<String, any>} JSTarget */\n/** @typedef {DOMTarget|JSTarget} Target */\n/** @typedef {Target|NodeList|String} TargetSelector */\n/** @typedef {DOMTarget|NodeList|String} DOMTargetSelector */\n/** @typedef {Array.<DOMTargetSelector>|DOMTargetSelector} DOMTargetsParam */\n/** @typedef {Array.<DOMTarget>} DOMTargetsArray */\n/** @typedef {Array.<JSTarget>|JSTarget} JSTargetsParam */\n/** @typedef {Array.<JSTarget>} JSTargetsArray */\n/** @typedef {Array.<TargetSelector>|TargetSelector} TargetsParam */\n/** @typedef {Array.<Target>} TargetsArray */\n\n // Callback types ////////////////////////////////////////////////////////////\n\n/**\n * @template T\n * @callback Callback\n * @param {T} self - Returns itself\n * @param {PointerEvent} [e]\n * @return {*}\n */\n\n/**\n * @template {object} T\n * @typedef {Object} TickableCallbacks\n * @property {Callback<T>} [onBegin]\n * @property {Callback<T>} [onBeforeUpdate]\n * @property {Callback<T>} [onUpdate]\n * @property {Callback<T>} [onLoop]\n * @property {Callback<T>} [onPause]\n * @property {Callback<T>} [onComplete]\n */\n\n/**\n * @template {object} T\n * @typedef {Object} RenderableCallbacks\n * @property {Callback<T>} [onRender]\n */\n\n// Timer types ////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Object} TimerOptions\n * @property {Number|String} [id]\n * @property {TweenParamValue} [duration]\n * @property {TweenParamValue} [delay]\n * @property {Number} [loopDelay]\n * @property {Boolean} [reversed]\n * @property {Boolean} [alternate]\n * @property {Boolean|Number} [loop]\n * @property {Boolean|ScrollObserver} [autoplay]\n * @property {Number} [frameRate]\n * @property {Number} [playbackRate]\n */\n\n/**\n\n/**\n * @typedef {TimerOptions & TickableCallbacks<Timer>} TimerParams\n */\n\n// Tween types ////////////////////////////////////////////////////////////////\n\n/**\n * @callback FunctionValue\n * @param {Target} target - The animated target\n * @param {Number} index - The target index\n * @param {Number} length - The total number of animated targets\n * @return {Number|String|TweenObjectValue|Array.<Number|String|TweenObjectValue>}\n */\n\n/**\n * @callback TweenModifier\n * @param {Number} value - The animated value\n * @return {Number|String}\n */\n\n/** @typedef {[Number, Number, Number, Number]} ColorArray */\n\n/**\n * @typedef {Object} Tween\n * @property {Number} id\n * @property {JSAnimation} parent\n * @property {String} property\n * @property {Target} target\n * @property {String|Number} _value\n * @property {Function|null} _func\n * @property {EasingFunction} _ease\n * @property {Array.<Number>} _fromNumbers\n * @property {Array.<Number>} _toNumbers\n * @property {Array.<String>} _strings\n * @property {Number} _fromNumber\n * @property {Number} _toNumber\n * @property {Array.<Number>} _numbers\n * @property {Number} _number\n * @property {String} _unit\n * @property {TweenModifier} _modifier\n * @property {Number} _currentTime\n * @property {Number} _delay\n * @property {Number} _updateDuration\n * @property {Number} _startTime\n * @property {Number} _changeDuration\n * @property {Number} _absoluteStartTime\n * @property {tweenTypes} _tweenType\n * @property {valueTypes} _valueType\n * @property {Number} _composition\n * @property {Number} _isOverlapped\n * @property {Number} _isOverridden\n * @property {Number} _renderTransforms\n * @property {Tween} _prevRep\n * @property {Tween} _nextRep\n * @property {Tween} _prevAdd\n * @property {Tween} _nextAdd\n * @property {Tween} _prev\n * @property {Tween} _next\n */\n\n/**\n * @typedef TweenDecomposedValue\n * @property {Number} t - Type\n * @property {Number} n - Single number value\n * @property {String} u - Value unit\n * @property {String} o - Value operator\n * @property {Array.<Number>} d - Array of Numbers (in case of complex value type)\n * @property {Array.<String>} s - Strings (in case of complex value type)\n */\n\n/** @typedef {{_head: null|Tween, _tail: null|Tween}} TweenPropertySiblings */\n/** @typedef {Record<String, TweenPropertySiblings>} TweenLookups */\n/** @typedef {WeakMap.<Target, TweenLookups>} TweenReplaceLookups */\n/** @typedef {Map.<Target, TweenLookups>} TweenAdditiveLookups */\n\n// Animation types ////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Number|String|FunctionValue} TweenParamValue\n */\n\n/**\n * @typedef {TweenParamValue|[TweenParamValue, TweenParamValue]} TweenPropValue\n */\n\n/**\n * @typedef {(String & {})|'none'|'replace'|'blend'|compositionTypes} TweenComposition\n */\n\n/**\n * @typedef {Object} TweenParamsOptions\n * @property {TweenParamValue} [duration]\n * @property {TweenParamValue} [delay]\n * @property {EasingParam} [ease]\n * @property {TweenModifier} [modifier]\n * @property {TweenComposition} [composition]\n */\n\n/**\n * @typedef {Object} TweenValues\n * @property {TweenParamValue} [from]\n * @property {TweenPropValue} [to]\n * @property {TweenPropValue} [fromTo]\n */\n\n/**\n * @typedef {TweenParamsOptions & TweenValues} TweenKeyValue\n */\n\n/**\n * @typedef {Array.<TweenKeyValue|TweenPropValue>} ArraySyntaxValue\n */\n\n/**\n * @typedef {TweenParamValue|ArraySyntaxValue|TweenKeyValue} TweenOptions\n */\n\n/**\n * @typedef {Partial<{to: TweenParamValue|Array.<TweenParamValue>; from: TweenParamValue|Array.<TweenParamValue>; fromTo: TweenParamValue|Array.<TweenParamValue>;}>} TweenObjectValue\n */\n\n/**\n * @typedef {Object} PercentageKeyframeOptions\n * @property {EasingParam} [ease]\n */\n\n/**\n * @typedef {Record<String, TweenParamValue>} PercentageKeyframeParams\n */\n\n/**\n * @typedef {Record<String, PercentageKeyframeParams & PercentageKeyframeOptions>} PercentageKeyframes\n */\n\n/**\n * @typedef {Array<Record<String, TweenOptions | TweenModifier | boolean> & TweenParamsOptions>} DurationKeyframes\n */\n\n/**\n * @typedef {Object} AnimationOptions\n * @property {PercentageKeyframes|DurationKeyframes} [keyframes]\n * @property {EasingParam} [playbackEase]\n */\n\n// TODO: Currently setting TweenModifier to the intersected Record<> makes the FunctionValue type target param any if only one parameter is set\n/**\n * @typedef {Record<String, TweenOptions | Callback<JSAnimation> | TweenModifier | boolean | PercentageKeyframes | DurationKeyframes | ScrollObserver> & TimerOptions & AnimationOptions & TweenParamsOptions & TickableCallbacks<JSAnimation> & RenderableCallbacks<JSAnimation>} AnimationParams\n */\n\n// Timeline types /////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Object} TimelineOptions\n * @property {DefaultsParams} [defaults]\n * @property {EasingParam} [playbackEase]\n */\n\n/**\n * @typedef {TimerOptions & TimelineOptions & TickableCallbacks<Timeline> & RenderableCallbacks<Timeline>} TimelineParams\n */\n\n// Animatable types ///////////////////////////////////////////////////////////\n\n/**\n * @callback AnimatablePropertySetter\n * @param  {Number|Array.<Number>} to\n * @param  {Number} [duration]\n * @param  {EasingParam} [ease]\n * @return {AnimatableObject}\n */\n\n/**\n * @callback AnimatablePropertyGetter\n * @return {Number|Array.<Number>}\n */\n\n/**\n * @typedef {AnimatablePropertySetter & AnimatablePropertyGetter} AnimatableProperty\n */\n\n/**\n * @typedef {Animatable & Record<String, AnimatableProperty>} AnimatableObject\n */\n\n/**\n * @typedef {Object} AnimatablePropertyParamsOptions\n * @property {String} [unit]\n * @property {TweenParamValue} [duration]\n * @property {EasingParam} [ease]\n * @property {TweenModifier} [modifier]\n * @property {TweenComposition} [composition]\n */\n\n/**\n * @typedef {Record<String, TweenParamValue | EasingParam | TweenModifier | TweenComposition | AnimatablePropertyParamsOptions> & AnimatablePropertyParamsOptions} AnimatableParams\n */\n\n// Scope types ////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Object} ReactRef\n * @property {HTMLElement|SVGElement|null} [current]\n */\n\n/**\n * @typedef {Object} AngularRef\n * @property {HTMLElement|SVGElement} [nativeElement]\n */\n\n/**\n * @typedef {Object} ScopeParams\n * @property {DOMTargetSelector|ReactRef|AngularRef} [root]\n * @property {DefaultsParams} [defaults]\n * @property {Record<String, String>} [mediaQueries]\n */\n\n/**\n * @template T\n * @callback ScopedCallback\n * @param {Scope} scope\n * @return {T}\n */\n\n/**\n * @callback ScopeCleanupCallback\n * @param {Scope} [scope]\n */\n\n/**\n * @callback ScopeConstructorCallback\n * @param {Scope} [scope]\n * @return {ScopeCleanupCallback|void}\n */\n\n/**\n * @callback ScopeMethod\n * @param {...*} args\n * @return {ScopeCleanupCallback|void}\n */\n\n// Draggable types ////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Object} DraggableAxisParam\n * @property {String} [mapTo]\n * @property {TweenModifier} [modifier]\n * @property {TweenComposition} [composition]\n * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [snap]\n */\n\n/**\n * @typedef {Object} DraggableCursorParams\n * @property {String} [onHover]\n * @property {String} [onGrab]\n */\n\n/**\n * @typedef {Object} DraggableParams\n * @property {DOMTargetSelector} [trigger]\n * @property {DOMTargetSelector|Array<Number>|((draggable: Draggable) => DOMTargetSelector|Array<Number>)} [container]\n * @property {Boolean|DraggableAxisParam} [x]\n * @property {Boolean|DraggableAxisParam} [y]\n * @property {TweenModifier} [modifier]\n * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [snap]\n * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [containerPadding]\n * @property {Number|((draggable: Draggable) => Number)} [containerFriction]\n * @property {Number|((draggable: Draggable) => Number)} [releaseContainerFriction]\n * @property {Number|((draggable: Draggable) => Number)} [dragSpeed]\n * @property {Number|((draggable: Draggable) => Number)} [scrollSpeed]\n * @property {Number|((draggable: Draggable) => Number)} [scrollThreshold]\n * @property {Number|((draggable: Draggable) => Number)} [minVelocity]\n * @property {Number|((draggable: Draggable) => Number)} [maxVelocity]\n * @property {Number|((draggable: Draggable) => Number)} [velocityMultiplier]\n * @property {Number} [releaseMass]\n * @property {Number} [releaseStiffness]\n * @property {Number} [releaseDamping]\n * @property {Boolean} [releaseDamping]\n * @property {EasingParam} [releaseEase]\n * @property {Boolean|DraggableCursorParams|((draggable: Draggable) => Boolean|DraggableCursorParams)} [cursor]\n * @property {Callback<Draggable>} [onGrab]\n * @property {Callback<Draggable>} [onDrag]\n * @property {Callback<Draggable>} [onRelease]\n * @property {Callback<Draggable>} [onUpdate]\n * @property {Callback<Draggable>} [onSettle]\n * @property {Callback<Draggable>} [onSnap]\n * @property {Callback<Draggable>} [onResize]\n * @property {Callback<Draggable>} [onAfterResize]\n */\n\n// Text types /////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Object} splitTemplateParams\n * @property {false|String} [class]\n * @property {Boolean|'hidden'|'clip'|'visible'|'scroll'|'auto'} [wrap]\n * @property {Boolean|'top'|'right'|'bottom'|'left'|'center'} [clone]\n */\n\n/**\n * @typedef {Boolean|String} SplitValue\n */\n\n/**\n * @callback SplitFunctionValue\n * @param {Node|HTMLElement} [value]\n * @return String\n */\n\n/**\n * @typedef {Object} TextSplitterParams\n * @property {SplitValue|splitTemplateParams|SplitFunctionValue} [lines]\n * @property {SplitValue|splitTemplateParams|SplitFunctionValue} [words]\n * @property {SplitValue|splitTemplateParams|SplitFunctionValue} [chars]\n * @property {Boolean} [accessible]\n * @property {Boolean} [includeSpaces]\n * @property {Boolean} [debug]\n */\n\n// SVG types //////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {SVGGeometryElement & {\n *   setAttribute(name: 'draw', value: `${number} ${number}`): void;\n *   draw: `${number} ${number}`;\n * }} DrawableSVGGeometry\n */\n\n\n// Environments\n\n// TODO: Do we need to check if we're running inside a worker ?\nconst isBrowser = typeof window !== 'undefined';\n\n/** @type {Window & {AnimeJS: Array}|null} */\nconst win = isBrowser ? /** @type {Window & {AnimeJS: Array}} */(/** @type {unknown} */(window)) : null;\n\n/** @type {Document|null} */\nconst doc = isBrowser ? document : null;\n\n// Enums\n\n/** @enum {Number} */\nconst tweenTypes = {\n  OBJECT: 0,\n  ATTRIBUTE: 1,\n  CSS: 2,\n  TRANSFORM: 3,\n  CSS_VAR: 4,\n};\n\n/** @enum {Number} */\nconst valueTypes = {\n  NUMBER: 0,\n  UNIT: 1,\n  COLOR: 2,\n  COMPLEX: 3,\n};\n\n/** @enum {Number} */\nconst tickModes = {\n  NONE: 0,\n  AUTO: 1,\n  FORCE: 2,\n};\n\n/** @enum {Number} */\nconst compositionTypes = {\n  replace: 0,\n  none: 1,\n  blend: 2,\n};\n\n// Cache symbols\n\nconst isRegisteredTargetSymbol = Symbol();\nconst isDomSymbol = Symbol();\nconst isSvgSymbol = Symbol();\nconst transformsSymbol = Symbol();\nconst morphPointsSymbol = Symbol();\nconst proxyTargetSymbol = Symbol();\n\n// Numbers\n\nconst minValue = 1e-11;\nconst maxValue = 1e12;\nconst K = 1e3;\nconst maxFps = 120;\n\n// Strings\n\nconst emptyString = '';\nconst shortTransforms = /*#__PURE__*/ (() => {\n  const map = new Map();\n  map.set('x', 'translateX');\n  map.set('y', 'translateY');\n  map.set('z', 'translateZ');\n  return map;\n})();\n\nconst validTransforms = [\n  'translateX',\n  'translateY',\n  'translateZ',\n  'rotate',\n  'rotateX',\n  'rotateY',\n  'rotateZ',\n  'scale',\n  'scaleX',\n  'scaleY',\n  'scaleZ',\n  'skew',\n  'skewX',\n  'skewY',\n  'perspective',\n  'matrix',\n  'matrix3d',\n];\n\nconst transformsFragmentStrings = /*#__PURE__*/ validTransforms.reduce((a, v) => ({...a, [v]: v + '('}), {});\n\n// Functions\n\n/** @return {void} */\nconst noop = () => {};\n\n// Regex\n\nconst hexTestRgx = /(^#([\\da-f]{3}){1,2}$)|(^#([\\da-f]{4}){1,2}$)/i;\nconst rgbExecRgx = /rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/i;\nconst rgbaExecRgx = /rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(-?\\d+|-?\\d*.\\d+)\\s*\\)/i;\nconst hslExecRgx = /hsl\\(\\s*(-?\\d+|-?\\d*.\\d+)\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*\\)/i;\nconst hslaExecRgx = /hsla\\(\\s*(-?\\d+|-?\\d*.\\d+)\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*,\\s*(-?\\d+|-?\\d*.\\d+)\\s*\\)/i;\n// export const digitWithExponentRgx = /[-+]?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?/g;\nconst digitWithExponentRgx = /[-+]?\\d*\\.?\\d+(?:e[-+]?\\d)?/gi;\n// export const unitsExecRgx = /^([-+]?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?)+([a-z]+|%)$/i;\nconst unitsExecRgx = /^([-+]?\\d*\\.?\\d+(?:e[-+]?\\d+)?)([a-z]+|%)$/i;\nconst lowerCaseRgx = /([a-z])([A-Z])/g;\nconst transformsExecRgx = /(\\w+)(\\([^)]+\\)+)/g; // Match inline transforms with cacl() values, returns the value wrapped in ()\nconst relativeValuesExecRgx = /(\\*=|\\+=|-=)/;\n\n\n\n\n/** @type {DefaultsParams} */\nconst defaults = {\n  id: null,\n  keyframes: null,\n  playbackEase: null,\n  playbackRate: 1,\n  frameRate: maxFps,\n  loop: 0,\n  reversed: false,\n  alternate: false,\n  autoplay: true,\n  duration: K,\n  delay: 0,\n  loopDelay: 0,\n  ease: 'out(2)',\n  composition: compositionTypes.replace,\n  modifier: v => v,\n  onBegin: noop,\n  onBeforeUpdate: noop,\n  onUpdate: noop,\n  onLoop: noop,\n  onPause: noop,\n  onComplete: noop,\n  onRender: noop,\n};\n\nconst scope = {\n  /** @type {Scope} */\n  current: null,\n  /** @type {Document|DOMTarget} */\n  root: doc,\n};\n\nconst globals = {\n  /** @type {DefaultsParams} */\n  defaults,\n  /** @type {Number} */\n  precision: 4,\n  /** @type {Number} */\n  timeScale: 1,\n  /** @type {Number} */\n  tickThreshold: 200,\n};\n\nconst globalVersions = { version: '4.1.2', engine: null };\n\nif (isBrowser) {\n  if (!win.AnimeJS) win.AnimeJS = [];\n  win.AnimeJS.push(globalVersions);\n}\n\n// Strings\n\n/**\n * @param  {String} str\n * @return {String}\n */\nconst toLowerCase = str => str.replace(lowerCaseRgx, '$1-$2').toLowerCase();\n\n/**\n * Prioritize this method instead of regex when possible\n * @param  {String} str\n * @param  {String} sub\n * @return {Boolean}\n */\nconst stringStartsWith = (str, sub) => str.indexOf(sub) === 0;\n\n// Time\n// Note: Date.now is used instead of performance.now since it is precise enough for timings calculations, performs slightly faster and works in Node.js environement.\nconst now = Date.now;\n\n// Types checkers\n\nconst isArr = Array.isArray;\n/**@param {any} a @return {a is Record<String, any>} */\nconst isObj = a => a && a.constructor === Object;\n/**@param {any} a @return {a is Number} */\nconst isNum = a => typeof a === 'number' && !isNaN(a);\n/**@param {any} a @return {a is String} */\nconst isStr = a => typeof a === 'string';\n/**@param {any} a @return {a is Function} */\nconst isFnc = a => typeof a === 'function';\n/**@param {any} a @return {a is undefined} */\nconst isUnd = a => typeof a === 'undefined';\n/**@param {any} a @return {a is null | undefined} */\nconst isNil = a => isUnd(a) || a === null;\n/**@param {any} a @return {a is SVGElement} */\nconst isSvg = a => isBrowser && a instanceof SVGElement;\n/**@param {any} a @return {Boolean} */\nconst isHex = a => hexTestRgx.test(a);\n/**@param {any} a @return {Boolean} */\nconst isRgb = a => stringStartsWith(a, 'rgb');\n/**@param {any} a @return {Boolean} */\nconst isHsl = a => stringStartsWith(a, 'hsl');\n/**@param {any} a @return {Boolean} */\nconst isCol = a => isHex(a) || isRgb(a) || isHsl(a);\n/**@param {any} a @return {Boolean} */\nconst isKey = a => !globals.defaults.hasOwnProperty(a);\n\n// Number\n\n/**\n * @param  {Number|String} str\n * @return {Number}\n */\nconst parseNumber = str => isStr(str) ?\n  parseFloat(/** @type {String} */(str)) :\n  /** @type {Number} */(str);\n\n// Math\n\nconst pow = Math.pow;\nconst sqrt = Math.sqrt;\nconst sin = Math.sin;\nconst cos = Math.cos;\nconst abs = Math.abs;\nconst exp = Math.exp;\nconst ceil = Math.ceil;\nconst floor = Math.floor;\nconst asin = Math.asin;\nconst max = Math.max;\nconst atan2 = Math.atan2;\nconst PI = Math.PI;\nconst _round = Math.round;\n\n/**\n * @param  {Number} v\n * @param  {Number} min\n * @param  {Number} max\n * @return {Number}\n */\nconst clamp = (v, min, max) => v < min ? min : v > max ? max : v;\n\nconst powCache = {};\n\n/**\n * @param  {Number} v\n * @param  {Number} decimalLength\n * @return {Number}\n */\nconst round = (v, decimalLength) => {\n  if (decimalLength < 0) return v;\n  if (!decimalLength) return _round(v);\n  let p = powCache[decimalLength];\n  if (!p) p = powCache[decimalLength] = 10 ** decimalLength;\n  return _round(v * p) / p;\n};\n\n/**\n * @param  {Number} v\n * @param  {Number|Array<Number>} increment\n * @return {Number}\n */\nconst snap = (v, increment) => isArr(increment) ? increment.reduce((closest, cv) => (abs(cv - v) < abs(closest - v) ? cv : closest)) : increment ? _round(v / increment) * increment : v;\n\n/**\n * @param  {Number} start\n * @param  {Number} end\n * @param  {Number} progress\n * @return {Number}\n */\nconst interpolate = (start, end, progress) => start + (end - start) * progress;\n\n/**\n * @param  {Number} min\n * @param  {Number} max\n * @param  {Number} [decimalLength]\n * @return {Number}\n */\nconst random = (min, max, decimalLength) => { const m = 10 ** (decimalLength || 0); return floor((Math.random() * (max - min + (1 / m)) + min) * m) / m };\n\n/**\n * Adapted from https://bost.ocks.org/mike/shuffle/\n * @param  {Array} items\n * @return {Array}\n */\nconst shuffle = items => {\n  let m = items.length, t, i;\n  while (m) { i = random(0, --m); t = items[m]; items[m] = items[i]; items[i] = t; }\n  return items;\n};\n\n/**\n * @param  {Number} v\n * @return {Number}\n */\nconst clampInfinity = v => v === Infinity ? maxValue : v === -Infinity ? -1e12 : v;\n\n/**\n * @param  {Number} v\n * @return {Number}\n */\nconst normalizeTime = v => v <= minValue ? minValue : clampInfinity(round(v, 11));\n\n// Arrays\n\n/**\n * @template T\n * @param {T[]} a\n * @return {T[]}\n */\nconst cloneArray = a => isArr(a) ? [ ...a ] : a;\n\n// Objects\n\n/**\n * @template T\n * @template U\n * @param {T} o1\n * @param {U} o2\n * @return {T & U}\n */\nconst mergeObjects = (o1, o2) => {\n  const merged = /** @type {T & U} */({ ...o1 });\n  for (let p in o2) {\n    const o1p = /** @type {T & U} */(o1)[p];\n    merged[p] = isUnd(o1p) ? /** @type {T & U} */(o2)[p] : o1p;\n  }  return merged;\n};\n\n// Linked lists\n\n/**\n * @param {Object} parent\n * @param {Function} callback\n * @param {Boolean} [reverse]\n * @param {String} [prevProp]\n * @param {String} [nextProp]\n * @return {void}\n */\nconst forEachChildren = (parent, callback, reverse, prevProp = '_prev', nextProp = '_next') => {\n  let next = parent._head;\n  let adjustedNextProp = nextProp;\n  if (reverse) {\n    next = parent._tail;\n    adjustedNextProp = prevProp;\n  }\n  while (next) {\n    const currentNext = next[adjustedNextProp];\n    callback(next);\n    next = currentNext;\n  }\n};\n\n/**\n * @param  {Object} parent\n * @param  {Object} child\n * @param  {String} [prevProp]\n * @param  {String} [nextProp]\n * @return {void}\n */\nconst removeChild = (parent, child, prevProp = '_prev', nextProp = '_next') => {\n  const prev = child[prevProp];\n  const next = child[nextProp];\n  prev ? prev[nextProp] = next : parent._head = next;\n  next ? next[prevProp] = prev : parent._tail = prev;\n  child[prevProp] = null;\n  child[nextProp] = null;\n};\n\n/**\n * @param  {Object} parent\n * @param  {Object} child\n * @param  {Function} [sortMethod]\n * @param  {String} prevProp\n * @param  {String} nextProp\n * @return {void}\n */\nconst addChild = (parent, child, sortMethod, prevProp = '_prev', nextProp = '_next') => {\n  let prev = parent._tail;\n  while (prev && sortMethod && sortMethod(prev, child)) prev = prev[prevProp];\n  const next = prev ? prev[nextProp] : parent._head;\n  prev ? prev[nextProp] = child : parent._head = child;\n  next ? next[prevProp] = child : parent._tail = child;\n  child[prevProp] = prev;\n  child[nextProp] = next;\n};\n\n/**\n * @param  {(...args: any[]) => Tickable | ((...args: any[]) => void)} constructor\n * @return {(...args: any[]) => Tickable | ((...args: any[]) => void)}\n */\nconst createRefreshable = constructor => {\n  /** @type {Tickable} */\n  let tracked;\n  return (...args) => {\n    let currentIteration, currentIterationProgress, reversed, alternate;\n    if (tracked) {\n      currentIteration = tracked.currentIteration;\n      currentIterationProgress = tracked.iterationProgress;\n      reversed = tracked.reversed;\n      alternate = tracked._alternate;\n      tracked.revert();\n    }\n    const cleanup = constructor(...args);\n    if (cleanup && !isFnc(cleanup) && cleanup.revert) tracked = cleanup;\n    if (!isUnd(currentIterationProgress)) {\n      /** @type {Tickable} */(tracked).currentIteration = currentIteration;\n      /** @type {Tickable} */(tracked).iterationProgress = (alternate ? !(currentIteration % 2) ? reversed : !reversed : reversed) ? 1 - currentIterationProgress : currentIterationProgress;\n    }\n    return cleanup || noop;\n  }\n};\n\n/*\n * Base class to control framerate and playback rate.\n * Inherited by Engine, Timer, Animation and Timeline.\n */\nclass Clock {\n\n  /** @param {Number} [initTime] */\n  constructor(initTime = 0) {\n    /** @type {Number} */\n    this.deltaTime = 0;\n    /** @type {Number} */\n    this._currentTime = initTime;\n    /** @type {Number} */\n    this._elapsedTime = initTime;\n    /** @type {Number} */\n    this._startTime = initTime;\n    /** @type {Number} */\n    this._lastTime = initTime;\n    /** @type {Number} */\n    this._scheduledTime = 0;\n    /** @type {Number} */\n    this._frameDuration = round(K / maxFps, 0);\n    /** @type {Number} */\n    this._fps = maxFps;\n    /** @type {Number} */\n    this._speed = 1;\n    /** @type {Boolean} */\n    this._hasChildren = false;\n    /** @type {Tickable|Tween} */\n    this._head = null;\n    /** @type {Tickable|Tween} */\n    this._tail = null;\n  }\n\n  get fps() {\n    return this._fps;\n  }\n\n  set fps(frameRate) {\n    const previousFrameDuration = this._frameDuration;\n    const fr = +frameRate;\n    const fps = fr < minValue ? minValue : fr;\n    const frameDuration = round(K / fps, 0);\n    this._fps = fps;\n    this._frameDuration = frameDuration;\n    this._scheduledTime += frameDuration - previousFrameDuration;\n  }\n\n  get speed() {\n    return this._speed;\n  }\n\n  set speed(playbackRate) {\n    const pbr = +playbackRate;\n    this._speed = pbr < minValue ? minValue : pbr;\n  }\n\n  /**\n   * @param  {Number} time\n   * @return {tickModes}\n   */\n  requestTick(time) {\n    const scheduledTime = this._scheduledTime;\n    const elapsedTime = this._elapsedTime;\n    this._elapsedTime += (time - elapsedTime);\n    // If the elapsed time is lower than the scheduled time\n    // this means not enough time has passed to hit one frameDuration\n    // so skip that frame\n    if (elapsedTime < scheduledTime) return tickModes.NONE;\n    const frameDuration = this._frameDuration;\n    const frameDelta = elapsedTime - scheduledTime;\n    // Ensures that _scheduledTime progresses in steps of at least 1 frameDuration.\n    // Skips ahead if the actual elapsed time is higher.\n    this._scheduledTime += frameDelta < frameDuration ? frameDuration : frameDelta;\n    return tickModes.AUTO;\n  }\n\n  /**\n   * @param  {Number} time\n   * @return {Number}\n   */\n  computeDeltaTime(time) {\n    const delta = time - this._lastTime;\n    this.deltaTime = delta;\n    this._lastTime = time;\n    return delta;\n  }\n\n}\n\n\n\n\n/**\n * @param  {Tickable} tickable\n * @param  {Number} time\n * @param  {Number} muteCallbacks\n * @param  {Number} internalRender\n * @param  {tickModes} tickMode\n * @return {Number}\n */\nconst render = (tickable, time, muteCallbacks, internalRender, tickMode) => {\n\n  const parent = tickable.parent;\n  const duration = tickable.duration;\n  const completed = tickable.completed;\n  const iterationDuration = tickable.iterationDuration;\n  const iterationCount = tickable.iterationCount;\n  const _currentIteration = tickable._currentIteration;\n  const _loopDelay = tickable._loopDelay;\n  const _reversed = tickable._reversed;\n  const _alternate = tickable._alternate;\n  const _hasChildren = tickable._hasChildren;\n  const tickableDelay = tickable._delay;\n  const tickablePrevAbsoluteTime = tickable._currentTime; // TODO: rename ._currentTime to ._absoluteCurrentTime\n\n  const tickableEndTime = tickableDelay + iterationDuration;\n  const tickableAbsoluteTime = time - tickableDelay;\n  const tickablePrevTime = clamp(tickablePrevAbsoluteTime, -tickableDelay, duration);\n  const tickableCurrentTime = clamp(tickableAbsoluteTime, -tickableDelay, duration);\n  const deltaTime = tickableAbsoluteTime - tickablePrevAbsoluteTime;\n  const isCurrentTimeAboveZero = tickableCurrentTime > 0;\n  const isCurrentTimeEqualOrAboveDuration = tickableCurrentTime >= duration;\n  const isSetter = duration <= minValue;\n  const forcedTick = tickMode === tickModes.FORCE;\n\n  let isOdd = 0;\n  let iterationElapsedTime = tickableAbsoluteTime;\n  // Render checks\n  // Used to also check if the children have rendered in order to trigger the onRender callback on the parent timer\n  let hasRendered = 0;\n\n  // Execute the \"expensive\" iterations calculations only when necessary\n  if (iterationCount > 1) {\n    // bitwise NOT operator seems to be generally faster than Math.floor() across browsers\n    const currentIteration = ~~(tickableCurrentTime / (iterationDuration + (isCurrentTimeEqualOrAboveDuration ? 0 : _loopDelay)));\n    tickable._currentIteration = clamp(currentIteration, 0, iterationCount);\n    // Prevent the iteration count to go above the max iterations when reaching the end of the animation\n    if (isCurrentTimeEqualOrAboveDuration) tickable._currentIteration--;\n    isOdd = tickable._currentIteration % 2;\n    iterationElapsedTime = tickableCurrentTime % (iterationDuration + _loopDelay) || 0;\n  }\n\n  // Checks if exactly one of _reversed and (_alternate && isOdd) is true\n  const isReversed = _reversed ^ (_alternate && isOdd);\n  const _ease = /** @type {Renderable} */(tickable)._ease;\n  let iterationTime = isCurrentTimeEqualOrAboveDuration ? isReversed ? 0 : duration : isReversed ? iterationDuration - iterationElapsedTime : iterationElapsedTime;\n  if (_ease) iterationTime = iterationDuration * _ease(iterationTime / iterationDuration) || 0;\n  const isRunningBackwards = (parent ? parent.backwards : tickableAbsoluteTime < tickablePrevAbsoluteTime) ? !isReversed : !!isReversed;\n\n  tickable._currentTime = tickableAbsoluteTime;\n  tickable._iterationTime = iterationTime;\n  tickable.backwards = isRunningBackwards;\n\n  if (isCurrentTimeAboveZero && !tickable.began) {\n    tickable.began = true;\n    if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {\n      tickable.onBegin(/** @type {CallbackArgument} */(tickable));\n    }\n  } else if (tickableAbsoluteTime <= 0) {\n    tickable.began = false;\n  }\n\n  // Only triggers onLoop for tickable without children, otherwise call the the onLoop callback in the tick function\n  // Make sure to trigger the onLoop before rendering to allow .refresh() to pickup the current values\n  if (!muteCallbacks && !_hasChildren && isCurrentTimeAboveZero && tickable._currentIteration !== _currentIteration) {\n    tickable.onLoop(/** @type {CallbackArgument} */(tickable));\n  }\n\n  if (\n    forcedTick ||\n    tickMode === tickModes.AUTO && (\n      time >= tickableDelay && time <= tickableEndTime || // Normal render\n      time <= tickableDelay && tickablePrevTime > tickableDelay || // Playhead is before the animation start time so make sure the animation is at its initial state\n      time >= tickableEndTime && tickablePrevTime !== duration // Playhead is after the animation end time so make sure the animation is at its end state\n    ) ||\n    iterationTime >= tickableEndTime && tickablePrevTime !== duration ||\n    iterationTime <= tickableDelay && tickablePrevTime > 0 ||\n    time <= tickablePrevTime && tickablePrevTime === duration && completed || // Force a render if a seek occurs on an completed animation\n    isCurrentTimeEqualOrAboveDuration && !completed && isSetter // This prevents 0 duration tickables to be skipped\n  ) {\n\n    if (isCurrentTimeAboveZero) {\n      // Trigger onUpdate callback before rendering\n      tickable.computeDeltaTime(tickablePrevTime);\n      if (!muteCallbacks) tickable.onBeforeUpdate(/** @type {CallbackArgument} */(tickable));\n    }\n\n    // Start tweens rendering\n    if (!_hasChildren) {\n\n      // Time has jumped more than globals.tickThreshold so consider this tick manual\n      const forcedRender = forcedTick || (isRunningBackwards ? deltaTime * -1 : deltaTime) >= globals.tickThreshold;\n      const absoluteTime = tickable._offset + (parent ? parent._offset : 0) + tickableDelay + iterationTime;\n\n      // Only Animation can have tweens, Timer returns undefined\n      let tween = /** @type {Tween} */(/** @type {JSAnimation} */(tickable)._head);\n      let tweenTarget;\n      let tweenStyle;\n      let tweenTargetTransforms;\n      let tweenTargetTransformsProperties;\n      let tweenTransformsNeedUpdate = 0;\n\n      while (tween) {\n\n        const tweenComposition = tween._composition;\n        const tweenCurrentTime = tween._currentTime;\n        const tweenChangeDuration = tween._changeDuration;\n        const tweenAbsEndTime = tween._absoluteStartTime + tween._changeDuration;\n        const tweenNextRep = tween._nextRep;\n        const tweenPrevRep = tween._prevRep;\n        const tweenHasComposition = tweenComposition !== compositionTypes.none;\n\n        if ((forcedRender || (\n            (tweenCurrentTime !== tweenChangeDuration || absoluteTime <= tweenAbsEndTime + (tweenNextRep ? tweenNextRep._delay : 0)) &&\n            (tweenCurrentTime !== 0 || absoluteTime >= tween._absoluteStartTime)\n          )) && (!tweenHasComposition || (\n            !tween._isOverridden &&\n            (!tween._isOverlapped || absoluteTime <= tweenAbsEndTime) &&\n            (!tweenNextRep || (tweenNextRep._isOverridden || absoluteTime <= tweenNextRep._absoluteStartTime)) &&\n            (!tweenPrevRep || (tweenPrevRep._isOverridden || (absoluteTime >= (tweenPrevRep._absoluteStartTime + tweenPrevRep._changeDuration) + tween._delay)))\n          ))\n        ) {\n\n          const tweenNewTime = tween._currentTime = clamp(iterationTime - tween._startTime, 0, tweenChangeDuration);\n          const tweenProgress = tween._ease(tweenNewTime / tween._updateDuration);\n          const tweenModifier = tween._modifier;\n          const tweenValueType = tween._valueType;\n          const tweenType = tween._tweenType;\n          const tweenIsObject = tweenType === tweenTypes.OBJECT;\n          const tweenIsNumber = tweenValueType === valueTypes.NUMBER;\n          // Only round the in-between frames values if the final value is a string\n          const tweenPrecision = (tweenIsNumber && tweenIsObject) || tweenProgress === 0 || tweenProgress === 1 ? -1 : globals.precision;\n\n          // Recompose tween value\n          /** @type {String|Number} */\n          let value;\n          /** @type {Number} */\n          let number;\n\n          if (tweenIsNumber) {\n            value = number = /** @type {Number} */(tweenModifier(round(interpolate(tween._fromNumber, tween._toNumber,  tweenProgress), tweenPrecision )));\n          } else if (tweenValueType === valueTypes.UNIT) {\n            // Rounding the values speed up string composition\n            number = /** @type {Number} */(tweenModifier(round(interpolate(tween._fromNumber, tween._toNumber,  tweenProgress), tweenPrecision)));\n            value = `${number}${tween._unit}`;\n          } else if (tweenValueType === valueTypes.COLOR) {\n            const fn = tween._fromNumbers;\n            const tn = tween._toNumbers;\n            const r = round(clamp(/** @type {Number} */(tweenModifier(interpolate(fn[0], tn[0], tweenProgress))), 0, 255), 0);\n            const g = round(clamp(/** @type {Number} */(tweenModifier(interpolate(fn[1], tn[1], tweenProgress))), 0, 255), 0);\n            const b = round(clamp(/** @type {Number} */(tweenModifier(interpolate(fn[2], tn[2], tweenProgress))), 0, 255), 0);\n            const a = clamp(/** @type {Number} */(tweenModifier(round(interpolate(fn[3], tn[3], tweenProgress), tweenPrecision))), 0, 1);\n            value = `rgba(${r},${g},${b},${a})`;\n            if (tweenHasComposition) {\n              const ns = tween._numbers;\n              ns[0] = r;\n              ns[1] = g;\n              ns[2] = b;\n              ns[3] = a;\n            }\n          } else if (tweenValueType === valueTypes.COMPLEX) {\n            value = tween._strings[0];\n            for (let j = 0, l = tween._toNumbers.length; j < l; j++) {\n              const n = /** @type {Number} */(tweenModifier(round(interpolate(tween._fromNumbers[j], tween._toNumbers[j], tweenProgress), tweenPrecision)));\n              const s = tween._strings[j + 1];\n              value += `${s ? n + s : n}`;\n              if (tweenHasComposition) {\n                tween._numbers[j] = n;\n              }\n            }\n          }\n\n          // For additive tweens and Animatables\n          if (tweenHasComposition) {\n            tween._number = number;\n          }\n\n          if (!internalRender && tweenComposition !== compositionTypes.blend) {\n\n            const tweenProperty = tween.property;\n            tweenTarget = tween.target;\n\n            if (tweenIsObject) {\n              tweenTarget[tweenProperty] = value;\n            } else if (tweenType === tweenTypes.ATTRIBUTE) {\n              /** @type {DOMTarget} */(tweenTarget).setAttribute(tweenProperty, /** @type {String} */(value));\n            } else {\n              tweenStyle = /** @type {DOMTarget} */(tweenTarget).style;\n              if (tweenType === tweenTypes.TRANSFORM) {\n                if (tweenTarget !== tweenTargetTransforms) {\n                  tweenTargetTransforms = tweenTarget;\n                  // NOTE: Referencing the cachedTransforms in the tween property directly can be a little bit faster but appears to increase memory usage.\n                  tweenTargetTransformsProperties = tweenTarget[transformsSymbol];\n                }\n                tweenTargetTransformsProperties[tweenProperty] = value;\n                tweenTransformsNeedUpdate = 1;\n              } else if (tweenType === tweenTypes.CSS) {\n                tweenStyle[tweenProperty] = value;\n              } else if (tweenType === tweenTypes.CSS_VAR) {\n                tweenStyle.setProperty(tweenProperty,/** @type {String} */(value));\n              }\n            }\n\n            if (isCurrentTimeAboveZero) hasRendered = 1;\n\n          } else {\n            // Used for composing timeline tweens without having to do a real render\n            tween._value = value;\n          }\n\n        }\n\n        // NOTE: Possible improvement: Use translate(x,y) / translate3d(x,y,z) syntax\n        // to reduce memory usage on string composition\n        if (tweenTransformsNeedUpdate && tween._renderTransforms) {\n          let str = emptyString;\n          for (let key in tweenTargetTransformsProperties) {\n            str += `${transformsFragmentStrings[key]}${tweenTargetTransformsProperties[key]}) `;\n          }\n          tweenStyle.transform = str;\n          tweenTransformsNeedUpdate = 0;\n        }\n\n        tween = tween._next;\n      }\n\n      if (!muteCallbacks && hasRendered) {\n        /** @type {JSAnimation} */(tickable).onRender(/** @type {JSAnimation} */(tickable));\n      }\n    }\n\n    if (!muteCallbacks && isCurrentTimeAboveZero) {\n      tickable.onUpdate(/** @type {CallbackArgument} */(tickable));\n    }\n\n  }\n\n  // End tweens rendering\n\n  // Handle setters on timeline differently and allow re-trigering the onComplete callback when seeking backwards\n  if (parent && isSetter) {\n    if (!muteCallbacks && (\n      (parent.began && !isRunningBackwards && tickableAbsoluteTime >= duration && !completed) ||\n      (isRunningBackwards && tickableAbsoluteTime <= minValue && completed)\n    )) {\n      tickable.onComplete(/** @type {CallbackArgument} */(tickable));\n      tickable.completed = !isRunningBackwards;\n    }\n  // If currentTime is both above 0 and at least equals to duration, handles normal onComplete or infinite loops\n  } else if (isCurrentTimeAboveZero && isCurrentTimeEqualOrAboveDuration) {\n    if (iterationCount === Infinity) {\n      // Offset the tickable _startTime with its duration to reset _currentTime to 0 and continue the infinite timer\n      tickable._startTime += tickable.duration;\n    } else if (tickable._currentIteration >= iterationCount - 1) {\n      // By setting paused to true, we tell the engine loop to not render this tickable and removes it from the list on the next tick\n      tickable.paused = true;\n      if (!completed && !_hasChildren) {\n        // If the tickable has children, triggers onComplete() only when all children have completed in the tick function\n        tickable.completed = true;\n        if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {\n          tickable.onComplete(/** @type {CallbackArgument} */(tickable));\n          tickable._resolve(/** @type {CallbackArgument} */(tickable));\n        }\n      }\n    }\n  // Otherwise set the completed flag to false\n  } else {\n    tickable.completed = false;\n  }\n\n  // NOTE: hasRendered * direction (negative for backwards) this way we can remove the tickable.backwards property completly ?\n  return hasRendered;\n};\n\n/**\n * @param  {Tickable} tickable\n * @param  {Number} time\n * @param  {Number} muteCallbacks\n * @param  {Number} internalRender\n * @param  {Number} tickMode\n * @return {void}\n */\nconst tick = (tickable, time, muteCallbacks, internalRender, tickMode) => {\n  const _currentIteration = tickable._currentIteration;\n  render(tickable, time, muteCallbacks, internalRender, tickMode);\n  if (tickable._hasChildren) {\n    const tl = /** @type {Timeline} */(tickable);\n    const tlIsRunningBackwards = tl.backwards;\n    const tlChildrenTime = internalRender ? time : tl._iterationTime;\n    const tlCildrenTickTime = now();\n\n    let tlChildrenHasRendered = 0;\n    let tlChildrenHaveCompleted = true;\n\n    // If the timeline has looped forward, we need to manually triggers children skipped callbacks\n    if (!internalRender && tl._currentIteration !== _currentIteration) {\n      const tlIterationDuration = tl.iterationDuration;\n      forEachChildren(tl, (/** @type {JSAnimation} */child) => {\n        if (!tlIsRunningBackwards) {\n          // Force an internal render to trigger the callbacks if the child has not completed on loop\n          if (!child.completed && !child.backwards && child._currentTime < child.iterationDuration) {\n            render(child, tlIterationDuration, muteCallbacks, 1, tickModes.FORCE);\n          }\n          // Reset their began and completed flags to allow retrigering callbacks on the next iteration\n          child.began = false;\n          child.completed = false;\n        } else {\n          const childDuration = child.duration;\n          const childStartTime = child._offset + child._delay;\n          const childEndTime = childStartTime + childDuration;\n          // Triggers the onComplete callback on reverse for children on the edges of the timeline\n          if (!muteCallbacks && childDuration <= minValue && (!childStartTime || childEndTime === tlIterationDuration)) {\n            child.onComplete(child);\n          }\n        }\n      });\n      if (!muteCallbacks) tl.onLoop(/** @type {CallbackArgument} */(tl));\n    }\n\n    forEachChildren(tl, (/** @type {JSAnimation} */child) => {\n      const childTime = round((tlChildrenTime - child._offset) * child._speed, 12); // Rounding is needed when using seconds\n      const childTickMode = child._fps < tl._fps ? child.requestTick(tlCildrenTickTime) : tickMode;\n      tlChildrenHasRendered += render(child, childTime, muteCallbacks, internalRender, childTickMode);\n      if (!child.completed && tlChildrenHaveCompleted) tlChildrenHaveCompleted = false;\n    }, tlIsRunningBackwards);\n\n    // Renders on timeline are triggered by its children so it needs to be set after rendering the children\n    if (!muteCallbacks && tlChildrenHasRendered) tl.onRender(/** @type {CallbackArgument} */(tl));\n\n    // Triggers the timeline onComplete() once all chindren all completed and the current time has reached the end\n    if ((tlChildrenHaveCompleted || tlIsRunningBackwards) && tl._currentTime >= tl.duration) {\n      // Make sure the paused flag is false in case it has been skipped in the render function\n      tl.paused = true;\n      if (!tl.completed) {\n        tl.completed = true;\n        if (!muteCallbacks) {\n          tl.onComplete(/** @type {CallbackArgument} */(tl));\n          tl._resolve(/** @type {CallbackArgument} */(tl));\n        }\n      }\n    }\n  }\n};\n\n\n\n\nconst additive = {\n  animation: null,\n  update: noop,\n};\n\n/**\n * @typedef AdditiveAnimation\n * @property {Number} duration\n * @property {Number} _offset\n * @property {Number} _delay\n * @property {Tween} _head\n * @property {Tween} _tail\n */\n\n/**\n * @param  {TweenAdditiveLookups} lookups\n * @return {AdditiveAnimation}\n */\nconst addAdditiveAnimation = lookups => {\n  let animation = additive.animation;\n  if (!animation) {\n    animation = {\n      duration: minValue,\n      computeDeltaTime: noop,\n      _offset: 0,\n      _delay: 0,\n      _head: null,\n      _tail: null,\n    };\n    additive.animation = animation;\n    additive.update = () => {\n      lookups.forEach(propertyAnimation => {\n        for (let propertyName in propertyAnimation) {\n          const tweens = propertyAnimation[propertyName];\n          const lookupTween = tweens._head;\n          if (lookupTween) {\n            const valueType = lookupTween._valueType;\n            const additiveValues = valueType === valueTypes.COMPLEX || valueType === valueTypes.COLOR ? cloneArray(lookupTween._fromNumbers) : null;\n            let additiveValue = lookupTween._fromNumber;\n            let tween = tweens._tail;\n            while (tween && tween !== lookupTween) {\n              if (additiveValues) {\n                for (let i = 0, l = tween._numbers.length; i < l; i++) additiveValues[i] += tween._numbers[i];\n              } else {\n                additiveValue += tween._number;\n              }\n              tween = tween._prevAdd;\n            }\n            lookupTween._toNumber = additiveValue;\n            lookupTween._toNumbers = additiveValues;\n          }\n        }\n      });\n      // TODO: Avoid polymorphism here, idealy the additive animation should be a regular animation with a higher priority in the render loop\n      render(animation, 1, 1, 0, tickModes.FORCE);\n    };\n  }\n  return animation;\n};\n\nconst engineTickMethod = /*#__PURE__*/ (() => isBrowser ? requestAnimationFrame : setImmediate)();\nconst engineCancelMethod = /*#__PURE__*/ (() => isBrowser ? cancelAnimationFrame : clearImmediate)();\n\nclass Engine extends Clock {\n\n  /** @param {Number} [initTime] */\n  constructor(initTime) {\n    super(initTime);\n    this.useDefaultMainLoop = true;\n    this.pauseOnDocumentHidden = true;\n    /** @type {DefaultsParams} */\n    this.defaults = defaults;\n    this.paused = isBrowser && doc.hidden ? true  : false;\n    /** @type {Number|NodeJS.Immediate} */\n    this.reqId = null;\n  }\n\n  update() {\n    const time = this._currentTime = now();\n    if (this.requestTick(time)) {\n      this.computeDeltaTime(time);\n      const engineSpeed = this._speed;\n      const engineFps = this._fps;\n      let activeTickable = /** @type {Tickable} */(this._head);\n      while (activeTickable) {\n        const nextTickable = activeTickable._next;\n        if (!activeTickable.paused) {\n          tick(\n            activeTickable,\n            (time - activeTickable._startTime) * activeTickable._speed * engineSpeed,\n            0, // !muteCallbacks\n            0, // !internalRender\n            activeTickable._fps < engineFps ? activeTickable.requestTick(time) : tickModes.AUTO\n          );\n        } else {\n          removeChild(this, activeTickable);\n          this._hasChildren = !!this._tail;\n          activeTickable._running = false;\n          if (activeTickable.completed && !activeTickable._cancelled) {\n            activeTickable.cancel();\n          }\n        }\n        activeTickable = nextTickable;\n      }\n      additive.update();\n    }\n  }\n\n  wake() {\n    if (this.useDefaultMainLoop && !this.reqId && !this.paused) {\n      this.reqId = engineTickMethod(tickEngine);\n    }\n    return this;\n  }\n\n  pause() {\n    this.paused = true;\n    return killEngine();\n  }\n\n  resume() {\n    if (!this.paused) return;\n    this.paused = false;\n    forEachChildren(this, (/** @type {Tickable} */child) => child.resetTime());\n    return this.wake();\n  }\n\n  // Getter and setter for speed\n  get speed() {\n    return this._speed * (globals.timeScale === 1 ? 1 : K);\n  }\n\n  set speed(playbackRate) {\n    this._speed = playbackRate * globals.timeScale;\n    forEachChildren(this, (/** @type {Tickable} */child) => child.speed = child._speed);\n  }\n\n  // Getter and setter for timeUnit\n  get timeUnit() {\n    return globals.timeScale === 1 ? 'ms' : 's';\n  };\n\n  set timeUnit(unit) {\n    const secondsScale = 0.001;\n    const isSecond = unit === 's';\n    const newScale = isSecond ? secondsScale : 1;\n    if (globals.timeScale !== newScale) {\n      globals.timeScale = newScale;\n      globals.tickThreshold = 200 * newScale;\n      const scaleFactor = isSecond ? secondsScale : K;\n      /** @type {Number} */\n      (this.defaults.duration) *= scaleFactor;\n      this._speed *= scaleFactor;\n    }\n  }\n\n  // Getter and setter for precision\n  get precision() {\n    return globals.precision;\n  }\n\n  set precision(precision) {\n    globals.precision = precision;\n  }\n\n}\nconst engine = /*#__PURE__*/(() => {\n  const engine = new Engine(now());\n  if (isBrowser) {\n    globalVersions.engine = engine;\n    doc.addEventListener('visibilitychange', () => {\n      if (!engine.pauseOnDocumentHidden) return;\n      doc.hidden ? engine.pause() : engine.resume();\n    });\n  }\n  return engine;\n})();\n\n\nconst tickEngine = () => {\n  if (engine._head) {\n    engine.reqId = engineTickMethod(tickEngine);\n    engine.update();\n  } else {\n    engine.reqId = 0;\n  }\n};\n\nconst killEngine = () => {\n  engineCancelMethod(/** @type {NodeJS.Immediate & Number} */(engine.reqId));\n  engine.reqId = 0;\n  return engine;\n};\n\n\n\n\n/**\n * @param  {DOMTarget} target\n * @param  {String} propName\n * @param  {Object} animationInlineStyles\n * @return {String}\n */\nconst parseInlineTransforms = (target, propName, animationInlineStyles) => {\n  const inlineTransforms = target.style.transform;\n  let inlinedStylesPropertyValue;\n  if (inlineTransforms) {\n    const cachedTransforms = target[transformsSymbol];\n    let t; while (t = transformsExecRgx.exec(inlineTransforms)) {\n      const inlinePropertyName = t[1];\n      // const inlinePropertyValue = t[2];\n      const inlinePropertyValue = t[2].slice(1, -1);\n      cachedTransforms[inlinePropertyName] = inlinePropertyValue;\n      if (inlinePropertyName === propName) {\n        inlinedStylesPropertyValue = inlinePropertyValue;\n        // Store the new parsed inline styles if animationInlineStyles is provided\n        if (animationInlineStyles) {\n          animationInlineStyles[propName] = inlinePropertyValue;\n        }\n      }\n    }\n  }\n  return inlineTransforms && !isUnd(inlinedStylesPropertyValue) ? inlinedStylesPropertyValue :\n    stringStartsWith(propName, 'scale') ? '1' :\n    stringStartsWith(propName, 'rotate') || stringStartsWith(propName, 'skew') ? '0deg' : '0px';\n};\n\n\n\n\n/**\n * @param  {DOMTargetsParam|TargetsParam} v\n * @return {NodeList|HTMLCollection}\n */\nfunction getNodeList(v) {\n  const n = isStr(v) ? scope.root.querySelectorAll(v) : v;\n  if (n instanceof NodeList || n instanceof HTMLCollection) return n;\n}\n\n/**\n * @overload\n * @param  {DOMTargetsParam} targets\n * @return {DOMTargetsArray}\n *\n * @overload\n * @param  {JSTargetsParam} targets\n * @return {JSTargetsArray}\n *\n * @overload\n * @param  {TargetsParam} targets\n * @return {TargetsArray}\n *\n * @param  {DOMTargetsParam|JSTargetsParam|TargetsParam} targets\n */\nfunction parseTargets(targets) {\n  if (isNil(targets)) return /** @type {TargetsArray} */([]);\n  if (isArr(targets)) {\n    const flattened = targets.flat(Infinity);\n    /** @type {TargetsArray} */\n    const parsed = [];\n    for (let i = 0, l = flattened.length; i < l; i++) {\n      const item = flattened[i];\n      if (!isNil(item)) {\n        const nodeList = getNodeList(item);\n        if (nodeList) {\n          for (let j = 0, jl = nodeList.length; j < jl; j++) {\n            const subItem = nodeList[j];\n            if (!isNil(subItem)) {\n              let isDuplicate = false;\n              for (let k = 0, kl = parsed.length; k < kl; k++) {\n                if (parsed[k] === subItem) {\n                  isDuplicate = true;\n                  break;\n                }\n              }\n              if (!isDuplicate) {\n                parsed.push(subItem);\n              }\n            }\n          }\n        } else {\n          let isDuplicate = false;\n          for (let j = 0, jl = parsed.length; j < jl; j++) {\n            if (parsed[j] === item) {\n              isDuplicate = true;\n              break;\n            }\n          }\n          if (!isDuplicate) {\n            parsed.push(item);\n          }\n        }\n      }\n    }\n    return parsed;\n  }\n  if (!isBrowser) return /** @type {JSTargetsArray} */([targets]);\n  const nodeList = getNodeList(targets);\n  if (nodeList) return /** @type {DOMTargetsArray} */(Array.from(nodeList));\n  return /** @type {TargetsArray} */([targets]);\n}\n\n/**\n * @overload\n * @param  {DOMTargetsParam} targets\n * @return {DOMTargetsArray}\n *\n * @overload\n * @param  {JSTargetsParam} targets\n * @return {JSTargetsArray}\n *\n * @overload\n * @param  {TargetsParam} targets\n * @return {TargetsArray}\n *\n * @param  {DOMTargetsParam|JSTargetsParam|TargetsParam} targets\n */\nfunction registerTargets(targets) {\n  const parsedTargetsArray = parseTargets(targets);\n  const parsedTargetsLength = parsedTargetsArray.length;\n  if (parsedTargetsLength) {\n    for (let i = 0; i < parsedTargetsLength; i++) {\n      const target = parsedTargetsArray[i];\n      if (!target[isRegisteredTargetSymbol]) {\n        target[isRegisteredTargetSymbol] = true;\n        const isSvgType = isSvg(target);\n        const isDom = /** @type {DOMTarget} */(target).nodeType || isSvgType;\n        if (isDom) {\n          target[isDomSymbol] = true;\n          target[isSvgSymbol] = isSvgType;\n          target[transformsSymbol] = {};\n        }\n      }\n    }\n  }\n  return parsedTargetsArray;\n}\n\n\n\n\n/**\n * @param  {TargetsParam} path\n * @return {SVGGeometryElement|undefined}\n */\nconst getPath = path => {\n  const parsedTargets = parseTargets(path);\n  const $parsedSvg = /** @type {SVGGeometryElement} */(parsedTargets[0]);\n  if (!$parsedSvg || !isSvg($parsedSvg)) return;\n  return $parsedSvg;\n};\n\n/**\n * @param  {TargetsParam} path2\n * @param  {Number} [precision]\n * @return {FunctionValue}\n */\nconst morphTo = (path2, precision = .33) => ($path1) => {\n  const $path2 = /** @type {SVGGeometryElement} */(getPath(path2));\n  if (!$path2) return;\n  const isPath = $path1.tagName === 'path';\n  const separator = isPath ? ' ' : ',';\n  const previousPoints = $path1[morphPointsSymbol];\n  if (previousPoints) $path1.setAttribute(isPath ? 'd' : 'points', previousPoints);\n\n  let v1 = '', v2 = '';\n\n  if (!precision) {\n    v1 = $path1.getAttribute(isPath ? 'd' : 'points');\n    v2 = $path2.getAttribute(isPath ? 'd' : 'points');\n  } else {\n    const length1 = /** @type {SVGGeometryElement} */($path1).getTotalLength();\n    const length2 = $path2.getTotalLength();\n    const maxPoints = Math.max(Math.ceil(length1 * precision), Math.ceil(length2 * precision));\n    for (let i = 0; i < maxPoints; i++) {\n      const t = i / (maxPoints - 1);\n      const pointOnPath1 = /** @type {SVGGeometryElement} */($path1).getPointAtLength(length1 * t);\n      const pointOnPath2 = $path2.getPointAtLength(length2 * t);\n      const prefix = isPath ? (i === 0 ? 'M' : 'L') : '';\n      v1 += prefix + round(pointOnPath1.x, 3) + separator + pointOnPath1.y + ' ';\n      v2 += prefix + round(pointOnPath2.x, 3) + separator + pointOnPath2.y + ' ';\n    }\n  }\n\n  $path1[morphPointsSymbol] = v2;\n\n  return [v1, v2];\n};\n\n/**\n * @param {SVGGeometryElement} [$el]\n * @return {Number}\n */\nconst getScaleFactor = $el => {\n  let scaleFactor = 1;\n  if ($el && $el.getCTM) {\n    const ctm = $el.getCTM();\n    if (ctm) {\n      const scaleX = sqrt(ctm.a * ctm.a + ctm.b * ctm.b);\n      const scaleY = sqrt(ctm.c * ctm.c + ctm.d * ctm.d);\n      scaleFactor = (scaleX + scaleY) / 2;\n    }\n  }\n  return scaleFactor;\n};\n\n/**\n * Creates a proxy that wraps an SVGGeometryElement and adds drawing functionality.\n * @param {SVGGeometryElement} $el - The SVG element to transform into a drawable\n * @param {number} start - Starting position (0-1)\n * @param {number} end - Ending position (0-1)\n * @return {DrawableSVGGeometry} - Returns a proxy that preserves the original element's type with additional 'draw' attribute functionality\n */\nconst createDrawableProxy = ($el, start, end) => {\n  const pathLength = K;\n  const computedStyles = getComputedStyle($el);\n  const strokeLineCap = computedStyles.strokeLinecap;\n  // @ts-ignore\n  const $scalled = computedStyles.vectorEffect === 'non-scaling-stroke' ? $el : null;\n  let currentCap = strokeLineCap;\n\n  const proxy = new Proxy($el, {\n    get(target, property) {\n      const value = target[property];\n      if (property === proxyTargetSymbol) return target;\n      if (property === 'setAttribute') {\n        return (...args) => {\n          if (args[0] === 'draw') {\n            const value = args[1];\n            const values = value.split(' ');\n            const v1 = +values[0];\n            const v2 = +values[1];\n            // TOTO: Benchmark if performing two slices is more performant than one split\n            // const spaceIndex = value.indexOf(' ');\n            // const v1 = round(+value.slice(0, spaceIndex), precision);\n            // const v2 = round(+value.slice(spaceIndex + 1), precision);\n            const scaleFactor = getScaleFactor($scalled);\n            const os = v1 * -1e3 * scaleFactor;\n            const d1 = (v2 * pathLength * scaleFactor) + os;\n            const d2 = (pathLength * scaleFactor +\n                      ((v1 === 0 && v2 === 1) || (v1 === 1 && v2 === 0) ? 0 : 10 * scaleFactor) - d1);\n            if (strokeLineCap !== 'butt') {\n              const newCap = v1 === v2 ? 'butt' : strokeLineCap;\n              if (currentCap !== newCap) {\n                target.style.strokeLinecap = `${newCap}`;\n                currentCap = newCap;\n              }\n            }\n            target.setAttribute('stroke-dashoffset', `${os}`);\n            target.setAttribute('stroke-dasharray', `${d1} ${d2}`);\n          }\n          return Reflect.apply(value, target, args);\n        };\n      }\n\n      if (isFnc(value)) {\n        return (...args) => Reflect.apply(value, target, args);\n      } else {\n        return value;\n      }\n    }\n  });\n\n  if ($el.getAttribute('pathLength') !== `${pathLength}`) {\n    $el.setAttribute('pathLength', `${pathLength}`);\n    proxy.setAttribute('draw', `${start} ${end}`);\n  }\n\n  return /** @type {DrawableSVGGeometry} */(proxy);\n};\n\n/**\n * Creates drawable proxies for multiple SVG elements.\n * @param {TargetsParam} selector - CSS selector, SVG element, or array of elements and selectors\n * @param {number} [start=0] - Starting position (0-1)\n * @param {number} [end=0] - Ending position (0-1)\n * @return {Array<DrawableSVGGeometry>} - Array of proxied elements with drawing functionality\n */\nconst createDrawable = (selector, start = 0, end = 0) => {\n  const els = parseTargets(selector);\n  return els.map($el => createDrawableProxy(\n    /** @type {SVGGeometryElement} */($el),\n    start,\n    end\n  ));\n};\n\n// Motion path animation\n\n/**\n * @param {SVGGeometryElement} $path\n * @param {Number} progress\n * @param {Number}lookup\n * @return {DOMPoint}\n */\nconst getPathPoint = ($path, progress, lookup = 0) => {\n  return $path.getPointAtLength(progress + lookup >= 1 ? progress + lookup : 0);\n};\n\n/**\n * @param {SVGGeometryElement} $path\n * @param {String} pathProperty\n * @return {FunctionValue}\n */\nconst getPathProgess = ($path, pathProperty) => {\n  return $el => {\n    const totalLength = +($path.getTotalLength());\n    const inSvg = $el[isSvgSymbol];\n    const ctm = $path.getCTM();\n    /** @type {TweenObjectValue} */\n    return {\n      from: 0,\n      to: totalLength,\n      /** @type {TweenModifier} */\n      modifier: progress => {\n        if (pathProperty === 'a') {\n          const p0 = getPathPoint($path, progress, -1);\n          const p1 = getPathPoint($path, progress, 1);\n          return atan2(p1.y - p0.y, p1.x - p0.x) * 180 / PI;\n        } else {\n          const p = getPathPoint($path, progress, 0);\n          return pathProperty === 'x' ?\n            inSvg || !ctm ? p.x : p.x * ctm.a + p.y * ctm.c + ctm.e :\n            inSvg || !ctm ? p.y : p.x * ctm.b + p.y * ctm.d + ctm.f\n        }\n      }\n    }\n  }\n};\n\n/**\n * @param {TargetsParam} path\n */\nconst createMotionPath = path => {\n  const $path = getPath(path);\n  if (!$path) return;\n  return {\n    translateX: getPathProgess($path, 'x'),\n    translateY: getPathProgess($path, 'y'),\n    rotate: getPathProgess($path, 'a'),\n  }\n};\n\n// Check for valid SVG attribute\n\nconst cssReservedProperties = ['opacity', 'rotate', 'overflow', 'color'];\n\n/**\n * @param  {Target} el\n * @param  {String} propertyName\n * @return {Boolean}\n */\nconst isValidSVGAttribute = (el, propertyName) => {\n  // Return early and use CSS opacity animation instead (already better default values (opacity: 1 instead of 0)) and rotate should be considered a transform\n  if (cssReservedProperties.includes(propertyName)) return false;\n  if (el.getAttribute(propertyName) || propertyName in el) {\n    if (propertyName === 'scale') { // Scale\n      const elParentNode = /** @type {SVGGeometryElement} */(/** @type {DOMTarget} */(el).parentNode);\n      // Only consider scale as a valid SVG attribute on filter element\n      return elParentNode && elParentNode.tagName === 'filter';\n    }\n    return true;\n  }\n};\n\nconst svg = {\n  morphTo,\n  createMotionPath,\n  createDrawable,\n};\n\n\n\n\n/**\n * RGB / RGBA Color value string -> RGBA values array\n * @param  {String} rgbValue\n * @return {ColorArray}\n */\nconst rgbToRgba = rgbValue => {\n  const rgba = rgbExecRgx.exec(rgbValue) || rgbaExecRgx.exec(rgbValue);\n  const a = !isUnd(rgba[4]) ? +rgba[4] : 1;\n  return [\n    +rgba[1],\n    +rgba[2],\n    +rgba[3],\n    a\n  ]\n};\n\n/**\n * HEX3 / HEX3A / HEX6 / HEX6A Color value string -> RGBA values array\n * @param  {String} hexValue\n * @return {ColorArray}\n */\nconst hexToRgba = hexValue => {\n  const hexLength = hexValue.length;\n  const isShort = hexLength === 4 || hexLength === 5;\n  return [\n    +('0x' + hexValue[1] + hexValue[isShort ? 1 : 2]),\n    +('0x' + hexValue[isShort ? 2 : 3] + hexValue[isShort ? 2 : 4]),\n    +('0x' + hexValue[isShort ? 3 : 5] + hexValue[isShort ? 3 : 6]),\n    ((hexLength === 5 || hexLength === 9) ? +(+('0x' + hexValue[isShort ? 4 : 7] + hexValue[isShort ? 4 : 8]) / 255).toFixed(3) : 1)\n  ]\n};\n\n/**\n * @param  {Number} p\n * @param  {Number} q\n * @param  {Number} t\n * @return {Number}\n */\nconst hue2rgb = (p, q, t) => {\n  if (t < 0) t += 1;\n  if (t > 1) t -= 1;\n  return t < 1 / 6 ? p + (q - p) * 6 * t :\n         t < 1 / 2 ? q :\n         t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 :\n         p;\n};\n\n/**\n * HSL / HSLA Color value string -> RGBA values array\n * @param  {String} hslValue\n * @return {ColorArray}\n */\nconst hslToRgba = hslValue => {\n  const hsla = hslExecRgx.exec(hslValue) || hslaExecRgx.exec(hslValue);\n  const h = +hsla[1] / 360;\n  const s = +hsla[2] / 100;\n  const l = +hsla[3] / 100;\n  const a = !isUnd(hsla[4]) ? +hsla[4] : 1;\n  let r, g, b;\n  if (s === 0) {\n    r = g = b = l;\n  } else {\n    const q = l < .5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    r = round(hue2rgb(p, q, h + 1 / 3) * 255, 0);\n    g = round(hue2rgb(p, q, h) * 255, 0);\n    b = round(hue2rgb(p, q, h - 1 / 3) * 255, 0);\n  }\n  return [r, g, b, a];\n};\n\n/**\n * All in one color converter that converts a color string value into an array of RGBA values\n * @param  {String} colorString\n * @return {ColorArray}\n */\nconst convertColorStringValuesToRgbaArray = colorString => {\n  return isRgb(colorString) ? rgbToRgba(colorString) :\n         isHex(colorString) ? hexToRgba(colorString) :\n         isHsl(colorString) ? hslToRgba(colorString) :\n         [0, 0, 0, 1];\n};\n\n\n\n\n/**\n * @template T, D\n * @param {T|undefined} targetValue\n * @param {D} defaultValue\n * @return {T|D}\n */\nconst setValue = (targetValue, defaultValue) => {\n  return isUnd(targetValue) ? defaultValue : targetValue;\n};\n\n/**\n * @param  {TweenPropValue} value\n * @param  {Target} target\n * @param  {Number} index\n * @param  {Number} total\n * @param  {Object} [store]\n * @return {any}\n */\nconst getFunctionValue = (value, target, index, total, store) => {\n  if (isFnc(value)) {\n    const func = () => {\n      const computed = /** @type {Function} */(value)(target, index, total);\n      // Fallback to 0 if the function returns undefined / NaN / null / false / 0\n      return !isNaN(+computed) ? +computed : computed || 0;\n    };\n    if (store) {\n      store.func = func;\n    }\n    return func();\n  } else {\n    return value;\n  }\n};\n\n/**\n * @param  {Target} target\n * @param  {String} prop\n * @return {tweenTypes}\n */\nconst getTweenType = (target, prop) => {\n  return !target[isDomSymbol] ? tweenTypes.OBJECT :\n    // Handle SVG attributes\n    target[isSvgSymbol] && isValidSVGAttribute(target, prop) ? tweenTypes.ATTRIBUTE :\n    // Handle CSS Transform properties differently than CSS to allow individual animations\n    validTransforms.includes(prop) || shortTransforms.get(prop) ? tweenTypes.TRANSFORM :\n    // CSS variables\n    stringStartsWith(prop, '--') ? tweenTypes.CSS_VAR :\n    // All other CSS properties\n    prop in /** @type {DOMTarget} */(target).style ? tweenTypes.CSS :\n    // Handle other DOM Attributes\n    prop in target ? tweenTypes.OBJECT :\n    tweenTypes.ATTRIBUTE;\n};\n\n/**\n * @param  {DOMTarget} target\n * @param  {String} propName\n * @param  {Object} animationInlineStyles\n * @return {String}\n */\nconst getCSSValue = (target, propName, animationInlineStyles) => {\n  const inlineStyles = target.style[propName];\n  if (inlineStyles && animationInlineStyles) {\n    animationInlineStyles[propName] = inlineStyles;\n  }\n  const value = inlineStyles || getComputedStyle(target[proxyTargetSymbol] || target).getPropertyValue(propName);\n  return value === 'auto' ? '0' : value;\n};\n\n/**\n * @param {Target} target\n * @param {String} propName\n * @param {tweenTypes} [tweenType]\n * @param {Object|void} [animationInlineStyles]\n * @return {String|Number}\n */\nconst getOriginalAnimatableValue = (target, propName, tweenType, animationInlineStyles) => {\n  const type = !isUnd(tweenType) ? tweenType : getTweenType(target, propName);\n  return type === tweenTypes.OBJECT ? target[propName] || 0 :\n         type === tweenTypes.ATTRIBUTE ? /** @type {DOMTarget} */(target).getAttribute(propName) :\n         type === tweenTypes.TRANSFORM ? parseInlineTransforms(/** @type {DOMTarget} */(target), propName, animationInlineStyles) :\n         type === tweenTypes.CSS_VAR ? getCSSValue(/** @type {DOMTarget} */(target), propName, animationInlineStyles).trimStart() :\n         getCSSValue(/** @type {DOMTarget} */(target), propName, animationInlineStyles);\n};\n\n/**\n * @param  {Number} x\n * @param  {Number} y\n * @param  {String} operator\n * @return {Number}\n */\nconst getRelativeValue = (x, y, operator) => {\n  return operator === '-' ? x - y :\n         operator === '+' ? x + y :\n         x * y;\n};\n\n/** @return {TweenDecomposedValue} */\nconst createDecomposedValueTargetObject = () => {\n  return {\n    /** @type {valueTypes} */\n    t: valueTypes.NUMBER,\n    n: 0,\n    u: null,\n    o: null,\n    d: null,\n    s: null,\n  }\n};\n\n/**\n * @param  {String|Number} rawValue\n * @param  {TweenDecomposedValue} targetObject\n * @return {TweenDecomposedValue}\n */\nconst decomposeRawValue = (rawValue, targetObject) => {\n  /** @type {valueTypes} */\n  targetObject.t = valueTypes.NUMBER;\n  targetObject.n = 0;\n  targetObject.u = null;\n  targetObject.o = null;\n  targetObject.d = null;\n  targetObject.s = null;\n  if (!rawValue) return targetObject;\n  const num = +rawValue;\n  if (!isNaN(num)) {\n    // It's a number\n    targetObject.n = num;\n    return targetObject;\n  } else {\n    // let str = /** @type {String} */(rawValue).trim();\n    let str = /** @type {String} */(rawValue);\n    // Parsing operators (+=, -=, *=) manually is much faster than using regex here\n    if (str[1] === '=') {\n      targetObject.o = str[0];\n      str = str.slice(2);\n    }\n    // Skip exec regex if the value type is complex or color to avoid long regex backtracking\n    const unitMatch = str.includes(' ') ? false : unitsExecRgx.exec(str);\n    if (unitMatch) {\n      // Has a number and a unit\n      targetObject.t = valueTypes.UNIT;\n      targetObject.n = +unitMatch[1];\n      targetObject.u = unitMatch[2];\n      return targetObject;\n    } else if (targetObject.o) {\n      // Has an operator (+=, -=, *=)\n      targetObject.n = +str;\n      return targetObject;\n    } else if (isCol(str)) {\n      // Is a color\n      targetObject.t = valueTypes.COLOR;\n      targetObject.d = convertColorStringValuesToRgbaArray(str);\n      return targetObject;\n    } else {\n      // Is a more complex string (generally svg coords, calc() or filters CSS values)\n      const matchedNumbers = str.match(digitWithExponentRgx);\n      targetObject.t = valueTypes.COMPLEX;\n      targetObject.d = matchedNumbers ? matchedNumbers.map(Number) : [];\n      targetObject.s = str.split(digitWithExponentRgx) || [];\n      return targetObject;\n    }\n  }\n};\n\n/**\n * @param  {Tween} tween\n * @param  {TweenDecomposedValue} targetObject\n * @return {TweenDecomposedValue}\n */\nconst decomposeTweenValue = (tween, targetObject) => {\n  targetObject.t = tween._valueType;\n  targetObject.n = tween._toNumber;\n  targetObject.u = tween._unit;\n  targetObject.o = null;\n  targetObject.d = cloneArray(tween._toNumbers);\n  targetObject.s = cloneArray(tween._strings);\n  return targetObject;\n};\n\nconst decomposedOriginalValue = createDecomposedValueTargetObject();\n\n\n\n\nconst lookups = {\n  /** @type {TweenReplaceLookups} */\n  _rep: new WeakMap(),\n  /** @type {TweenAdditiveLookups} */\n  _add: new Map(),\n};\n\n/**\n * @param  {Target} target\n * @param  {String} property\n * @param  {String} lookup\n * @return {TweenPropertySiblings}\n */\nconst getTweenSiblings = (target, property, lookup = '_rep') => {\n  const lookupMap = lookups[lookup];\n  let targetLookup = lookupMap.get(target);\n  if (!targetLookup) {\n    targetLookup = {};\n    lookupMap.set(target, targetLookup);\n  }\n  return targetLookup[property] ? targetLookup[property] : targetLookup[property] = {\n    _head: null,\n    _tail: null,\n  }\n};\n\n/**\n * @param  {Tween} p\n * @param  {Tween} c\n * @return {Number|Boolean}\n */\nconst addTweenSortMethod = (p, c) => {\n  return p._isOverridden || p._absoluteStartTime > c._absoluteStartTime;\n};\n\n/**\n * @param {Tween} tween\n */\nconst overrideTween = tween => {\n  tween._isOverlapped = 1;\n  tween._isOverridden = 1;\n  tween._changeDuration = minValue;\n  tween._currentTime = minValue;\n};\n\n/**\n * @param  {Tween} tween\n * @param  {TweenPropertySiblings} siblings\n * @return {Tween}\n */\nconst composeTween = (tween, siblings) => {\n\n  const tweenCompositionType = tween._composition;\n\n  // Handle replaced tweens\n\n  if (tweenCompositionType === compositionTypes.replace) {\n\n    const tweenAbsStartTime = tween._absoluteStartTime;\n\n    addChild(siblings, tween, addTweenSortMethod, '_prevRep', '_nextRep');\n\n    const prevSibling = tween._prevRep;\n\n    // Update the previous siblings for composition replace tweens\n\n    if (prevSibling) {\n\n      const prevParent = prevSibling.parent;\n      const prevAbsEndTime = prevSibling._absoluteStartTime + prevSibling._changeDuration;\n\n      // Handle looped animations tween\n\n      if (\n        // Check if the previous tween is from a different animation\n        tween.parent.id !== prevParent.id &&\n        // Check if the animation has loops\n        prevParent.iterationCount> 1 &&\n        // Check if _absoluteChangeEndTime of last loop overlaps the current tween\n        prevAbsEndTime + (prevParent.duration - prevParent.iterationDuration) > tweenAbsStartTime\n      ) {\n\n        // TODO: Find a way to only override the iterations overlapping with the tween\n        overrideTween(prevSibling);\n\n        let prevPrevSibling = prevSibling._prevRep;\n\n        // If the tween was part of a set of keyframes, override its siblings\n        while (prevPrevSibling && prevPrevSibling.parent.id === prevParent.id) {\n          overrideTween(prevPrevSibling);\n          prevPrevSibling = prevPrevSibling._prevRep;\n        }\n\n      }\n\n      const absoluteUpdateStartTime = tweenAbsStartTime - tween._delay;\n\n      if (prevAbsEndTime > absoluteUpdateStartTime) {\n\n        const prevChangeStartTime = prevSibling._startTime;\n        const prevTLOffset = prevAbsEndTime - (prevChangeStartTime + prevSibling._updateDuration);\n\n        prevSibling._changeDuration = absoluteUpdateStartTime - prevTLOffset - prevChangeStartTime;\n        prevSibling._currentTime = prevSibling._changeDuration;\n        prevSibling._isOverlapped = 1;\n\n        if (prevSibling._changeDuration < minValue) {\n          overrideTween(prevSibling);\n        }\n      }\n\n      // Pause (and cancel) the parent if it only contains overlapped tweens\n\n      let pausePrevParentAnimation = true;\n\n      forEachChildren(prevParent, (/** @type Tween */t) => {\n        if (!t._isOverlapped) pausePrevParentAnimation = false;\n      });\n\n      if (pausePrevParentAnimation) {\n        const prevParentTL = prevParent.parent;\n        if (prevParentTL) {\n          let pausePrevParentTL = true;\n          forEachChildren(prevParentTL, (/** @type JSAnimation */a) => {\n            if (a !== prevParent) {\n              forEachChildren(a, (/** @type Tween */t) => {\n                if (!t._isOverlapped) pausePrevParentTL = false;\n              });\n            }\n          });\n          if (pausePrevParentTL) {\n            prevParentTL.cancel();\n          }\n        } else {\n          prevParent.cancel();\n          // Previously, calling .cancel() on a timeline child would affect the render order of other children\n          // Worked around this by marking it as .completed and using .pause() for safe removal in the engine loop\n          // This is no longer needed since timeline tween composition is now handled separatly\n          // Keeping this here for reference\n          // prevParent.completed = true;\n          // prevParent.pause();\n        }\n      }\n\n    }\n\n    // let nextSibling = tween._nextRep;\n\n    // // All the next siblings are automatically overridden\n\n    // if (nextSibling && nextSibling._absoluteStartTime >= tweenAbsStartTime) {\n    //   while (nextSibling) {\n    //     overrideTween(nextSibling);\n    //     nextSibling = nextSibling._nextRep;\n    //   }\n    // }\n\n    // if (nextSibling && nextSibling._absoluteStartTime < tweenAbsStartTime) {\n    //   while (nextSibling) {\n    //     overrideTween(nextSibling);\n    //     console.log(tween.id, nextSibling.id);\n    //     nextSibling = nextSibling._nextRep;\n    //   }\n    // }\n\n  // Handle additive tweens composition\n\n  } else if (tweenCompositionType === compositionTypes.blend) {\n\n    const additiveTweenSiblings = getTweenSiblings(tween.target, tween.property, '_add');\n    const additiveAnimation = addAdditiveAnimation(lookups._add);\n\n    let lookupTween = additiveTweenSiblings._head;\n\n    if (!lookupTween) {\n      lookupTween = { ...tween };\n      lookupTween._composition = compositionTypes.replace;\n      lookupTween._updateDuration = minValue;\n      lookupTween._startTime = 0;\n      lookupTween._numbers = cloneArray(tween._fromNumbers);\n      lookupTween._number = 0;\n      lookupTween._next = null;\n      lookupTween._prev = null;\n      addChild(additiveTweenSiblings, lookupTween);\n      addChild(additiveAnimation, lookupTween);\n    }\n\n    // Convert the values of TO to FROM and set TO to 0\n\n    const toNumber = tween._toNumber;\n    tween._fromNumber = lookupTween._fromNumber - toNumber;\n    tween._toNumber = 0;\n    tween._numbers = cloneArray(tween._fromNumbers);\n    tween._number = 0;\n    lookupTween._fromNumber = toNumber;\n\n    if (tween._toNumbers) {\n      const toNumbers = cloneArray(tween._toNumbers);\n      if (toNumbers) {\n        toNumbers.forEach((value, i) => {\n          tween._fromNumbers[i] = lookupTween._fromNumbers[i] - value;\n          tween._toNumbers[i] = 0;\n        });\n      }\n      lookupTween._fromNumbers = toNumbers;\n    }\n\n    addChild(additiveTweenSiblings, tween, null, '_prevAdd', '_nextAdd');\n\n  }\n\n  return tween;\n\n};\n\n/**\n * @param  {Tween} tween\n * @return {Tween}\n */\nconst removeTweenSliblings = tween => {\n  const tweenComposition = tween._composition;\n  if (tweenComposition !== compositionTypes.none) {\n    const tweenTarget = tween.target;\n    const tweenProperty = tween.property;\n    const replaceTweensLookup = lookups._rep;\n    const replaceTargetProps = replaceTweensLookup.get(tweenTarget);\n    const tweenReplaceSiblings = replaceTargetProps[tweenProperty];\n    removeChild(tweenReplaceSiblings, tween, '_prevRep', '_nextRep');\n    if (tweenComposition === compositionTypes.blend) {\n      const addTweensLookup = lookups._add;\n      const addTargetProps = addTweensLookup.get(tweenTarget);\n      if (!addTargetProps) return;\n      const additiveTweenSiblings = addTargetProps[tweenProperty];\n      const additiveAnimation = additive.animation;\n      removeChild(additiveTweenSiblings, tween, '_prevAdd', '_nextAdd');\n      // If only one tween is left in the additive lookup, it's the tween lookup\n      const lookupTween = additiveTweenSiblings._head;\n      if (lookupTween && lookupTween === additiveTweenSiblings._tail) {\n        removeChild(additiveTweenSiblings, lookupTween, '_prevAdd', '_nextAdd');\n        removeChild(additiveAnimation, lookupTween);\n        let shouldClean = true;\n        for (let prop in addTargetProps) {\n          if (addTargetProps[prop]._head) {\n            shouldClean = false;\n            break;\n          }\n        }\n        if (shouldClean) {\n          addTweensLookup.delete(tweenTarget);\n        }\n      }\n    }\n  }\n  return tween;\n};\n\n\n\n\n/**\n * @param  {Timer} timer\n * @return {Timer}\n */\nconst resetTimerProperties = timer => {\n  timer.paused = true;\n  timer.began = false;\n  timer.completed = false;\n  return timer;\n};\n\n/**\n * @param  {Timer} timer\n * @return {Timer}\n */\nconst reviveTimer = timer => {\n  if (!timer._cancelled) return timer;\n  if (timer._hasChildren) {\n    forEachChildren(timer, reviveTimer);\n  } else {\n    forEachChildren(timer, (/** @type {Tween} tween*/tween) => {\n      if (tween._composition !== compositionTypes.none) {\n        composeTween(tween, getTweenSiblings(tween.target, tween.property));\n      }\n    });\n  }\n  timer._cancelled = 0;\n  return timer;\n};\n\nlet timerId = 0;\n\n/**\n * Base class used to create Timers, Animations and Timelines\n */\nclass Timer extends Clock {\n  /**\n   * @param {TimerParams} [parameters]\n   * @param {Timeline} [parent]\n   * @param {Number} [parentPosition]\n   */\n  constructor(parameters = {}, parent = null, parentPosition = 0) {\n\n    super(0);\n\n    const {\n      id,\n      delay,\n      duration,\n      reversed,\n      alternate,\n      loop,\n      loopDelay,\n      autoplay,\n      frameRate,\n      playbackRate,\n      onComplete,\n      onLoop,\n      onPause,\n      onBegin,\n      onBeforeUpdate,\n      onUpdate,\n    } = parameters;\n\n    if (scope.current) scope.current.register(this);\n\n    const timerInitTime = parent ? 0 : engine._elapsedTime;\n    const timerDefaults = parent ? parent.defaults : globals.defaults;\n    const timerDelay = /** @type {Number} */(isFnc(delay) || isUnd(delay) ? timerDefaults.delay : +delay);\n    const timerDuration = isFnc(duration) || isUnd(duration) ? Infinity : +duration;\n    const timerLoop = setValue(loop, timerDefaults.loop);\n    const timerLoopDelay = setValue(loopDelay, timerDefaults.loopDelay);\n    const timerIterationCount = timerLoop === true ||\n                                timerLoop === Infinity ||\n                                /** @type {Number} */(timerLoop) < 0 ? Infinity :\n                                /** @type {Number} */(timerLoop) + 1;\n\n    let offsetPosition = 0;\n\n    if (parent) {\n      offsetPosition = parentPosition;\n    } else {\n      let startTime = now();\n      // Make sure to tick the engine once if suspended to avoid big gaps with the following offsetPosition calculation\n      if (engine.paused) {\n        engine.requestTick(startTime);\n        startTime = engine._elapsedTime;\n      }\n      offsetPosition = startTime - engine._startTime;\n    }\n\n    // Timer's parameters\n    this.id = !isUnd(id) ? id : ++timerId;\n    /** @type {Timeline} */\n    this.parent = parent;\n    // Total duration of the timer\n    this.duration = clampInfinity(((timerDuration + timerLoopDelay) * timerIterationCount) - timerLoopDelay) || minValue;\n    /** @type {Boolean} */\n    this.backwards = false;\n    /** @type {Boolean} */\n    this.paused = true;\n    /** @type {Boolean} */\n    this.began = false;\n    /** @type {Boolean} */\n    this.completed = false;\n    /** @type {Callback<this>} */\n    this.onBegin = onBegin || timerDefaults.onBegin;\n    /** @type {Callback<this>} */\n    this.onBeforeUpdate = onBeforeUpdate || timerDefaults.onBeforeUpdate;\n    /** @type {Callback<this>} */\n    this.onUpdate = onUpdate || timerDefaults.onUpdate;\n    /** @type {Callback<this>} */\n    this.onLoop = onLoop || timerDefaults.onLoop;\n    /** @type {Callback<this>} */\n    this.onPause = onPause || timerDefaults.onPause;\n    /** @type {Callback<this>} */\n    this.onComplete = onComplete || timerDefaults.onComplete;\n    /** @type {Number} */\n    this.iterationDuration = timerDuration; // Duration of one loop\n    /** @type {Number} */\n    this.iterationCount = timerIterationCount; // Number of loops\n    /** @type {Boolean|ScrollObserver} */\n    this._autoplay = parent ? false : setValue(autoplay, timerDefaults.autoplay);\n    /** @type {Number} */\n    this._offset = offsetPosition;\n    /** @type {Number} */\n    this._delay = timerDelay;\n    /** @type {Number} */\n    this._loopDelay = timerLoopDelay;\n    /** @type {Number} */\n    this._iterationTime = 0;\n    /** @type {Number} */\n    this._currentIteration = 0; // Current loop index\n    /** @type {Function} */\n    this._resolve = noop; // Used by .then()\n    /** @type {Boolean} */\n    this._running = false;\n    /** @type {Number} */\n    this._reversed = +setValue(reversed, timerDefaults.reversed);\n    /** @type {Number} */\n    this._reverse = this._reversed;\n    /** @type {Number} */\n    this._cancelled = 0;\n    /** @type {Boolean} */\n    this._alternate = setValue(alternate, timerDefaults.alternate);\n    /** @type {Renderable} */\n    this._prev = null;\n    /** @type {Renderable} */\n    this._next = null;\n\n    // Clock's parameters\n    /** @type {Number} */\n    this._elapsedTime = timerInitTime;\n    /** @type {Number} */\n    this._startTime = timerInitTime;\n    /** @type {Number} */\n    this._lastTime = timerInitTime;\n    /** @type {Number} */\n    this._fps = setValue(frameRate, timerDefaults.frameRate);\n    /** @type {Number} */\n    this._speed = setValue(playbackRate, timerDefaults.playbackRate);\n  }\n\n  get cancelled() {\n    return !!this._cancelled;\n  }\n\n  /** @param {Boolean} cancelled  */\n  set cancelled(cancelled) {\n    cancelled ? this.cancel() : this.reset(1).play();\n  }\n\n  get currentTime() {\n    return clamp(round(this._currentTime, globals.precision), -this._delay, this.duration);\n  }\n\n  /** @param {Number} time  */\n  set currentTime(time) {\n    const paused = this.paused;\n    // Pausing the timer is necessary to avoid time jumps on a running instance\n    this.pause().seek(+time);\n    if (!paused) this.resume();\n  }\n\n  get iterationCurrentTime() {\n    return round(this._iterationTime, globals.precision);\n  }\n\n  /** @param {Number} time  */\n  set iterationCurrentTime(time) {\n    this.currentTime = (this.iterationDuration * this._currentIteration) + time;\n  }\n\n  get progress() {\n    return clamp(round(this._currentTime / this.duration, 10), 0, 1);\n  }\n\n  /** @param {Number} progress  */\n  set progress(progress) {\n    this.currentTime = this.duration * progress;\n  }\n\n  get iterationProgress() {\n    return clamp(round(this._iterationTime / this.iterationDuration, 10), 0, 1);\n  }\n\n  /** @param {Number} progress  */\n  set iterationProgress(progress) {\n    const iterationDuration = this.iterationDuration;\n    this.currentTime = (iterationDuration * this._currentIteration) + (iterationDuration * progress);\n  }\n\n  get currentIteration() {\n    return this._currentIteration;\n  }\n\n  /** @param {Number} iterationCount  */\n  set currentIteration(iterationCount) {\n    this.currentTime = (this.iterationDuration * clamp(+iterationCount, 0, this.iterationCount - 1));\n  }\n\n  get reversed() {\n    return !!this._reversed;\n  }\n\n  /** @param {Boolean} reverse  */\n  set reversed(reverse) {\n    reverse ? this.reverse() : this.play();\n  }\n\n  get speed() {\n    return super.speed;\n  }\n\n  /** @param {Number} playbackRate  */\n  set speed(playbackRate) {\n    super.speed = playbackRate;\n    this.resetTime();\n  }\n\n  /**\n   * @param  {Number} internalRender\n   * @return {this}\n   */\n  reset(internalRender = 0) {\n    // If cancelled, revive the timer before rendering in order to have propertly composed tweens siblings\n    reviveTimer(this);\n    if (this._reversed && !this._reverse) this.reversed = false;\n    // Rendering before updating the completed flag to prevent skips and to make sure the properties are not overridden\n    // Setting the iterationTime at the end to force the rendering to happend backwards, otherwise calling .reset() on Timelines might not render children in the right order\n    // NOTE: This is only required for Timelines and might be better to move to the Timeline class?\n    this._iterationTime = this.iterationDuration;\n    // Set tickMode to tickModes.FORCE to force rendering\n    tick(this, 0, 1, internalRender, tickModes.FORCE);\n    // Reset timer properties after revive / render to make sure the props are not updated again\n    resetTimerProperties(this);\n    // Also reset children properties\n    if (this._hasChildren) {\n      forEachChildren(this, resetTimerProperties);\n    }\n    return this;\n  }\n\n  /**\n   * @param  {Number} internalRender\n   * @return {this}\n   */\n  init(internalRender = 0) {\n    this.fps = this._fps;\n    this.speed = this._speed;\n    // Manually calling .init() on timelines should render all children intial state\n    // Forces all children to render once then render to 0 when reseted\n    if (!internalRender && this._hasChildren) {\n      tick(this, this.duration, 1, internalRender, tickModes.FORCE);\n    }\n    this.reset(internalRender);\n    // Make sure to set autoplay to false to child timers so it doesn't attempt to autoplay / link\n    const autoplay = this._autoplay;\n    if (autoplay === true) {\n      this.resume();\n    } else if (autoplay && !isUnd(/** @type {ScrollObserver} */(autoplay).linked)) {\n      /** @type {ScrollObserver} */(autoplay).link(this);\n    }\n    return this;\n  }\n\n  /** @return {this} */\n  resetTime() {\n    const timeScale = 1 / (this._speed * engine._speed);\n    this._startTime = now() - (this._currentTime + this._delay) * timeScale;\n    return this;\n  }\n\n  /** @return {this} */\n  pause() {\n    if (this.paused) return this;\n    this.paused = true;\n    this.onPause(this);\n    return this;\n  }\n\n  /** @return {this} */\n  resume() {\n    if (!this.paused) return this;\n    this.paused = false;\n    // We can safely imediatly render a timer that has no duration and no children\n    if (this.duration <= minValue && !this._hasChildren) {\n      tick(this, minValue, 0, 0, tickModes.FORCE);\n    } else {\n      if (!this._running) {\n        addChild(engine, this);\n        engine._hasChildren = true;\n        this._running = true;\n      }\n      this.resetTime();\n      // Forces the timer to advance by at least one frame when the next tick occurs\n      this._startTime -= 12;\n      engine.wake();\n    }\n    return this;\n  }\n\n  /** @return {this} */\n  restart() {\n    return this.reset(0).resume();\n  }\n\n  /**\n   * @param  {Number} time\n   * @param  {Boolean|Number} [muteCallbacks]\n   * @param  {Boolean|Number} [internalRender]\n   * @return {this}\n   */\n  seek(time, muteCallbacks = 0, internalRender = 0) {\n    // Recompose the tween siblings in case the timer has been cancelled\n    reviveTimer(this);\n    // If you seek a completed animation, otherwise the next play will starts at 0\n    this.completed = false;\n    const isPaused = this.paused;\n    this.paused = true;\n    // timer, time, muteCallbacks, internalRender, tickMode\n    tick(this, time + this._delay, ~~muteCallbacks, ~~internalRender, tickModes.AUTO);\n    return isPaused ? this : this.resume();\n  }\n\n  /** @return {this} */\n  alternate() {\n    const reversed = this._reversed;\n    const count = this.iterationCount;\n    const duration = this.iterationDuration;\n    // Calculate the maximum iterations possible given the iteration duration\n    const iterations = count === Infinity ? floor(maxValue / duration) : count;\n    this._reversed = +(this._alternate && !(iterations % 2) ? reversed : !reversed);\n    if (count === Infinity) {\n      // Handle infinite loops to loop on themself\n      this.iterationProgress = this._reversed ? 1 - this.iterationProgress : this.iterationProgress;\n    } else {\n      this.seek((duration * iterations) - this._currentTime);\n    }\n    this.resetTime();\n    return this;\n  }\n\n  /** @return {this} */\n  play() {\n    if (this._reversed) this.alternate();\n    return this.resume();\n  }\n\n  /** @return {this} */\n  reverse() {\n    if (!this._reversed) this.alternate();\n    return this.resume();\n  }\n\n  // TODO: Move all the animation / tweens / children related code to Animation / Timeline\n\n  /** @return {this} */\n  cancel() {\n    if (this._hasChildren) {\n      forEachChildren(this, (/** @type {Renderable} */child) => child.cancel(), true);\n    } else {\n      forEachChildren(this, removeTweenSliblings);\n    }\n    this._cancelled = 1;\n    // Pausing the timer removes it from the engine\n    return this.pause();\n  }\n\n  /**\n   * @param  {Number} newDuration\n   * @return {this}\n   */\n  stretch(newDuration) {\n    const currentDuration = this.duration;\n    const normlizedDuration = normalizeTime(newDuration);\n    if (currentDuration === normlizedDuration) return this;\n    const timeScale = newDuration / currentDuration;\n    const isSetter = newDuration <= minValue;\n    this.duration = isSetter ? minValue : normlizedDuration;\n    this.iterationDuration = isSetter ? minValue : normalizeTime(this.iterationDuration * timeScale);\n    this._offset *= timeScale;\n    this._delay *= timeScale;\n    this._loopDelay *= timeScale;\n    return this;\n  }\n\n /**\n   * Cancels the timer by seeking it back to 0 and reverting the attached scroller if necessary\n   * @return {this}\n   */\n  revert() {\n    tick(this, 0, 1, 0, tickModes.AUTO);\n    const ap = /** @type {ScrollObserver} */(this._autoplay);\n    if (ap && ap.linked && ap.linked === this) ap.revert();\n    return this.cancel();\n  }\n\n /**\n   * Imediatly completes the timer, cancels it and triggers the onComplete callback\n   * @return {this}\n   */\n  complete() {\n    return this.seek(this.duration).cancel();\n  }\n\n  /**\n   * @param  {Callback<this>} [callback]\n   * @return {Promise}\n   */\n  then(callback = noop) {\n    const then = this.then;\n    const onResolve = () => {\n      // this.then = null prevents infinite recursion if returned by an async function\n      // https://github.com/juliangarnierorg/anime-beta/issues/26\n      this.then = null;\n      callback(this);\n      this.then = then;\n      this._resolve = noop;\n    };\n    return new Promise(r => {\n      this._resolve = () => r(onResolve());\n      // Make sure to resolve imediatly if the timer has already completed\n      if (this.completed) this._resolve();\n      return this;\n    });\n  }\n\n}\n\n\n/**\n * @param {TimerParams} [parameters]\n * @return {Timer}\n */\nconst createTimer = parameters => new Timer(parameters, null, 0).init();\n\n\n\n\n/** @type {EasingFunction} */\nconst none = t => t;\n\n// Cubic Bezier solver adapted from https://github.com/gre/bezier-ease © Gaëtan Renaudeau\n\n/**\n * @param  {Number} aT\n * @param  {Number} aA1\n * @param  {Number} aA2\n * @return {Number}\n */\nconst calcBezier = (aT, aA1, aA2) => (((1 - 3 * aA2 + 3 * aA1) * aT + (3 * aA2 - 6 * aA1)) * aT + (3 * aA1)) * aT;\n\n/**\n * @param  {Number} aX\n * @param  {Number} mX1\n * @param  {Number} mX2\n * @return {Number}\n */\nconst binarySubdivide = (aX, mX1, mX2) => {\n  let aA = 0, aB = 1, currentX, currentT, i = 0;\n  do {\n    currentT = aA + (aB - aA) / 2;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (abs(currentX) > .0000001 && ++i < 100);\n  return currentT;\n};\n\n/**\n * @param  {Number} [mX1]\n * @param  {Number} [mY1]\n * @param  {Number} [mX2]\n * @param  {Number} [mY2]\n * @return {EasingFunction}\n */\n\nconst cubicBezier = (mX1 = 0.5, mY1 = 0.0, mX2 = 0.5, mY2 = 1.0) => (mX1 === mY1 && mX2 === mY2) ? none :\n  t => t === 0 || t === 1 ? t :\n  calcBezier(binarySubdivide(t, mX1, mX2), mY1, mY2);\n\n/**\n * Steps ease implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function\n * Only covers 'end' and 'start' jumpterms\n * @param  {Number} steps\n * @param  {Boolean} [fromStart]\n * @return {EasingFunction}\n */\nconst steps = (steps = 10, fromStart) => {\n  const roundMethod = fromStart ? ceil : floor;\n  return t => roundMethod(clamp(t, 0, 1) * steps) * (1 / steps);\n};\n\n/**\n * Without parameters, the linear function creates a non-eased transition.\n * Parameters, if used, creates a piecewise linear easing by interpolating linearly between the specified points.\n * @param  {...String|Number} [args] - Points\n * @return {EasingFunction}\n */\nconst linear = (...args) => {\n  const argsLength = args.length;\n  if (!argsLength) return none;\n  const totalPoints = argsLength - 1;\n  const firstArg = args[0];\n  const lastArg = args[totalPoints];\n  const xPoints = [0];\n  const yPoints = [parseNumber(firstArg)];\n  for (let i = 1; i < totalPoints; i++) {\n    const arg = args[i];\n    const splitValue = isStr(arg) ?\n    /** @type {String} */(arg).trim().split(' ') :\n    [arg];\n    const value = splitValue[0];\n    const percent = splitValue[1];\n    xPoints.push(!isUnd(percent) ? parseNumber(percent) / 100 : i / totalPoints);\n    yPoints.push(parseNumber(value));\n  }\n  yPoints.push(parseNumber(lastArg));\n  xPoints.push(1);\n  return function easeLinear(t) {\n    for (let i = 1, l = xPoints.length; i < l; i++) {\n      const currentX = xPoints[i];\n      if (t <= currentX) {\n        const prevX = xPoints[i - 1];\n        const prevY = yPoints[i - 1];\n        return prevY + (yPoints[i] - prevY) * (t - prevX) / (currentX - prevX);\n      }\n    }\n    return yPoints[yPoints.length - 1];\n  }\n};\n\n/**\n * Generate random steps\n * @param  {Number} [length] - The number of steps\n * @param  {Number} [randomness] - How strong the randomness is\n * @return {EasingFunction}\n */\nconst irregular = (length = 10, randomness = 1) => {\n  const values = [0];\n  const total = length - 1;\n  for (let i = 1; i < total; i++) {\n    const previousValue = values[i - 1];\n    const spacing = i / total;\n    const segmentEnd = (i + 1) / total;\n    const randomVariation = spacing + (segmentEnd - spacing) * Math.random();\n    // Mix the even spacing and random variation based on the randomness parameter\n    const randomValue = spacing * (1 - randomness) + randomVariation * randomness;\n    values.push(clamp(randomValue, previousValue, 1));\n  }\n  values.push(1);\n  return linear(...values);\n};\n\n// Easing functions adapted from http://www.robertpenner.com/ease © Robert Penner\n\n/**\n * @callback PowerEasing\n * @param {Number|String} [power=1.675]\n * @return {EasingFunction}\n */\n\n/**\n * @callback BackEasing\n * @param {Number|String} [overshoot=1.70158]\n * @return {EasingFunction}\n */\n\n/**\n * @callback ElasticEasing\n * @param {Number|String} [amplitude=1]\n * @param {Number|String} [period=.3]\n * @return {EasingFunction}\n */\n\n/**\n * @callback EaseFactory\n * @param {Number|String} [paramA]\n * @param {Number|String} [paramB]\n * @return {EasingFunction|Number}\n */\n\n/** @typedef {PowerEasing|BackEasing|ElasticEasing} EasesFactory */\n\nconst halfPI = PI / 2;\nconst doublePI = PI * 2;\n/** @type {PowerEasing} */\nconst easeInPower = (p = 1.68) => t => pow(t, +p);\n\n/** @type {Record<String, EasesFactory|EasingFunction>} */\nconst easeInFunctions = {\n  [emptyString]: easeInPower,\n  Quad: easeInPower(2),\n  Cubic: easeInPower(3),\n  Quart: easeInPower(4),\n  Quint: easeInPower(5),\n  /** @type {EasingFunction} */\n  Sine: t => 1 - cos(t * halfPI),\n  /** @type {EasingFunction} */\n  Circ: t => 1 - sqrt(1 - t * t),\n  /** @type {EasingFunction} */\n  Expo: t => t ? pow(2, 10 * t - 10) : 0,\n  /** @type {EasingFunction} */\n  Bounce: t => {\n    let pow2, b = 4;\n    while (t < ((pow2 = pow(2, --b)) - 1) / 11);\n    return 1 / pow(4, 3 - b) - 7.5625 * pow((pow2 * 3 - 2) / 22 - t, 2);\n  },\n  /** @type {BackEasing} */\n  Back: (overshoot = 1.70158) => t => (+overshoot + 1) * t * t * t - +overshoot * t * t,\n  /** @type {ElasticEasing} */\n  Elastic: (amplitude = 1, period = .3) => {\n    const a = clamp(+amplitude, 1, 10);\n    const p = clamp(+period, minValue, 2);\n    const s = (p / doublePI) * asin(1 / a);\n    const e = doublePI / p;\n    return t => t === 0 || t === 1 ? t : -a * pow(2, -10 * (1 - t)) * sin(((1 - t) - s) * e);\n  }\n};\n\n/**\n * @callback EaseType\n * @param {EasingFunction} Ease\n * @return {EasingFunction}\n */\n\n/** @type {Record<String, EaseType>} */\nconst easeTypes = {\n  in: easeIn => t => easeIn(t),\n  out: easeIn => t => 1 - easeIn(1 - t),\n  inOut: easeIn => t => t < .5 ? easeIn(t * 2) / 2 : 1 - easeIn(t * -2 + 2) / 2,\n  outIn: easeIn => t => t < .5 ? (1 - easeIn(1 - t * 2)) / 2 : (easeIn(t * 2 - 1) + 1) / 2,\n};\n\n/**\n * @param  {String} string\n * @param  {Record<String, EasesFactory|EasingFunction>} easesFunctions\n * @param  {Object} easesLookups\n * @return {EasingFunction}\n */\nconst parseEaseString = (string, easesFunctions, easesLookups) => {\n  if (easesLookups[string]) return easesLookups[string];\n  if (string.indexOf('(') <= -1) {\n    const hasParams = easeTypes[string] || string.includes('Back') || string.includes('Elastic');\n    const parsedFn = /** @type {EasingFunction} */(hasParams ? /** @type {EasesFactory} */(easesFunctions[string])() : easesFunctions[string]);\n    return parsedFn ? easesLookups[string] = parsedFn : none;\n  } else {\n    const split = string.slice(0, -1).split('(');\n    const parsedFn = /** @type {EasesFactory} */(easesFunctions[split[0]]);\n    return parsedFn ? easesLookups[string] = parsedFn(...split[1].split(',')) : none;\n  }\n};\n\n/**\n * @typedef  {Object} EasesFunctions\n * @property {typeof linear} linear\n * @property {typeof irregular} irregular\n * @property {typeof steps} steps\n * @property {typeof cubicBezier} cubicBezier\n * @property {PowerEasing} in\n * @property {PowerEasing} out\n * @property {PowerEasing} inOut\n * @property {PowerEasing} outIn\n * @property {EasingFunction} inQuad\n * @property {EasingFunction} outQuad\n * @property {EasingFunction} inOutQuad\n * @property {EasingFunction} outInQuad\n * @property {EasingFunction} inCubic\n * @property {EasingFunction} outCubic\n * @property {EasingFunction} inOutCubic\n * @property {EasingFunction} outInCubic\n * @property {EasingFunction} inQuart\n * @property {EasingFunction} outQuart\n * @property {EasingFunction} inOutQuart\n * @property {EasingFunction} outInQuart\n * @property {EasingFunction} inQuint\n * @property {EasingFunction} outQuint\n * @property {EasingFunction} inOutQuint\n * @property {EasingFunction} outInQuint\n * @property {EasingFunction} inSine\n * @property {EasingFunction} outSine\n * @property {EasingFunction} inOutSine\n * @property {EasingFunction} outInSine\n * @property {EasingFunction} inCirc\n * @property {EasingFunction} outCirc\n * @property {EasingFunction} inOutCirc\n * @property {EasingFunction} outInCirc\n * @property {EasingFunction} inExpo\n * @property {EasingFunction} outExpo\n * @property {EasingFunction} inOutExpo\n * @property {EasingFunction} outInExpo\n * @property {EasingFunction} inBounce\n * @property {EasingFunction} outBounce\n * @property {EasingFunction} inOutBounce\n * @property {EasingFunction} outInBounce\n * @property {BackEasing} inBack\n * @property {BackEasing} outBack\n * @property {BackEasing} inOutBack\n * @property {BackEasing} outInBack\n * @property {ElasticEasing} inElastic\n * @property {ElasticEasing} outElastic\n * @property {ElasticEasing} inOutElastic\n * @property {ElasticEasing} outInElastic\n */\n\nconst eases = (/*#__PURE__*/ (() => {\n  const list = { linear, irregular, steps, cubicBezier };\n  for (let type in easeTypes) {\n    for (let name in easeInFunctions) {\n      const easeIn = easeInFunctions[name];\n      const easeType = easeTypes[type];\n      list[type + name] = /** @type {EasesFactory|EasingFunction} */(\n        name === emptyString || name === 'Back' || name === 'Elastic' ?\n        (a, b) => easeType(/** @type {EasesFactory} */(easeIn)(a, b)) :\n        easeType(/** @type {EasingFunction} */(easeIn))\n      );\n    }\n  }\n  return /** @type {EasesFunctions} */(list);\n})());\n\n/** @type {Record<String, EasingFunction>} */\nconst JSEasesLookups = { linear: none };\n\n/**\n * @param  {EasingParam} ease\n * @return {EasingFunction}\n */\nconst parseEasings = ease => isFnc(ease) ? ease :\n  isStr(ease) ? parseEaseString(/** @type {String} */(ease), eases, JSEasesLookups) :\n  none;\n\n\n\n\nconst propertyNamesCache = {};\n\n/**\n * @param  {String} propertyName\n * @param  {Target} target\n * @param  {tweenTypes} tweenType\n * @return {String}\n */\nconst sanitizePropertyName = (propertyName, target, tweenType) => {\n  if (tweenType === tweenTypes.TRANSFORM) {\n    const t = shortTransforms.get(propertyName);\n    return t ? t : propertyName;\n  } else if (\n    tweenType === tweenTypes.CSS ||\n    // Handle special cases where properties like \"strokeDashoffset\" needs to be set as \"stroke-dashoffset\"\n    // but properties like \"baseFrequency\" should stay in lowerCamelCase\n    (tweenType === tweenTypes.ATTRIBUTE && (isSvg(target) && propertyName in /** @type {DOMTarget} */(target).style))\n  ) {\n    const cachedPropertyName = propertyNamesCache[propertyName];\n    if (cachedPropertyName) {\n      return cachedPropertyName;\n    } else {\n      const lowerCaseName = propertyName ? toLowerCase(propertyName) : propertyName;\n      propertyNamesCache[propertyName] = lowerCaseName;\n      return lowerCaseName;\n    }\n  } else {\n    return propertyName;\n  }\n};\n\n\n\n\nconst angleUnitsMap = { 'deg': 1, 'rad': 180 / PI, 'turn': 360 };\nconst convertedValuesCache = {};\n\n/**\n * @param  {DOMTarget} el\n * @param  {TweenDecomposedValue} decomposedValue\n * @param  {String} unit\n * @param  {Boolean} [force]\n * @return {TweenDecomposedValue}\n */\nconst convertValueUnit = (el, decomposedValue, unit, force = false) => {\n  const currentUnit = decomposedValue.u;\n  const currentNumber = decomposedValue.n;\n  if (decomposedValue.t === valueTypes.UNIT && currentUnit === unit) { // TODO: Check if checking against the same unit string is necessary\n    return decomposedValue;\n  }\n  const cachedKey = currentNumber + currentUnit + unit;\n  const cached = convertedValuesCache[cachedKey];\n  if (!isUnd(cached) && !force) {\n    decomposedValue.n = cached;\n  } else {\n    let convertedValue;\n    if (currentUnit in angleUnitsMap) {\n      convertedValue = currentNumber * angleUnitsMap[currentUnit] / angleUnitsMap[unit];\n    } else {\n      const baseline = 100;\n      const tempEl = /** @type {DOMTarget} */(el.cloneNode());\n      const parentNode = el.parentNode;\n      const parentEl = (parentNode && (parentNode !== doc)) ? parentNode : doc.body;\n      parentEl.appendChild(tempEl);\n      const elStyle = tempEl.style;\n      elStyle.width = baseline + currentUnit;\n      const currentUnitWidth = /** @type {HTMLElement} */(tempEl).offsetWidth || baseline;\n      elStyle.width = baseline + unit;\n      const newUnitWidth = /** @type {HTMLElement} */(tempEl).offsetWidth || baseline;\n      const factor = currentUnitWidth / newUnitWidth;\n      parentEl.removeChild(tempEl);\n      convertedValue = factor * currentNumber;\n    }\n    decomposedValue.n = convertedValue;\n    convertedValuesCache[cachedKey] = convertedValue;\n  }\n  decomposedValue.t === valueTypes.UNIT;\n  decomposedValue.u = unit;\n  return decomposedValue;\n};\n\n\n\n\n/**\n * @template {Renderable} T\n * @param {T} renderable\n * @return {T}\n */\nconst cleanInlineStyles = renderable => {\n  // Allow cleanInlineStyles() to be called on timelines\n  if (renderable._hasChildren) {\n    forEachChildren(renderable, cleanInlineStyles, true);\n  } else {\n    const animation = /** @type {JSAnimation} */(renderable);\n    animation.pause();\n    forEachChildren(animation, (/** @type {Tween} */tween) => {\n      const tweenProperty = tween.property;\n      const tweenTarget = tween.target;\n      if (tweenTarget[isDomSymbol]) {\n        const targetStyle = /** @type {DOMTarget} */(tweenTarget).style;\n        const originalInlinedValue = animation._inlineStyles[tweenProperty];\n        if (tween._tweenType === tweenTypes.TRANSFORM) {\n          const cachedTransforms = tweenTarget[transformsSymbol];\n          if (isUnd(originalInlinedValue) || originalInlinedValue === emptyString) {\n            delete cachedTransforms[tweenProperty];\n          } else {\n            cachedTransforms[tweenProperty] = originalInlinedValue;\n          }\n          if (tween._renderTransforms) {\n            if (!Object.keys(cachedTransforms).length) {\n              targetStyle.removeProperty('transform');\n            } else {\n              let str = emptyString;\n              for (let key in cachedTransforms) {\n                str += transformsFragmentStrings[key] + cachedTransforms[key] + ') ';\n              }\n              targetStyle.transform = str;\n            }\n          }\n        } else {\n          if (isUnd(originalInlinedValue) || originalInlinedValue === emptyString) {\n            targetStyle.removeProperty(tweenProperty);\n          } else {\n            targetStyle[tweenProperty] = originalInlinedValue;\n          }\n        }\n        if (animation._tail === tween) {\n          animation.targets.forEach(t => {\n            if (t.getAttribute && t.getAttribute('style') === emptyString) {\n              t.removeAttribute('style');\n            }          });\n        }\n      }\n    });\n  }\n  return renderable;\n};\n\n// Defines decomposed values target objects only once and mutate their properties later to avoid GC\n// TODO: Maybe move the objects creation to values.js and use the decompose function to create the base object\nconst fromTargetObject = createDecomposedValueTargetObject();\nconst toTargetObject = createDecomposedValueTargetObject();\nconst toFunctionStore = { func: null };\nconst keyframesTargetArray = [null];\nconst fastSetValuesArray = [null, null];\n/** @type {TweenKeyValue} */\nconst keyObjectTarget = { to: null };\n\nlet tweenId = 0;\nlet keyframes;\n/** @type {TweenParamsOptions & TweenValues} */\nlet key;\n\n/**\n * @param {DurationKeyframes | PercentageKeyframes} keyframes\n * @param {AnimationParams} parameters\n * @return {AnimationParams}\n */\nconst generateKeyframes = (keyframes, parameters) => {\n  /** @type {AnimationParams} */\n  const properties = {};\n  if (isArr(keyframes)) {\n    const propertyNames = [].concat(.../** @type {DurationKeyframes} */(keyframes).map(key => Object.keys(key))).filter(isKey);\n    for (let i = 0, l = propertyNames.length; i < l; i++) {\n      const propName = propertyNames[i];\n      const propArray = /** @type {DurationKeyframes} */(keyframes).map(key => {\n        /** @type {TweenKeyValue} */\n        const newKey = {};\n        for (let p in key) {\n          const keyValue = /** @type {TweenPropValue} */(key[p]);\n          if (isKey(p)) {\n            if (p === propName) {\n              newKey.to = keyValue;\n            }\n          } else {\n            newKey[p] = keyValue;\n          }\n        }\n        return newKey;\n      });\n      properties[propName] = /** @type {ArraySyntaxValue} */(propArray);\n    }\n\n  } else {\n    const totalDuration = /** @type {Number} */(setValue(parameters.duration, globals.defaults.duration));\n    const keys = Object.keys(keyframes)\n    .map(key => { return {o: parseFloat(key) / 100, p: keyframes[key]} })\n    .sort((a, b) => a.o - b.o);\n    keys.forEach(key => {\n      const offset = key.o;\n      const prop = key.p;\n      for (let name in prop) {\n        if (isKey(name)) {\n          let propArray = /** @type {Array} */(properties[name]);\n          if (!propArray) propArray = properties[name] = [];\n          const duration = offset * totalDuration;\n          let length = propArray.length;\n          let prevKey = propArray[length - 1];\n          const keyObj = { to: prop[name] };\n          let durProgress = 0;\n          for (let i = 0; i < length; i++) {\n            durProgress += propArray[i].duration;\n          }\n          if (length === 1) {\n            keyObj.from = prevKey.to;\n          }\n          if (prop.ease) {\n            keyObj.ease = prop.ease;\n          }\n          keyObj.duration = duration - (length ? durProgress : 0);\n          propArray.push(keyObj);\n        }\n      }\n      return key;\n    });\n\n    for (let name in properties) {\n      const propArray = /** @type {Array} */(properties[name]);\n      let prevEase;\n      // let durProgress = 0\n      for (let i = 0, l = propArray.length; i < l; i++) {\n        const prop = propArray[i];\n        // Emulate WAPPI easing parameter position\n        const currentEase = prop.ease;\n        prop.ease = prevEase ? prevEase : undefined;\n        prevEase = currentEase;\n        // durProgress += prop.duration;\n        // if (i === l - 1 && durProgress !== totalDuration) {\n        //   propArray.push({ from: prop.to, ease: prop.ease, duration: totalDuration - durProgress })\n        // }\n      }\n      if (!propArray[0].duration) {\n        propArray.shift();\n      }\n    }\n\n  }\n\n  return properties;\n};\n\nclass JSAnimation extends Timer {\n  /**\n   * @param {TargetsParam} targets\n   * @param {AnimationParams} parameters\n   * @param {Timeline} [parent]\n   * @param {Number} [parentPosition]\n   * @param {Boolean} [fastSet=false]\n   * @param {Number} [index=0]\n   * @param {Number} [length=0]\n   */\n  constructor(\n    targets,\n    parameters,\n    parent,\n    parentPosition,\n    fastSet = false,\n    index = 0,\n    length = 0\n  ) {\n\n    super(/** @type {TimerParams&AnimationParams} */(parameters), parent, parentPosition);\n\n    const parsedTargets = registerTargets(targets);\n    const targetsLength = parsedTargets.length;\n\n    // If the parameters object contains a \"keyframes\" property, convert all the keyframes values to regular properties\n\n    const kfParams = /** @type {AnimationParams} */(parameters).keyframes;\n    const params = /** @type {AnimationParams} */(kfParams ? mergeObjects(generateKeyframes(/** @type {DurationKeyframes} */(kfParams), parameters), parameters) : parameters);\n\n    const {\n      delay,\n      duration,\n      ease,\n      playbackEase,\n      modifier,\n      composition,\n      onRender,\n    } = params;\n\n    const animDefaults = parent ? parent.defaults : globals.defaults;\n    const animaPlaybackEase = setValue(playbackEase, animDefaults.playbackEase);\n    const animEase = animaPlaybackEase ? parseEasings(animaPlaybackEase) : null;\n    const hasSpring = !isUnd(ease) && !isUnd(/** @type {Spring} */(ease).ease);\n    const tEasing = hasSpring ? /** @type {Spring} */(ease).ease : setValue(ease, animEase ? 'linear' : animDefaults.ease);\n    const tDuration = hasSpring ? /** @type {Spring} */(ease).duration : setValue(duration, animDefaults.duration);\n    const tDelay = setValue(delay, animDefaults.delay);\n    const tModifier = modifier || animDefaults.modifier;\n    // If no composition is defined and the targets length is high (>= 1000) set the composition to 'none' (0) for faster tween creation\n    const tComposition = isUnd(composition) && targetsLength >= K ? compositionTypes.none : !isUnd(composition) ? composition : animDefaults.composition;\n    // TODO: Do not create an empty object until we know the animation will generate inline styles\n    const animInlineStyles = {};\n    // const absoluteOffsetTime = this._offset;\n    const absoluteOffsetTime = this._offset + (parent ? parent._offset : 0);\n\n    let iterationDuration = NaN;\n    let iterationDelay = NaN;\n    let animationAnimationLength = 0;\n    let shouldTriggerRender = 0;\n\n    for (let targetIndex = 0; targetIndex < targetsLength; targetIndex++) {\n\n      const target = parsedTargets[targetIndex];\n      const ti = index || targetIndex;\n      const tl = length || targetsLength;\n\n      let lastTransformGroupIndex = NaN;\n      let lastTransformGroupLength = NaN;\n\n      for (let p in params) {\n\n        if (isKey(p)) {\n\n          const tweenType = getTweenType(target, p);\n\n          const propName = sanitizePropertyName(p, target, tweenType);\n\n          let propValue = params[p];\n\n          const isPropValueArray = isArr(propValue);\n\n          if (fastSet && !isPropValueArray) {\n            fastSetValuesArray[0] = propValue;\n            fastSetValuesArray[1] = propValue;\n            propValue = fastSetValuesArray;\n          }\n\n          // TODO: Allow nested keyframes inside ObjectValue value (prop: { to: [.5, 1, .75, 2, 3] })\n          // Normalize property values to valid keyframe syntax:\n          // [x, y] to [{to: [x, y]}] or {to: x} to [{to: x}] or keep keys syntax [{}, {}, {}...]\n          // const keyframes = isArr(propValue) ? propValue.length === 2 && !isObj(propValue[0]) ? [{ to: propValue }] : propValue : [propValue];\n          if (isPropValueArray) {\n            const arrayLength = /** @type {Array} */(propValue).length;\n            const isNotObjectValue = !isObj(propValue[0]);\n            // Convert [x, y] to [{to: [x, y]}]\n            if (arrayLength === 2 && isNotObjectValue) {\n              keyObjectTarget.to = /** @type {TweenParamValue} */(/** @type {unknown} */(propValue));\n              keyframesTargetArray[0] = keyObjectTarget;\n              keyframes = keyframesTargetArray;\n            // Convert [x, y, z] to [[x, y], z]\n            } else if (arrayLength > 2 && isNotObjectValue) {\n              keyframes = [];\n              /** @type {Array.<Number>} */(propValue).forEach((v, i) => {\n                if (!i) {\n                  fastSetValuesArray[0] = v;\n                } else if (i === 1) {\n                  fastSetValuesArray[1] = v;\n                  keyframes.push(fastSetValuesArray);\n                } else {\n                  keyframes.push(v);\n                }\n              });\n            } else {\n              keyframes = /** @type {Array.<TweenKeyValue>} */(propValue);\n            }\n          } else {\n            keyframesTargetArray[0] = propValue;\n            keyframes = keyframesTargetArray;\n          }\n\n          let siblings = null;\n          let prevTween = null;\n          let firstTweenChangeStartTime = NaN;\n          let lastTweenChangeEndTime = 0;\n          let tweenIndex = 0;\n\n          for (let l = keyframes.length; tweenIndex < l; tweenIndex++) {\n\n            const keyframe = keyframes[tweenIndex];\n\n            if (isObj(keyframe)) {\n              key = keyframe;\n            } else {\n              keyObjectTarget.to = /** @type {TweenParamValue} */(keyframe);\n              key = keyObjectTarget;\n            }\n\n            toFunctionStore.func = null;\n\n            const computedToValue = getFunctionValue(key.to, target, ti, tl, toFunctionStore);\n\n            let tweenToValue;\n            // Allows function based values to return an object syntax value ({to: v})\n            if (isObj(computedToValue) && !isUnd(computedToValue.to)) {\n              key = computedToValue;\n              tweenToValue = computedToValue.to;\n            } else {\n              tweenToValue = computedToValue;\n            }\n            const tweenFromValue = getFunctionValue(key.from, target, ti, tl);\n            const keyEasing = key.ease;\n            const hasSpring = !isUnd(keyEasing) && !isUnd(/** @type {Spring} */(keyEasing).ease);\n            // Easing are treated differently and don't accept function based value to prevent having to pass a function wrapper that returns an other function all the time\n            const tweenEasing = hasSpring ? /** @type {Spring} */(keyEasing).ease : keyEasing || tEasing;\n            // Calculate default individual keyframe duration by dividing the tl of keyframes\n            const tweenDuration = hasSpring ? /** @type {Spring} */(keyEasing).duration : getFunctionValue(setValue(key.duration, (l > 1 ? getFunctionValue(tDuration, target, ti, tl) / l : tDuration)), target, ti, tl);\n            // Default delay value should only be applied to the first tween\n            const tweenDelay = getFunctionValue(setValue(key.delay, (!tweenIndex ? tDelay : 0)), target, ti, tl);\n            const computedComposition = getFunctionValue(setValue(key.composition, tComposition), target, ti, tl);\n            const tweenComposition = isNum(computedComposition) ? computedComposition : compositionTypes[computedComposition];\n            // Modifiers are treated differently and don't accept function based value to prevent having to pass a function wrapper\n            const tweenModifier = key.modifier || tModifier;\n            const hasFromvalue = !isUnd(tweenFromValue);\n            const hasToValue = !isUnd(tweenToValue);\n            const isFromToArray = isArr(tweenToValue);\n            const isFromToValue = isFromToArray || (hasFromvalue && hasToValue);\n            const tweenStartTime = prevTween ? lastTweenChangeEndTime + tweenDelay : tweenDelay;\n            const absoluteStartTime = absoluteOffsetTime + tweenStartTime;\n\n            // Force a onRender callback if the animation contains at least one from value and autoplay is set to false\n            if (!shouldTriggerRender && (hasFromvalue || isFromToArray)) shouldTriggerRender = 1;\n\n            let prevSibling = prevTween;\n\n            if (tweenComposition !== compositionTypes.none) {\n              if (!siblings) siblings = getTweenSiblings(target, propName);\n              let nextSibling = siblings._head;\n              // Iterate trough all the next siblings until we find a sibling with an equal or inferior start time\n              while (nextSibling && !nextSibling._isOverridden && nextSibling._absoluteStartTime <= absoluteStartTime) {\n                prevSibling = nextSibling;\n                nextSibling = nextSibling._nextRep;\n                // Overrides all the next siblings if the next sibling starts at the same time of after as the new tween start time\n                if (nextSibling && nextSibling._absoluteStartTime >= absoluteStartTime) {\n                  while (nextSibling) {\n                    overrideTween(nextSibling);\n                    // This will ends both the current while loop and the upper one once all the next sibllings have been overriden\n                    nextSibling = nextSibling._nextRep;\n                  }\n                }\n              }\n            }\n\n            // Decompose values\n            if (isFromToValue) {\n              decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[0], target, ti, tl) : tweenFromValue, fromTargetObject);\n              decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[1], target, ti, tl, toFunctionStore) : tweenToValue, toTargetObject);\n              if (fromTargetObject.t === valueTypes.NUMBER) {\n                if (prevSibling) {\n                  if (prevSibling._valueType === valueTypes.UNIT) {\n                    fromTargetObject.t = valueTypes.UNIT;\n                    fromTargetObject.u = prevSibling._unit;\n                  }\n                } else {\n                  decomposeRawValue(\n                    getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles),\n                    decomposedOriginalValue\n                  );\n                  if (decomposedOriginalValue.t === valueTypes.UNIT) {\n                    fromTargetObject.t = valueTypes.UNIT;\n                    fromTargetObject.u = decomposedOriginalValue.u;\n                  }\n                }\n              }\n            } else {\n              if (hasToValue) {\n                decomposeRawValue(tweenToValue, toTargetObject);\n              } else {\n                if (prevTween) {\n                  decomposeTweenValue(prevTween, toTargetObject);\n                } else {\n                  // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline\n                  decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value :\n                  getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles), toTargetObject);\n                }\n              }\n              if (hasFromvalue) {\n                decomposeRawValue(tweenFromValue, fromTargetObject);\n              } else {\n                if (prevTween) {\n                  decomposeTweenValue(prevTween, fromTargetObject);\n                } else {\n                  decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value :\n                  // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline\n                  getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles), fromTargetObject);\n                }\n              }\n            }\n\n            // Apply operators\n            if (fromTargetObject.o) {\n              fromTargetObject.n = getRelativeValue(\n                !prevSibling ? decomposeRawValue(\n                  getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles),\n                  decomposedOriginalValue\n                ).n : prevSibling._toNumber,\n                fromTargetObject.n,\n                fromTargetObject.o\n              );\n            }\n\n            if (toTargetObject.o) {\n              toTargetObject.n = getRelativeValue(fromTargetObject.n, toTargetObject.n, toTargetObject.o);\n            }\n\n            // Values omogenisation in cases of type difference between \"from\" and \"to\"\n            if (fromTargetObject.t !== toTargetObject.t) {\n              if (fromTargetObject.t === valueTypes.COMPLEX || toTargetObject.t === valueTypes.COMPLEX) {\n                const complexValue = fromTargetObject.t === valueTypes.COMPLEX ? fromTargetObject : toTargetObject;\n                const notComplexValue = fromTargetObject.t === valueTypes.COMPLEX ? toTargetObject : fromTargetObject;\n                notComplexValue.t = valueTypes.COMPLEX;\n                notComplexValue.s = cloneArray(complexValue.s);\n                notComplexValue.d = complexValue.d.map(() => notComplexValue.n);\n              } else if (fromTargetObject.t === valueTypes.UNIT || toTargetObject.t === valueTypes.UNIT) {\n                const unitValue = fromTargetObject.t === valueTypes.UNIT ? fromTargetObject : toTargetObject;\n                const notUnitValue = fromTargetObject.t === valueTypes.UNIT ? toTargetObject : fromTargetObject;\n                notUnitValue.t = valueTypes.UNIT;\n                notUnitValue.u = unitValue.u;\n              } else if (fromTargetObject.t === valueTypes.COLOR || toTargetObject.t === valueTypes.COLOR) {\n                const colorValue = fromTargetObject.t === valueTypes.COLOR ? fromTargetObject : toTargetObject;\n                const notColorValue = fromTargetObject.t === valueTypes.COLOR ? toTargetObject : fromTargetObject;\n                notColorValue.t = valueTypes.COLOR;\n                notColorValue.s = colorValue.s;\n                notColorValue.d = [0, 0, 0, 1];\n              }\n            }\n\n            // Unit conversion\n            if (fromTargetObject.u !== toTargetObject.u) {\n              let valueToConvert = toTargetObject.u ? fromTargetObject : toTargetObject;\n              valueToConvert = convertValueUnit(/** @type {DOMTarget} */(target), valueToConvert, toTargetObject.u ? toTargetObject.u : fromTargetObject.u, false);\n              // TODO:\n              // convertValueUnit(target, to.u ? from : to, to.u ? to.u : from.u);\n            }\n\n            // Fill in non existing complex values\n            if (toTargetObject.d && fromTargetObject.d && (toTargetObject.d.length !== fromTargetObject.d.length)) {\n              const longestValue = fromTargetObject.d.length > toTargetObject.d.length ? fromTargetObject : toTargetObject;\n              const shortestValue = longestValue === fromTargetObject ? toTargetObject : fromTargetObject;\n              // TODO: Check if n should be used instead of 0 for default complex values\n              shortestValue.d = longestValue.d.map((_, i) => isUnd(shortestValue.d[i]) ? 0 : shortestValue.d[i]);\n              shortestValue.s = cloneArray(longestValue.s);\n            }\n\n            // Tween factory\n\n            // Rounding is necessary here to minimize floating point errors\n            const tweenUpdateDuration = round(+tweenDuration || minValue, 12);\n\n            /** @type {Tween} */\n            const tween = {\n              parent: this,\n              id: tweenId++,\n              property: propName,\n              target: target,\n              _value: null,\n              _func: toFunctionStore.func,\n              _ease: parseEasings(tweenEasing),\n              _fromNumbers: cloneArray(fromTargetObject.d),\n              _toNumbers: cloneArray(toTargetObject.d),\n              _strings: cloneArray(toTargetObject.s),\n              _fromNumber: fromTargetObject.n,\n              _toNumber: toTargetObject.n,\n              _numbers: cloneArray(fromTargetObject.d), // For additive tween and animatables\n              _number: fromTargetObject.n, // For additive tween and animatables\n              _unit: toTargetObject.u,\n              _modifier: tweenModifier,\n              _currentTime: 0,\n              _startTime: tweenStartTime,\n              _delay: +tweenDelay,\n              _updateDuration: tweenUpdateDuration,\n              _changeDuration: tweenUpdateDuration,\n              _absoluteStartTime: absoluteStartTime,\n              // NOTE: Investigate bit packing to stores ENUM / BOOL\n              _tweenType: tweenType,\n              _valueType: toTargetObject.t,\n              _composition: tweenComposition,\n              _isOverlapped: 0,\n              _isOverridden: 0,\n              _renderTransforms: 0,\n              _prevRep: null, // For replaced tween\n              _nextRep: null, // For replaced tween\n              _prevAdd: null, // For additive tween\n              _nextAdd: null, // For additive tween\n              _prev: null,\n              _next: null,\n            };\n\n            if (tweenComposition !== compositionTypes.none) {\n              composeTween(tween, siblings);\n            }\n\n            if (isNaN(firstTweenChangeStartTime)) {\n              firstTweenChangeStartTime = tween._startTime;\n            }\n            // Rounding is necessary here to minimize floating point errors\n            lastTweenChangeEndTime = round(tweenStartTime + tweenUpdateDuration, 12);\n            prevTween = tween;\n            animationAnimationLength++;\n\n            addChild(this, tween);\n\n          }\n\n          // Update animation timings with the added tweens properties\n\n          if (isNaN(iterationDelay) || firstTweenChangeStartTime < iterationDelay) {\n            iterationDelay = firstTweenChangeStartTime;\n          }\n\n          if (isNaN(iterationDuration) || lastTweenChangeEndTime > iterationDuration) {\n            iterationDuration = lastTweenChangeEndTime;\n          }\n\n          // TODO: Find a way to inline tween._renderTransforms = 1 here\n          if (tweenType === tweenTypes.TRANSFORM) {\n            lastTransformGroupIndex = animationAnimationLength - tweenIndex;\n            lastTransformGroupLength = animationAnimationLength;\n          }\n\n        }\n\n      }\n\n      // Set _renderTransforms to last transform property to correctly render the transforms list\n      if (!isNaN(lastTransformGroupIndex)) {\n        let i = 0;\n        forEachChildren(this, (/** @type {Tween} */tween) => {\n          if (i >= lastTransformGroupIndex && i < lastTransformGroupLength) {\n            tween._renderTransforms = 1;\n            if (tween._composition === compositionTypes.blend) {\n              forEachChildren(additive.animation, (/** @type {Tween} */additiveTween) => {\n                if (additiveTween.id === tween.id) {\n                  additiveTween._renderTransforms = 1;\n                }\n              });\n            }\n          }\n          i++;\n        });\n      }\n\n    }\n\n    if (!targetsLength) {\n      console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);\n    }\n\n    if (iterationDelay) {\n      forEachChildren(this, (/** @type {Tween} */tween) => {\n        // If (startTime - delay) equals 0, this means the tween is at the begining of the animation so we need to trim the delay too\n        if (!(tween._startTime - tween._delay)) {\n          tween._delay -= iterationDelay;\n        }\n        tween._startTime -= iterationDelay;\n      });\n      iterationDuration -= iterationDelay;\n    } else {\n      iterationDelay = 0;\n    }\n\n    // Prevents iterationDuration to be NaN if no valid animatable props have been provided\n    // Prevents _iterationCount to be NaN if no valid animatable props have been provided\n    if (!iterationDuration) {\n      iterationDuration = minValue;\n      this.iterationCount = 0;\n    }\n    /** @type {TargetsArray} */\n    this.targets = parsedTargets;\n    /** @type {Number} */\n    this.duration = iterationDuration === minValue ? minValue : clampInfinity(((iterationDuration + this._loopDelay) * this.iterationCount) - this._loopDelay) || minValue;\n    /** @type {Callback<this>} */\n    this.onRender = onRender || animDefaults.onRender;\n    /** @type {EasingFunction} */\n    this._ease = animEase;\n    /** @type {Number} */\n    this._delay = iterationDelay;\n    // NOTE: I'm keeping delay values separated from offsets in timelines because delays can override previous tweens and it could be confusing to debug a timeline with overridden tweens and no associated visible delays.\n    // this._delay = parent ? 0 : iterationDelay;\n    // this._offset += parent ? iterationDelay : 0;\n    /** @type {Number} */\n    this.iterationDuration = iterationDuration;\n    /** @type {{}} */\n    this._inlineStyles = animInlineStyles;\n\n    if (!this._autoplay && shouldTriggerRender) this.onRender(this);\n  }\n\n  /**\n   * @param  {Number} newDuration\n   * @return {this}\n   */\n  stretch(newDuration) {\n    const currentDuration = this.duration;\n    if (currentDuration === normalizeTime(newDuration)) return this;\n    const timeScale = newDuration / currentDuration;\n    // NOTE: Find a better way to handle the stretch of an animation after stretch = 0\n    forEachChildren(this, (/** @type {Tween} */tween) => {\n      // Rounding is necessary here to minimize floating point errors\n      tween._updateDuration = normalizeTime(tween._updateDuration * timeScale);\n      tween._changeDuration = normalizeTime(tween._changeDuration * timeScale);\n      tween._currentTime *= timeScale;\n      tween._startTime *= timeScale;\n      tween._absoluteStartTime *= timeScale;\n    });\n    return super.stretch(newDuration);\n  }\n\n  /**\n   * @return {this}\n   */\n  refresh() {\n    forEachChildren(this, (/** @type {Tween} */tween) => {\n      const tweenFunc = tween._func;\n      if (tweenFunc) {\n        const ogValue = getOriginalAnimatableValue(tween.target, tween.property, tween._tweenType);\n        decomposeRawValue(ogValue, decomposedOriginalValue);\n        decomposeRawValue(tweenFunc(), toTargetObject);\n        tween._fromNumbers = cloneArray(decomposedOriginalValue.d);\n        tween._fromNumber = decomposedOriginalValue.n;\n        tween._toNumbers = cloneArray(toTargetObject.d);\n        tween._strings = cloneArray(toTargetObject.s);\n        // Make sure to apply relative operators https://github.com/juliangarnier/anime/issues/1025\n        tween._toNumber = toTargetObject.o ? getRelativeValue(decomposedOriginalValue.n, toTargetObject.n, toTargetObject.o) : toTargetObject.n;\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Cancel the animation and revert all the values affected by this animation to their original state\n   * @return {this}\n   */\n  revert() {\n    super.revert();\n    return cleanInlineStyles(this);\n  }\n\n  /**\n   * @param  {Callback<this>} [callback]\n   * @return {Promise}\n   */\n  then(callback) {\n    return super.then(callback);\n  }\n\n}\n\n/**\n * @param {TargetsParam} targets\n * @param {AnimationParams} parameters\n * @return {JSAnimation}\n */\nconst animate = (targets, parameters) => new JSAnimation(targets, parameters, null, 0, false).init();\n\n\n\n\n/**\n * Converts an easing function into a valid CSS linear() timing function string\n * @param {EasingFunction} fn\n * @param {number} [samples=100]\n * @returns {string} CSS linear() timing function\n */\nconst easingToLinear = (fn, samples = 100) => {\n  const points = [];\n  for (let i = 0; i <= samples; i++) points.push(fn(i / samples));\n  return `linear(${points.join(', ')})`;\n};\n\nconst WAAPIEasesLookups = {\n  in: 'ease-in',\n  out: 'ease-out',\n  inOut: 'ease-in-out',\n};\n\nconst WAAPIeases = /*#__PURE__*/(() => {\n  const list = {};\n  for (let type in easeTypes) list[type] = a => easeTypes[type](easeInPower(a));\n  return /** @type {Record<String, EasingFunction>} */(list);\n})();\n\n/**\n * @param  {EasingParam} ease\n * @return {String}\n */\nconst parseWAAPIEasing = (ease) => {\n  let parsedEase = WAAPIEasesLookups[ease];\n  if (parsedEase) return parsedEase;\n  parsedEase = 'linear';\n  if (isStr(ease)) {\n    if (\n      stringStartsWith(ease, 'linear') ||\n      stringStartsWith(ease, 'cubic-') ||\n      stringStartsWith(ease, 'steps') ||\n      stringStartsWith(ease, 'ease')\n    ) {\n      parsedEase = ease;\n    } else if (stringStartsWith(ease, 'cubicB')) {\n      parsedEase = toLowerCase(ease);\n    } else {\n      const parsed = parseEaseString(ease, WAAPIeases, WAAPIEasesLookups);\n      if (isFnc(parsed)) parsedEase = parsed === none ? 'linear' : easingToLinear(parsed);\n    }\n    WAAPIEasesLookups[ease] = parsedEase;\n  } else if (isFnc(ease)) {\n    const easing = easingToLinear(ease);\n    if (easing) parsedEase = easing;\n  } else if (/** @type {Spring} */(ease).ease) {\n    parsedEase = easingToLinear(/** @type {Spring} */(ease).ease);\n  }\n  return parsedEase;\n};\n\n/**\n * @typedef {String|Number|Array<String>|Array<Number>} WAAPITweenValue\n */\n\n/**\n * @callback WAAPIFunctionvalue\n * @param {DOMTarget} target - The animated target\n * @param {Number} index - The target index\n * @param {Number} length - The total number of animated targets\n * @return {WAAPITweenValue}\n */\n\n/**\n * @typedef {WAAPITweenValue|WAAPIFunctionvalue|Array<String|Number|WAAPIFunctionvalue>} WAAPIKeyframeValue\n */\n\n/**\n * @typedef {(animation: WAAPIAnimation) => void} WAAPICallback\n */\n\n/**\n * @typedef {Object} WAAPITweenOptions\n * @property {WAAPIKeyframeValue} [to]\n * @property {WAAPIKeyframeValue} [from]\n * @property {Number|WAAPIFunctionvalue} [duration]\n * @property {Number|WAAPIFunctionvalue} [delay]\n * @property {EasingParam} [ease]\n * @property {CompositeOperation} [composition]\n */\n\n/**\n * @typedef {Object} WAAPIAnimationOptions\n * @property {Number|Boolean} [loop]\n * @property {Boolean} [Reversed]\n * @property {Boolean} [Alternate]\n * @property {Boolean|ScrollObserver} [autoplay]\n * @property {Number} [playbackRate]\n * @property {Number|WAAPIFunctionvalue} [duration]\n * @property {Number|WAAPIFunctionvalue} [delay]\n * @property {EasingParam} [ease]\n * @property {CompositeOperation} [composition]\n * @property {WAAPICallback} [onComplete]\n */\n\n/**\n * @typedef {Record<String, WAAPIKeyframeValue | WAAPIAnimationOptions | Boolean | ScrollObserver | WAAPICallback | EasingParam | WAAPITweenOptions> & WAAPIAnimationOptions} WAAPIAnimationParams\n */\n\nconst transformsShorthands = ['x', 'y', 'z'];\nconst commonDefaultPXProperties = [\n  'perspective',\n  'width',\n  'height',\n  'margin',\n  'padding',\n  'top',\n  'right',\n  'bottom',\n  'left',\n  'borderWidth',\n  'fontSize',\n  'borderRadius',\n  ...transformsShorthands\n];\n\nconst validIndividualTransforms = /*#__PURE__*/ (() => [...transformsShorthands, ...validTransforms.filter(t => ['X', 'Y', 'Z'].some(axis => t.endsWith(axis)))])();\n\nlet transformsPropertiesRegistered = null;\n\nconst WAAPIAnimationsLookups = {\n  _head: null,\n  _tail: null,\n};\n\n/**\n * @param {DOMTarget} $el\n * @param {String} [property]\n * @param {WAAPIAnimation} [parent]\n */\nconst removeWAAPIAnimation = ($el, property, parent) => {\n  let nextLookup = WAAPIAnimationsLookups._head;\n  while (nextLookup) {\n    const next = nextLookup._next;\n    const matchTarget = nextLookup.$el === $el;\n    const matchProperty = !property || nextLookup.property === property;\n    const matchParent = !parent || nextLookup.parent === parent;\n    if (matchTarget && matchProperty && matchParent) {\n      const anim = nextLookup.animation;\n      try { anim.commitStyles(); } catch {}      anim.cancel();\n      removeChild(WAAPIAnimationsLookups, nextLookup);\n      const lookupParent = nextLookup.parent;\n      if (lookupParent) {\n        lookupParent._completed++;\n        if (lookupParent.animations.length === lookupParent._completed) {\n          lookupParent.completed = true;\n          if (!lookupParent.muteCallbacks) {\n            lookupParent.paused = true;\n            lookupParent.onComplete(lookupParent);\n            lookupParent._resolve(lookupParent);\n          }\n        }\n      }\n    }\n    nextLookup = next;\n  }\n};\n\n/**\n * @param {WAAPIAnimation} parent\n * @param {DOMTarget} $el\n * @param {String} property\n * @param {PropertyIndexedKeyframes} keyframes\n * @param {KeyframeAnimationOptions} params\n * @retun {Animation}\n */\nconst addWAAPIAnimation = (parent, $el, property, keyframes, params) => {\n  const animation = $el.animate(keyframes, params);\n  const animTotalDuration = params.delay + (+params.duration * params.iterations);\n  animation.playbackRate = parent._speed;\n  if (parent.paused) animation.pause();\n  if (parent.duration < animTotalDuration) {\n    parent.duration = animTotalDuration;\n    parent.controlAnimation = animation;\n  }\n  parent.animations.push(animation);\n  removeWAAPIAnimation($el, property);\n  addChild(WAAPIAnimationsLookups, { parent, animation, $el, property, _next: null, _prev: null });\n  const handleRemove = () => { removeWAAPIAnimation($el, property, parent); };\n  animation.onremove = handleRemove;\n  animation.onfinish = handleRemove;\n  return animation;\n};\n\n/**\n * @param  {String} propName\n * @param  {WAAPIKeyframeValue} value\n * @param  {DOMTarget} $el\n * @param  {Number} i\n * @param  {Number} targetsLength\n * @return {String}\n */\nconst normalizeTweenValue = (propName, value, $el, i, targetsLength) => {\n  let v = getFunctionValue(/** @type {any} */(value), $el, i, targetsLength);\n  if (!isNum(v)) return v;\n  if (commonDefaultPXProperties.includes(propName) || stringStartsWith(propName, 'translate')) return `${v}px`;\n  if (stringStartsWith(propName, 'rotate') || stringStartsWith(propName, 'skew')) return `${v}deg`;\n  return `${v}`;\n};\n\n/**\n * @param  {DOMTarget} $el\n * @param  {String} propName\n * @param  {WAAPIKeyframeValue} from\n * @param  {WAAPIKeyframeValue} to\n * @param  {Number} i\n * @param  {Number} targetsLength\n * @return {WAAPITweenValue}\n */\nconst parseIndividualTweenValue = ($el, propName, from, to, i, targetsLength) => {\n  /** @type {WAAPITweenValue} */\n  let tweenValue = '0';\n  const computedTo = !isUnd(to) ? normalizeTweenValue(propName, to, $el, i, targetsLength) : getComputedStyle($el)[propName];\n  if (!isUnd(from)) {\n    const computedFrom = normalizeTweenValue(propName, from, $el, i, targetsLength);\n    tweenValue = [computedFrom, computedTo];\n  } else {\n    tweenValue = isArr(to) ? to.map((/** @type {any} */v) => normalizeTweenValue(propName, v, $el, i, targetsLength)) : computedTo;\n  }\n  return tweenValue;\n};\n\nclass WAAPIAnimation {\n/**\n * @param {DOMTargetsParam} targets\n * @param {WAAPIAnimationParams} params\n */\n  constructor(targets, params) {\n\n    if (scope.current) scope.current.register(this);\n\n    // Skip the registration and fallback to no animation in case CSS.registerProperty is not supported\n    if (isNil(transformsPropertiesRegistered)) {\n      if (isBrowser && (isUnd(CSS) || !Object.hasOwnProperty.call(CSS, 'registerProperty'))) {\n        transformsPropertiesRegistered = false;\n      } else {\n        validTransforms.forEach(t => {\n          const isSkew = stringStartsWith(t, 'skew');\n          const isScale = stringStartsWith(t, 'scale');\n          const isRotate = stringStartsWith(t, 'rotate');\n          const isTranslate = stringStartsWith(t, 'translate');\n          const isAngle = isRotate || isSkew;\n          const syntax = isAngle ? '<angle>' : isScale ? \"<number>\" : isTranslate ? \"<length-percentage>\" : \"*\";\n          try {\n            CSS.registerProperty({\n              name: '--' + t,\n              syntax,\n              inherits: false,\n              initialValue: isTranslate ? '0px' : isAngle ? '0deg' : isScale ? '1' : '0',\n            });\n          } catch {}        });\n        transformsPropertiesRegistered = true;\n      }\n    }\n\n    const parsedTargets = registerTargets(targets);\n    const targetsLength = parsedTargets.length;\n\n    if (!targetsLength) {\n      console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);\n    }\n\n    const ease = setValue(params.ease, parseWAAPIEasing(globals.defaults.ease));\n    const spring = /** @type {Spring} */(ease).ease && ease;\n    const autoplay = setValue(params.autoplay, globals.defaults.autoplay);\n    const scroll = autoplay && /** @type {ScrollObserver} */(autoplay).link ? autoplay : false;\n    const alternate = params.alternate && /** @type {Boolean} */(params.alternate) === true;\n    const reversed = params.reversed && /** @type {Boolean} */(params.reversed) === true;\n    const loop = setValue(params.loop, globals.defaults.loop);\n    const iterations = /** @type {Number} */((loop === true || loop === Infinity) ? Infinity : isNum(loop) ? loop + 1 : 1);\n    /** @type {PlaybackDirection} */\n    const direction = alternate ? reversed ? 'alternate-reverse' : 'alternate' : reversed ? 'reverse' : 'normal';\n    /** @type {FillMode} */\n    const fill = 'forwards';\n    /** @type {String} */\n    const easing = parseWAAPIEasing(ease);\n    const timeScale = (globals.timeScale === 1 ? 1 : K);\n\n    /** @type {DOMTargetsArray}] */\n    this.targets = parsedTargets;\n    /** @type {Array<globalThis.Animation>}] */\n    this.animations = [];\n    /** @type {globalThis.Animation}] */\n    this.controlAnimation = null;\n    /** @type {Callback<this>} */\n    this.onComplete = params.onComplete || noop;\n    /** @type {Number} */\n    this.duration = 0;\n    /** @type {Boolean} */\n    this.muteCallbacks = false;\n    /** @type {Boolean} */\n    this.completed = false;\n    /** @type {Boolean} */\n    this.paused = !autoplay || scroll !== false;\n    /** @type {Boolean} */\n    this.reversed = reversed;\n    /** @type {Boolean|ScrollObserver} */\n    this.autoplay = autoplay;\n    /** @type {Number} */\n    this._speed = setValue(params.playbackRate, globals.defaults.playbackRate);\n    /** @type {Function} */\n    this._resolve = noop; // Used by .then()\n    /** @type {Number} */\n    this._completed = 0;\n    /** @type {Array<Object>}] */\n    this._inlineStyles = parsedTargets.map($el => $el.getAttribute('style'));\n\n    parsedTargets.forEach(($el, i) => {\n\n      const cachedTransforms = $el[transformsSymbol];\n\n      const hasIndividualTransforms = validIndividualTransforms.some(t => params.hasOwnProperty(t));\n\n      /** @type {Number} */\n      const duration = (spring ? /** @type {Spring} */(spring).duration : getFunctionValue(setValue(params.duration, globals.defaults.duration), $el, i, targetsLength)) * timeScale;\n      /** @type {Number} */\n      const delay = getFunctionValue(setValue(params.delay, globals.defaults.delay), $el, i, targetsLength) * timeScale;\n      /** @type {CompositeOperation} */\n      const composite = /** @type {CompositeOperation} */(setValue(params.composition, 'replace'));\n\n      for (let name in params) {\n        if (!isKey(name)) continue;\n        /** @type {PropertyIndexedKeyframes} */\n        const keyframes = {};\n        /** @type {KeyframeAnimationOptions} */\n        const tweenParams = { iterations, direction, fill, easing, duration, delay, composite };\n        const propertyValue = params[name];\n        const individualTransformProperty = hasIndividualTransforms ? validTransforms.includes(name) ? name : shortTransforms.get(name) : false;\n        let parsedPropertyValue;\n        if (isObj(propertyValue)) {\n          const tweenOptions = /** @type {WAAPITweenOptions} */(propertyValue);\n          const tweenOptionsEase = setValue(tweenOptions.ease, ease);\n          const tweenOptionsSpring = /** @type {Spring} */(tweenOptionsEase).ease && tweenOptionsEase;\n          const to = /** @type {WAAPITweenOptions} */(tweenOptions).to;\n          const from = /** @type {WAAPITweenOptions} */(tweenOptions).from;\n          /** @type {Number} */\n          tweenParams.duration = (tweenOptionsSpring ? /** @type {Spring} */(tweenOptionsSpring).duration : getFunctionValue(setValue(tweenOptions.duration, duration), $el, i, targetsLength)) * timeScale;\n          /** @type {Number} */\n          tweenParams.delay = getFunctionValue(setValue(tweenOptions.delay, delay), $el, i, targetsLength) * timeScale;\n          /** @type {CompositeOperation} */\n          tweenParams.composite = /** @type {CompositeOperation} */(setValue(tweenOptions.composition, composite));\n          /** @type {String} */\n          tweenParams.easing = parseWAAPIEasing(tweenOptionsEase);\n          parsedPropertyValue = parseIndividualTweenValue($el, name, from, to, i, targetsLength);\n          if (individualTransformProperty) {\n            keyframes[`--${individualTransformProperty}`] = parsedPropertyValue;\n            cachedTransforms[individualTransformProperty] = parsedPropertyValue;\n          } else {\n            keyframes[name] = parseIndividualTweenValue($el, name, from, to, i, targetsLength);\n          }\n          addWAAPIAnimation(this, $el, name, keyframes, tweenParams);\n          if (!isUnd(from)) {\n            if (!individualTransformProperty) {\n              $el.style[name] = keyframes[name][0];\n            } else {\n              const key = `--${individualTransformProperty}`;\n              $el.style.setProperty(key, keyframes[key][0]);\n            }\n          }\n        } else {\n          parsedPropertyValue = isArr(propertyValue) ?\n                                propertyValue.map((/** @type {any} */v) => normalizeTweenValue(name, v, $el, i, targetsLength)) :\n                                normalizeTweenValue(name, /** @type {any} */(propertyValue), $el, i, targetsLength);\n          if (individualTransformProperty) {\n            keyframes[`--${individualTransformProperty}`] = parsedPropertyValue;\n            cachedTransforms[individualTransformProperty] = parsedPropertyValue;\n          } else {\n            keyframes[name] = parsedPropertyValue;\n          }\n          addWAAPIAnimation(this, $el, name, keyframes, tweenParams);\n        }\n      }\n      if (hasIndividualTransforms) {\n        let transforms = emptyString;\n        for (let t in cachedTransforms) {\n          transforms += `${transformsFragmentStrings[t]}var(--${t})) `;\n        }\n        $el.style.transform = transforms;\n      }\n    });\n\n    if (scroll) {\n      /** @type {ScrollObserver} */(this.autoplay).link(this);\n    }\n  }\n\n  /**\n   * @callback forEachCallback\n   * @param {globalThis.Animation} animation\n   */\n\n  /**\n   * @param  {forEachCallback|String} callback\n   * @return {this}\n   */\n  forEach(callback) {\n    const cb = isStr(callback) ? a => a[callback]() : callback;\n    this.animations.forEach(cb);\n    return this;\n  }\n\n  get speed() {\n    return this._speed;\n  }\n\n  /** @param {Number} speed */\n  set speed(speed) {\n    this._speed = +speed;\n    this.forEach(anim => anim.playbackRate = speed);\n  }\n\n  get currentTime() {\n    const controlAnimation = this.controlAnimation;\n    const timeScale = globals.timeScale;\n    return this.completed ? this.duration : controlAnimation ? +controlAnimation.currentTime * (timeScale === 1 ? 1 : timeScale) : 0;\n  }\n\n  /** @param {Number} time */\n  set currentTime(time) {\n    const t = time * (globals.timeScale === 1 ? 1 : K);\n    this.forEach(anim => {\n      // Make sure the animation playState is not 'paused' in order to properly trigger an onfinish callback.\n      // The \"paused\" play state supersedes the \"finished\" play state; if the animation is both paused and finished, the \"paused\" state is the one that will be reported.\n      // https://developer.mozilla.org/en-US/docs/Web/API/Animation/finish_event\n      if (t >= this.duration) anim.play();\n      anim.currentTime = t;\n    });\n  }\n\n  get progress() {\n    return this.currentTime / this.duration;\n  }\n\n  /** @param {Number} progress */\n  set progress(progress) {\n    this.forEach(anim => anim.currentTime = progress * this.duration || 0);\n  }\n\n  resume() {\n    if (!this.paused) return this;\n    this.paused = false;\n    // TODO: Store the current time, and seek back to the last position\n    return this.forEach('play');\n  }\n\n  pause() {\n    if (this.paused) return this;\n    this.paused = true;\n    return this.forEach('pause');\n  }\n\n  alternate() {\n    this.reversed = !this.reversed;\n    this.forEach('reverse');\n    if (this.paused) this.forEach('pause');\n    return this;\n  }\n\n  play() {\n    if (this.reversed) this.alternate();\n    return this.resume();\n  }\n\n  reverse() {\n    if (!this.reversed) this.alternate();\n    return this.resume();\n  }\n\n /**\n  * @param {Number} time\n  * @param {Boolean} muteCallbacks\n  */\n  seek(time, muteCallbacks = false) {\n    if (muteCallbacks) this.muteCallbacks = true;\n    if (time < this.duration) this.completed = false;\n    this.currentTime = time;\n    this.muteCallbacks = false;\n    if (this.paused) this.pause();\n    return this;\n  }\n\n  restart() {\n    this.completed = false;\n    return this.seek(0, true).resume();\n  }\n\n  commitStyles() {\n    return this.forEach('commitStyles');\n  }\n\n  complete() {\n    return this.seek(this.duration);\n  }\n\n  cancel() {\n    this.forEach('cancel');\n    return this.pause();\n  }\n\n  revert() {\n    this.cancel();\n    this.targets.forEach(($el, i) => $el.setAttribute('style', this._inlineStyles[i]) );\n    return this;\n  }\n\n  /**\n   * @param  {WAAPICallback} [callback]\n   * @return {Promise}\n   */\n  then(callback = noop) {\n    const then = this.then;\n    const onResolve = () => {\n      this.then = null;\n      callback(this);\n      this.then = then;\n      this._resolve = noop;\n    };\n    return new Promise(r => {\n      this._resolve = () => r(onResolve());\n      if (this.completed) this._resolve();\n      return this;\n    });\n  }\n}\n\nconst waapi = {\n/**\n * @param {DOMTargetsParam} targets\n * @param {WAAPIAnimationParams} params\n * @return {WAAPIAnimation}\n */\n  animate: (targets, params) => new WAAPIAnimation(targets, params),\n  convertEase: easingToLinear\n};\n\n\n\n\n/**\n * @param  {Callback<Timer>} [callback]\n * @return {Timer}\n */\nconst sync = (callback = noop) => {\n  return new Timer({ duration: 1 * globals.timeScale, onComplete: callback }, null, 0).resume();\n};\n\n/**\n * @overload\n * @param  {DOMTargetSelector} targetSelector\n * @param  {String}            propName\n * @return {String}\n *\n * @overload\n * @param  {JSTargetsParam} targetSelector\n * @param  {String}         propName\n * @return {Number|String}\n *\n * @overload\n * @param  {DOMTargetsParam} targetSelector\n * @param  {String}          propName\n * @param  {String}          unit\n * @return {String}\n *\n * @overload\n * @param  {TargetsParam} targetSelector\n * @param  {String}       propName\n * @param  {Boolean}      unit\n * @return {Number}\n *\n * @param  {TargetsParam}   targetSelector\n * @param  {String}         propName\n * @param  {String|Boolean} [unit]\n */\nfunction getTargetValue(targetSelector, propName, unit) {\n  const targets = registerTargets(targetSelector);\n  if (!targets.length) return;\n  const [ target ] = targets;\n  const tweenType = getTweenType(target, propName);\n  const normalizePropName = sanitizePropertyName(propName, target, tweenType);\n  let originalValue = getOriginalAnimatableValue(target, normalizePropName);\n  if (isUnd(unit)) {\n    return originalValue;\n  } else {\n    decomposeRawValue(originalValue, decomposedOriginalValue);\n    if (decomposedOriginalValue.t === valueTypes.NUMBER || decomposedOriginalValue.t === valueTypes.UNIT) {\n      if (unit === false) {\n        return decomposedOriginalValue.n;\n      } else {\n        const convertedValue = convertValueUnit(/** @type {DOMTarget} */(target), decomposedOriginalValue, /** @type {String} */(unit), false);\n        return `${round(convertedValue.n, globals.precision)}${convertedValue.u}`;\n      }\n    }\n  }\n}\n\n/**\n * @param  {TargetsParam}    targets\n * @param  {AnimationParams} parameters\n * @return {JSAnimation}\n */\nconst setTargetValues = (targets, parameters) => {\n  if (isUnd(parameters)) return;\n  parameters.duration = minValue;\n  // Do not overrides currently active tweens by default\n  parameters.composition = setValue(parameters.composition, compositionTypes.none);\n  // Skip init() and force rendering by playing the animation\n  return new JSAnimation(targets, parameters, null, 0, true).resume();\n};\n\n/**\n * @param  {TargetsArray} targetsArray\n * @param  {JSAnimation}    animation\n * @param  {String}       [propertyName]\n * @return {Boolean}\n */\nconst removeTargetsFromAnimation = (targetsArray, animation, propertyName) => {\n  let tweensMatchesTargets = false;\n  forEachChildren(animation, (/**@type {Tween} */tween) => {\n    const tweenTarget = tween.target;\n    if (targetsArray.includes(tweenTarget)) {\n      const tweenName = tween.property;\n      const tweenType = tween._tweenType;\n      const normalizePropName = sanitizePropertyName(propertyName, tweenTarget, tweenType);\n      if (!normalizePropName || normalizePropName && normalizePropName === tweenName) {\n        // Make sure to flag the previous CSS transform tween to renderTransform\n        if (tween.parent._tail === tween &&\n            tween._tweenType === tweenTypes.TRANSFORM &&\n            tween._prev &&\n            tween._prev._tweenType === tweenTypes.TRANSFORM\n        ) {\n          tween._prev._renderTransforms = 1;\n        }\n        // Removes the tween from the selected animation\n        removeChild(animation, tween);\n        // Detach the tween from its siblings to make sure blended tweens are correctlly removed\n        removeTweenSliblings(tween);\n        tweensMatchesTargets = true;\n      }\n    }\n  }, true);\n  return tweensMatchesTargets;\n};\n\n/**\n * @param  {TargetsParam} targets\n * @param  {Renderable|WAAPIAnimation} [renderable]\n * @param  {String}                    [propertyName]\n * @return {TargetsArray}\n */\nconst remove = (targets, renderable, propertyName) => {\n  const targetsArray = parseTargets(targets);\n  const parent = /** @type {Renderable|typeof engine} **/(renderable ? renderable : engine);\n  const waapiAnimation = renderable && /** @type {WAAPIAnimation} */(renderable).controlAnimation && /** @type {WAAPIAnimation} */(renderable);\n  for (let i = 0, l = targetsArray.length; i < l; i++) {\n    const $el = /** @type {DOMTarget}  */(targetsArray[i]);\n    removeWAAPIAnimation($el, propertyName, waapiAnimation);\n  }\n  let removeMatches;\n  if (parent._hasChildren) {\n    let iterationDuration = 0;\n    forEachChildren(parent, (/** @type {Renderable} */child) => {\n      if (!child._hasChildren) {\n        removeMatches = removeTargetsFromAnimation(targetsArray, /** @type {JSAnimation} */(child), propertyName);\n        // Remove the child from its parent if no tweens and no children left after the removal\n        if (removeMatches && !child._head) {\n          child.cancel();\n          removeChild(parent, child);\n        } else {\n          // Calculate the new iterationDuration value to handle onComplete with last child in render()\n          const childTLOffset = child._offset + child._delay;\n          const childDur = childTLOffset + child.duration;\n          if (childDur > iterationDuration) {\n            iterationDuration = childDur;\n          }\n        }\n      }\n      // Make sure to also remove engine's children targets\n      // NOTE: Avoid recursion?\n      if (child._head) {\n        remove(targets, child, propertyName);\n      } else {\n        child._hasChildren = false;\n      }\n    }, true);\n    // Update iterationDuration value to handle onComplete with last child in render()\n    if (!isUnd(/** @type {Renderable} */(parent).iterationDuration)) {\n      /** @type {Renderable} */(parent).iterationDuration = iterationDuration;\n    }\n  } else {\n    removeMatches = removeTargetsFromAnimation(\n      targetsArray,\n      /** @type {JSAnimation} */(parent),\n      propertyName\n    );\n  }\n\n  if (removeMatches && !parent._head) {\n    parent._hasChildren = false;\n    // Cancel the parent if there are no tweens and no children left after the removal\n    // We have to check if the .cancel() method exist to handle cases where the parent is the engine itself\n    if (/** @type {Renderable} */(parent).cancel) /** @type {Renderable} */(parent).cancel();\n  }\n\n  return targetsArray;\n};\n\n/**\n * @param  {(...args: any[]) => Tickable} constructor\n * @return {(...args: any[]) => Tickable}\n */\nconst keepTime = createRefreshable;\n\n/**\n * @param  {String|Array} items\n * @return {any}\n */\nconst randomPick = items => items[random(0, items.length - 1)];\n\n/**\n * @param  {Number|String} v\n * @param  {Number} decimalLength\n * @return {String}\n */\nconst roundPad = (v, decimalLength) => (+v).toFixed(decimalLength);\n\n/**\n * @param  {Number} v\n * @param  {Number} totalLength\n * @param  {String} padString\n * @return {String}\n */\nconst padStart = (v, totalLength, padString) => `${v}`.padStart(totalLength, padString);\n\n/**\n * @param  {Number} v\n * @param  {Number} totalLength\n * @param  {String} padString\n * @return {String}\n */\nconst padEnd = (v, totalLength, padString) => `${v}`.padEnd(totalLength, padString);\n\n/**\n * @param  {Number} v\n * @param  {Number} min\n * @param  {Number} max\n * @return {Number}\n */\nconst wrap = (v, min, max) => (((v - min) % (max - min) + (max - min)) % (max - min)) + min;\n\n/**\n * @param  {Number} value\n * @param  {Number} inLow\n * @param  {Number} inHigh\n * @param  {Number} outLow\n * @param  {Number} outHigh\n * @return {Number}\n */\nconst mapRange = (value, inLow, inHigh, outLow, outHigh) => outLow + ((value - inLow) / (inHigh - inLow)) * (outHigh - outLow);\n\n/**\n * @param  {Number} degrees\n * @return {Number}\n */\nconst degToRad = degrees => degrees * PI / 180;\n\n/**\n * @param  {Number} radians\n * @return {Number}\n */\nconst radToDeg = radians => radians * 180 / PI;\n\n/**\n * https://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\n * @param  {Number} start\n * @param  {Number} end\n * @param  {Number} amount\n * @param  {Renderable|Boolean} [renderable]\n * @return {Number}\n */\nconst lerp = (start, end, amount, renderable) => {\n  let dt = K / globals.defaults.frameRate;\n  if (renderable !== false) {\n    const ticker = /** @type Renderable */\n                   (renderable) ||\n                   (engine._hasChildren && engine);\n    if (ticker && ticker.deltaTime) {\n      dt = ticker.deltaTime;\n    }\n  }\n  const t = 1 - Math.exp(-amount * dt * .1);\n  return !amount ? start : amount === 1 ? end : (1 - t) * start + t * end;\n};\n\n// Chain-able utilities\n\n/**\n * @callback UtilityFunction\n * @param {...*} args\n * @return {Number|String}\n *\n * @param {UtilityFunction} fn\n * @param {Number} [last=0]\n * @return {function(...(Number|String)): function(Number|String): (Number|String)}\n */\nconst curry = (fn, last = 0) => (...args) => last ? v => fn(...args, v) : v => fn(v, ...args);\n\n/**\n * @param {Function} fn\n * @return {function(...(Number|String))}\n */\nconst chain = fn => {\n   return (...args) => {\n    const result = fn(...args);\n    return new Proxy(noop, {\n      apply: (_, __, [v]) => result(v),\n      get: (_, prop) => chain(/**@param {...Number|String} nextArgs */(...nextArgs) => {\n        const nextResult = utils[prop](...nextArgs);\n        return (/**@type {Number|String} */v) => nextResult(result(v));\n      })\n    });\n  }\n};\n\n/**\n * @param {UtilityFunction} fn\n * @param {Number} [right]\n * @return {function(...(Number|String)): UtilityFunction}\n */\nconst makeChainable = (fn, right = 0) => (...args) => (args.length < fn.length ? chain(curry(fn, right)) : fn)(...args);\n\n/**\n * @callback ChainedUtilsResult\n * @param {Number} value\n * @return {Number}\n *\n * @typedef {Object} ChainableUtils\n * @property {ChainedClamp} clamp\n * @property {ChainedRound} round\n * @property {ChainedSnap} snap\n * @property {ChainedWrap} wrap\n * @property {ChainedInterpolate} interpolate\n * @property {ChainedMapRange} mapRange\n * @property {ChainedRoundPad} roundPad\n * @property {ChainedPadStart} padStart\n * @property {ChainedPadEnd} padEnd\n * @property {ChainedDegToRad} degToRad\n * @property {ChainedRadToDeg} radToDeg\n *\n * @typedef {ChainableUtils & ChainedUtilsResult} ChainableUtil\n *\n * @callback ChainedClamp\n * @param {Number} min\n * @param {Number} max\n * @return {ChainableUtil}\n *\n * @callback ChainedRound\n * @param {Number} decimalLength\n * @return {ChainableUtil}\n *\n * @callback ChainedSnap\n * @param {Number} increment\n * @return {ChainableUtil}\n *\n * @callback ChainedWrap\n * @param {Number} min\n * @param {Number} max\n * @return {ChainableUtil}\n *\n * @callback ChainedInterpolate\n * @param {Number} start\n * @param {Number} end\n * @return {ChainableUtil}\n *\n * @callback ChainedMapRange\n * @param {Number} inLow\n * @param {Number} inHigh\n * @param {Number} outLow\n * @param {Number} outHigh\n * @return {ChainableUtil}\n *\n * @callback ChainedRoundPad\n * @param {Number} decimalLength\n * @return {ChainableUtil}\n *\n * @callback ChainedPadStart\n * @param {Number} totalLength\n * @param {String} padString\n * @return {ChainableUtil}\n *\n * @callback ChainedPadEnd\n * @param {Number} totalLength\n * @param {String} padString\n * @return {ChainableUtil}\n *\n * @callback ChainedDegToRad\n * @return {ChainableUtil}\n *\n * @callback ChainedRadToDeg\n * @return {ChainableUtil}\n */\n\nconst utils = {\n  $: registerTargets,\n  get: getTargetValue,\n  set: setTargetValues,\n  remove,\n  cleanInlineStyles,\n  random,\n  randomPick,\n  shuffle,\n  lerp,\n  sync,\n  keepTime,\n  clamp: /** @type {typeof clamp & ChainedClamp} */(makeChainable(clamp)),\n  round: /** @type {typeof round & ChainedRound} */(makeChainable(round)),\n  snap: /** @type {typeof snap & ChainedSnap} */(makeChainable(snap)),\n  wrap: /** @type {typeof wrap & ChainedWrap} */(makeChainable(wrap)),\n  interpolate: /** @type {typeof interpolate & ChainedInterpolate} */(makeChainable(interpolate, 1)),\n  mapRange: /** @type {typeof mapRange & ChainedMapRange} */(makeChainable(mapRange)),\n  roundPad: /** @type {typeof roundPad & ChainedRoundPad} */(makeChainable(roundPad)),\n  padStart: /** @type {typeof padStart & ChainedPadStart} */(makeChainable(padStart)),\n  padEnd: /** @type {typeof padEnd & ChainedPadEnd} */(makeChainable(padEnd)),\n  degToRad: /** @type {typeof degToRad & ChainedDegToRad} */(makeChainable(degToRad)),\n  radToDeg: /** @type {typeof radToDeg & ChainedRadToDeg} */(makeChainable(radToDeg)),\n};\n\n\n\n\n/**\n * @typedef {Number|String|Function} TimePosition\n */\n\n/**\n * Timeline's children offsets positions parser\n * @param  {Timeline} timeline\n * @param  {String} timePosition\n * @return {Number}\n */\nconst getPrevChildOffset = (timeline, timePosition) => {\n  if (stringStartsWith(timePosition, '<')) {\n    const goToPrevAnimationOffset = timePosition[1] === '<';\n    const prevAnimation = /** @type {Tickable} */(timeline._tail);\n    const prevOffset = prevAnimation ? prevAnimation._offset + prevAnimation._delay : 0;\n    return goToPrevAnimationOffset ? prevOffset : prevOffset + prevAnimation.duration;\n  }\n};\n\n/**\n * @param  {Timeline} timeline\n * @param  {TimePosition} [timePosition]\n * @return {Number}\n */\nconst parseTimelinePosition = (timeline, timePosition) => {\n  let tlDuration = timeline.iterationDuration;\n  if (tlDuration === minValue) tlDuration = 0;\n  if (isUnd(timePosition)) return tlDuration;\n  if (isNum(+timePosition)) return +timePosition;\n  const timePosStr = /** @type {String} */(timePosition);\n  const tlLabels = timeline ? timeline.labels : null;\n  const hasLabels = !isNil(tlLabels);\n  const prevOffset = getPrevChildOffset(timeline, timePosStr);\n  const hasSibling = !isUnd(prevOffset);\n  const matchedRelativeOperator = relativeValuesExecRgx.exec(timePosStr);\n  if (matchedRelativeOperator) {\n    const fullOperator = matchedRelativeOperator[0];\n    const split = timePosStr.split(fullOperator);\n    const labelOffset = hasLabels && split[0] ? tlLabels[split[0]] : tlDuration;\n    const parsedOffset = hasSibling ? prevOffset : hasLabels ? labelOffset : tlDuration;\n    const parsedNumericalOffset = +split[1];\n    return getRelativeValue(parsedOffset, parsedNumericalOffset, fullOperator[0]);\n  } else {\n    return hasSibling ? prevOffset :\n           hasLabels ? !isUnd(tlLabels[timePosStr]) ? tlLabels[timePosStr] :\n           tlDuration : tlDuration;\n  }\n};\n\n/**\n * @param {Timeline} tl\n * @return {Number}\n */\nfunction getTimelineTotalDuration(tl) {\n  return clampInfinity(((tl.iterationDuration + tl._loopDelay) * tl.iterationCount) - tl._loopDelay) || minValue;\n}\n\n/**\n * @overload\n * @param  {TimerParams} childParams\n * @param  {Timeline} tl\n * @param  {Number} timePosition\n * @return {Timeline}\n *\n * @overload\n * @param  {AnimationParams} childParams\n * @param  {Timeline} tl\n * @param  {Number} timePosition\n * @param  {TargetsParam} targets\n * @param  {Number} [index]\n * @param  {Number} [length]\n * @return {Timeline}\n *\n * @param  {TimerParams|AnimationParams} childParams\n * @param  {Timeline} tl\n * @param  {Number} timePosition\n * @param  {TargetsParam} [targets]\n * @param  {Number} [index]\n * @param  {Number} [length]\n */\nfunction addTlChild(childParams, tl, timePosition, targets, index, length) {\n  const isSetter = isNum(childParams.duration) && /** @type {Number} */(childParams.duration) <= minValue;\n  // Offset the tl position with -minValue for 0 duration animations or .set() calls in order to align their end value with the defined position\n  const adjustedPosition = isSetter ? timePosition - minValue : timePosition;\n  tick(tl, adjustedPosition, 1, 1, tickModes.AUTO);\n  const tlChild = targets ?\n    new JSAnimation(targets,/** @type {AnimationParams} */(childParams), tl, adjustedPosition, false, index, length) :\n    new Timer(/** @type {TimerParams} */(childParams), tl, adjustedPosition);\n  tlChild.init(1);\n  // TODO: Might be better to insert at a position relative to startTime?\n  addChild(tl, tlChild);\n  forEachChildren(tl, (/** @type {Renderable} */child) => {\n    const childTLOffset = child._offset + child._delay;\n    const childDur = childTLOffset + child.duration;\n    if (childDur > tl.iterationDuration) tl.iterationDuration = childDur;\n  });\n  tl.duration = getTimelineTotalDuration(tl);\n  return tl;\n}\n\nclass Timeline extends Timer {\n\n  /**\n   * @param {TimelineParams} [parameters]\n   */\n  constructor(parameters = {}) {\n    super(/** @type {TimerParams&TimelineParams} */(parameters), null, 0);\n    /** @type {Number} */\n    this.duration = 0; // TL duration starts at 0 and grows when adding children\n    /** @type {Record<String, Number>} */\n    this.labels = {};\n    const defaultsParams = parameters.defaults;\n    const globalDefaults = globals.defaults;\n    /** @type {DefaultsParams} */\n    this.defaults = defaultsParams ? mergeObjects(defaultsParams, globalDefaults) : globalDefaults;\n    /** @type {Callback<this>} */\n    this.onRender = parameters.onRender || globalDefaults.onRender;\n    const tlPlaybackEase = setValue(parameters.playbackEase, globalDefaults.playbackEase);\n    this._ease = tlPlaybackEase ? parseEasings(tlPlaybackEase) : null;\n    /** @type {Number} */\n    this.iterationDuration = 0;\n  }\n\n  /**\n   * @overload\n   * @param {TargetsParam} a1\n   * @param {AnimationParams} a2\n   * @param {TimePosition} [a3]\n   * @return {this}\n   *\n   * @overload\n   * @param {TimerParams} a1\n   * @param {TimePosition} [a2]\n   * @return {this}\n   *\n   * @param {TargetsParam|TimerParams} a1\n   * @param {AnimationParams|TimePosition} a2\n   * @param {TimePosition} [a3]\n   */\n  add(a1, a2, a3) {\n    const isAnim = isObj(a2);\n    const isTimer = isObj(a1);\n    if (isAnim || isTimer) {\n      this._hasChildren = true;\n      if (isAnim) {\n        const childParams = /** @type {AnimationParams} */(a2);\n        // Check for function for children stagger positions\n        if (isFnc(a3)) {\n          const staggeredPosition = /** @type {Function} */(a3);\n          const parsedTargetsArray = parseTargets(/** @type {TargetsParam} */(a1));\n          // Store initial duration before adding new children that will change the duration\n          const tlDuration = this.duration;\n          // Store initial _iterationDuration before adding new children that will change the duration\n          const tlIterationDuration = this.iterationDuration;\n          // Store the original id in order to add specific indexes to the new animations ids\n          const id = childParams.id;\n          let i = 0;\n          const parsedLength = parsedTargetsArray.length;\n          parsedTargetsArray.forEach((/** @type {Target} */target) => {\n            // Create a new parameter object for each staggered children\n            const staggeredChildParams = { ...childParams };\n            // Reset the duration of the timeline iteration before each stagger to prevent wrong start value calculation\n            this.duration = tlDuration;\n            this.iterationDuration = tlIterationDuration;\n            if (!isUnd(id)) staggeredChildParams.id = id + '-' + i;\n            addTlChild(\n              staggeredChildParams,\n              this,\n              staggeredPosition(target, i, parsedLength, this),\n              target,\n              i,\n              parsedLength\n            );\n            i++;\n          });\n        } else {\n          addTlChild(\n            childParams,\n            this,\n            parseTimelinePosition(this, a3),\n            /** @type {TargetsParam} */(a1),\n          );\n        }\n      } else {\n        // It's a Timer\n        addTlChild(\n          /** @type TimerParams */(a1),\n          this,\n          parseTimelinePosition(this,/** @type TimePosition */(a2)),\n        );\n      }\n      return this.init(1); // 1 = internalRender\n    }\n  }\n\n  /**\n   * @overload\n   * @param {Tickable} [synced]\n   * @param {TimePosition} [position]\n   * @return {this}\n   *\n   * @overload\n   * @param {globalThis.Animation} [synced]\n   * @param {TimePosition} [position]\n   * @return {this}\n   *\n   * @overload\n   * @param {WAAPIAnimation} [synced]\n   * @param {TimePosition} [position]\n   * @return {this}\n   *\n   * @param {Tickable|WAAPIAnimation|globalThis.Animation} [synced]\n   * @param {TimePosition} [position]\n   */\n  sync(synced, position) {\n    if (isUnd(synced) || synced && isUnd(synced.pause)) return this;\n    synced.pause();\n    const duration = +(/** @type {globalThis.Animation} */(synced).effect ? /** @type {globalThis.Animation} */(synced).effect.getTiming().duration : /** @type {Tickable} */(synced).duration);\n    return this.add(synced, { currentTime: [0, duration], duration, ease: 'linear' }, position);\n  }\n\n  /**\n   * @param  {TargetsParam} targets\n   * @param  {AnimationParams} parameters\n   * @param  {TimePosition} [position]\n   * @return {this}\n   */\n  set(targets, parameters, position) {\n    if (isUnd(parameters)) return this;\n    parameters.duration = minValue;\n    parameters.composition = compositionTypes.replace;\n    return this.add(targets, parameters, position);\n  }\n\n  /**\n   * @param {Callback<Timer>} callback\n   * @param {TimePosition} [position]\n   * @return {this}\n   */\n  call(callback, position) {\n    if (isUnd(callback) || callback && !isFnc(callback)) return this;\n    return this.add({ duration: 0, onComplete: () => callback(this) }, position);\n  }\n\n  /**\n   * @param {String} labelName\n   * @param {TimePosition} [position]\n   * @return {this}\n   *\n   */\n  label(labelName, position) {\n    if (isUnd(labelName) || labelName && !isStr(labelName)) return this;\n    this.labels[labelName] = parseTimelinePosition(this,/** @type TimePosition */(position));\n    return this;\n  }\n\n  /**\n   * @param  {TargetsParam} targets\n   * @param  {String} [propertyName]\n   * @return {this}\n   */\n  remove(targets, propertyName) {\n    remove(targets, this, propertyName);\n    return this;\n  }\n\n  /**\n   * @param  {Number} newDuration\n   * @return {this}\n   */\n  stretch(newDuration) {\n    const currentDuration = this.duration;\n    if (currentDuration === normalizeTime(newDuration)) return this;\n    const timeScale = newDuration / currentDuration;\n    const labels = this.labels;\n    forEachChildren(this, (/** @type {JSAnimation} */child) => child.stretch(child.duration * timeScale));\n    for (let labelName in labels) labels[labelName] *= timeScale;\n    return super.stretch(newDuration);\n  }\n\n  /**\n   * @return {this}\n   */\n  refresh() {\n    forEachChildren(this, (/** @type {JSAnimation} */child) => {\n      if (child.refresh) child.refresh();\n    });\n    return this;\n  }\n\n  /**\n   * @return {this}\n   */\n  revert() {\n    super.revert();\n    forEachChildren(this, (/** @type {JSAnimation} */child) => child.revert, true);\n    return cleanInlineStyles(this);\n  }\n\n  /**\n   * @param  {Callback<this>} [callback]\n   * @return {Promise}\n   */\n  then(callback) {\n    return super.then(callback);\n  }\n}\n\n/**\n * @param {TimelineParams} [parameters]\n * @return {Timeline}\n */\nconst createTimeline = parameters => new Timeline(parameters).init();\n\n\n\n\nclass Animatable {\n  /**\n   * @param {TargetsParam} targets\n   * @param {AnimatableParams} parameters\n   */\n  constructor(targets, parameters) {\n    if (scope.current) scope.current.register(this);\n    /** @type {AnimationParams} */\n    const globalParams = {};\n    const properties = {};\n    this.targets = [];\n    this.animations = {};\n    if (isUnd(targets) || isUnd(parameters)) return;\n    for (let propName in parameters) {\n      const paramValue = parameters[propName];\n      if (isKey(propName)) {\n        properties[propName] = paramValue;\n      } else {\n        globalParams[propName] = paramValue;\n      }\n    }\n    for (let propName in properties) {\n      const propValue = properties[propName];\n      const isObjValue = isObj(propValue);\n      /** @type {TweenParamsOptions} */\n      let propParams = {};\n      let to = '+=0';\n      if (isObjValue) {\n        const unit = propValue.unit;\n        if (isStr(unit)) to += unit;\n      } else {\n        propParams.duration = propValue;\n      }\n      propParams[propName] = isObjValue ? mergeObjects({ to }, propValue) : to;\n      const animParams = mergeObjects(globalParams, propParams);\n      animParams.composition = compositionTypes.replace;\n      animParams.autoplay = false;\n      const animation = this.animations[propName] = new JSAnimation(targets, animParams, null, 0, false).init();\n      if (!this.targets.length) this.targets.push(...animation.targets);\n      /** @type {AnimatableProperty} */\n      this[propName] = (to, duration, ease) => {\n        const tween = /** @type {Tween} */(animation._head);\n        if (isUnd(to) && tween) {\n          const numbers = tween._numbers;\n          if (numbers && numbers.length) {\n            return numbers;\n          } else {\n            return tween._modifier(tween._number);\n          }\n        } else {\n          forEachChildren(animation, (/** @type {Tween} */tween) => {\n            if (isArr(to)) {\n              for (let i = 0, l = /** @type {Array} */(to).length; i < l; i++) {\n                if (!isUnd(tween._numbers[i])) {\n                  tween._fromNumbers[i] = /** @type {Number} */(tween._modifier(tween._numbers[i]));\n                  tween._toNumbers[i] = to[i];\n                }\n              }\n            } else {\n              tween._fromNumber = /** @type {Number} */(tween._modifier(tween._number));\n              tween._toNumber = /** @type {Number} */(to);\n            }\n            if (!isUnd(ease)) tween._ease = parseEasings(ease);\n            tween._currentTime = 0;\n          });\n          if (!isUnd(duration)) animation.stretch(duration);\n          animation.reset(1).resume();\n          return this;\n        }\n      };\n    }\n  }\n\n  revert() {\n    for (let propName in this.animations) {\n      this[propName] = noop;\n      this.animations[propName].revert();\n    }\n    this.animations = {};\n    this.targets.length = 0;\n    return this;\n  }\n}\n\n/**\n * @param {TargetsParam} targets\n * @param {AnimatableParams} parameters\n * @return {AnimatableObject}\n */\nconst createAnimatable = (targets, parameters) => /** @type {AnimatableObject} */(new Animatable(targets, parameters));\n\n\n\n\n/*\n * Spring ease solver adapted from https://webkit.org/demos/spring/spring.js\n * Webkit Copyright © 2016 Apple Inc\n */\n\n/**\n * @typedef {Object} SpringParams\n * @property {Number} [mass=1] - Mass, default 1\n * @property {Number} [stiffness=100] - Stiffness, default 100\n * @property {Number} [damping=10] - Damping, default 10\n * @property {Number} [velocity=0] - Initial velocity, default 0\n */\n\nclass Spring {\n  /**\n   * @param {SpringParams} [parameters]\n   */\n  constructor(parameters = {}) {\n    this.timeStep = .02; // Interval fed to the solver to calculate duration\n    this.restThreshold = .0005; // Values below this threshold are considered resting position\n    this.restDuration = 200; // Duration in ms used to check if the spring is resting after reaching restThreshold\n    this.maxDuration = 60000; // The maximum allowed spring duration in ms (default 1 min)\n    this.maxRestSteps = this.restDuration / this.timeStep / K; // How many steps allowed after reaching restThreshold before stopping the duration calculation\n    this.maxIterations = this.maxDuration / this.timeStep / K; // Calculate the maximum iterations allowed based on maxDuration\n    this.m = clamp(setValue(parameters.mass, 1), 0, K);\n    this.s = clamp(setValue(parameters.stiffness, 100), 1, K);\n    this.d = clamp(setValue(parameters.damping, 10), .1, K);\n    this.v = clamp(setValue(parameters.velocity, 0), -1e3, K);\n    this.w0 = 0;\n    this.zeta = 0;\n    this.wd = 0;\n    this.b = 0;\n    this.solverDuration = 0;\n    this.duration = 0;\n    this.compute();\n    /** @type {EasingFunction} */\n    this.ease = t => t === 0 || t === 1 ? t : this.solve(t * this.solverDuration);\n  }\n\n  /** @type {EasingFunction} */\n  solve(time) {\n    const { zeta, w0, wd, b } = this;\n    let t = time;\n    if (zeta < 1) {\n      t = exp(-t * zeta * w0) * (1 * cos(wd * t) + b * sin(wd * t));\n    } else {\n      t = (1 + b * t) * exp(-t * w0);\n    }\n    return 1 - t;\n  }\n\n  compute() {\n    const { maxRestSteps, maxIterations, restThreshold, timeStep, m, d, s, v } = this;\n    const w0 = this.w0 = clamp(sqrt(s / m), minValue, K);\n    const zeta = this.zeta = d / (2 * sqrt(s * m));\n    const wd = this.wd = zeta < 1 ? w0 * sqrt(1 - zeta * zeta) : 0;\n    this.b = zeta < 1 ? (zeta * w0 + -v) / wd : -v + w0;\n    let solverTime = 0;\n    let restSteps = 0;\n    let iterations = 0;\n    while (restSteps < maxRestSteps && iterations < maxIterations) {\n      if (abs(1 - this.solve(solverTime)) < restThreshold) {\n        restSteps++;\n      } else {\n        restSteps = 0;\n      }\n      this.solverDuration = solverTime;\n      solverTime += timeStep;\n      iterations++;\n    }\n    this.duration = round(this.solverDuration * K, 0) * globals.timeScale;\n  }\n\n  get mass() {\n    return this.m;\n  }\n\n  set mass(v) {\n    this.m = clamp(setValue(v, 1), 0, K);\n    this.compute();\n  }\n\n  get stiffness() {\n    return this.s;\n  }\n\n  set stiffness(v) {\n    this.s = clamp(setValue(v, 100), 1, K);\n    this.compute();\n  }\n\n  get damping() {\n    return this.d;\n  }\n\n  set damping(v) {\n    this.d = clamp(setValue(v, 10), .1, K);\n    this.compute();\n  }\n\n  get velocity() {\n    return this.v;\n  }\n\n  set velocity(v) {\n    this.v = clamp(setValue(v, 0), -1e3, K);\n    this.compute();\n  }\n}\n\n/**\n * @param {SpringParams} [parameters]\n * @returns {Spring}\n */\nconst createSpring = (parameters) => new Spring(parameters);\n\n\n\n\n/**\n * @param {Event} e\n */\nconst preventDefault = e => {\n  if (e.cancelable) e.preventDefault();\n};\n\nclass DOMProxy {\n  /** @param {Object} el */\n  constructor(el) {\n    this.el = el;\n    this.zIndex = 0;\n    this.parentElement = null;\n    this.classList = {\n      add: noop,\n      remove: noop,\n    };\n  }\n\n  get x() { return this.el.x || 0 };\n  set x(v) { this.el.x = v; };\n\n  get y() { return this.el.y || 0 };\n  set y(v) { this.el.y = v; };\n\n  get width() { return this.el.width || 0 };\n  set width(v) { this.el.width = v; };\n\n  get height() { return this.el.height || 0 };\n  set height(v) { this.el.height = v; };\n\n  getBoundingClientRect() {\n    return {\n      top: this.y,\n      right: this.x,\n      bottom: this.y + this.height,\n      left: this.x + this.width,\n    }\n  }\n}\n\nclass Transforms {\n  /**\n   * @param {DOMTarget|DOMProxy} $el\n   */\n  constructor($el) {\n    this.$el = $el;\n    this.inlineTransforms = [];\n    this.point = new DOMPoint();\n    this.inversedMatrix = this.getMatrix().inverse();\n  }\n\n  /**\n   * @param {Number} x\n   * @param {Number} y\n   * @return {DOMPoint}\n   */\n  normalizePoint(x, y) {\n    this.point.x = x;\n    this.point.y = y;\n    return this.point.matrixTransform(this.inversedMatrix);\n  }\n\n  /**\n   * @callback TraverseParentsCallback\n   * @param {DOMTarget} $el\n   * @param {Number} i\n   */\n\n  /**\n   * @param {TraverseParentsCallback} cb\n   */\n  traverseUp(cb) {\n    let $el = /** @type {DOMTarget|Document} */(this.$el.parentElement), i = 0;\n    while ($el && $el !== doc) {\n      cb(/** @type {DOMTarget} */($el), i);\n      $el = /** @type {DOMTarget} */($el.parentElement);\n      i++;\n    }\n  }\n\n  getMatrix() {\n    const matrix = new DOMMatrix();\n    this.traverseUp($el => {\n      const transformValue = getComputedStyle($el).transform;\n      if (transformValue) {\n        const elMatrix = new DOMMatrix(transformValue);\n        matrix.preMultiplySelf(elMatrix);\n      }\n    });\n    return matrix;\n  }\n\n  remove() {\n    this.traverseUp(($el, i) => {\n      this.inlineTransforms[i] = $el.style.transform;\n      $el.style.transform = 'none';\n    });\n  }\n\n  revert() {\n    this.traverseUp(($el, i) => {\n      const ct = this.inlineTransforms[i];\n      if (ct === '') {\n        $el.style.removeProperty('transform');\n      } else {\n        $el.style.transform = ct;\n      }\n    });\n  }\n}\n\n/**\n * @template {Array<Number>|DOMTargetSelector|String|Number|Boolean|Function|DraggableCursorParams} T\n * @param {T | ((draggable: Draggable) => T)} value\n * @param {Draggable} draggable\n * @return {T}\n */\nconst parseDraggableFunctionParameter = (value, draggable) => value && isFnc(value) ? /** @type {Function} */(value)(draggable) : value;\n\nlet zIndex = 0;\n\nclass Draggable {\n  /**\n   * @param {TargetsParam} target\n   * @param {DraggableParams} [parameters]\n   */\n  constructor(target, parameters = {}) {\n    if (!target) return;\n    if (scope.current) scope.current.register(this);\n    const paramX = parameters.x;\n    const paramY = parameters.y;\n    const trigger = parameters.trigger;\n    const modifier = parameters.modifier;\n    const ease = parameters.releaseEase;\n    const customEase = ease && parseEasings(ease);\n    const hasSpring = !isUnd(ease) && !isUnd(/** @type {Spring} */(ease).ease);\n    const xProp = /** @type {String} */(isObj(paramX) && !isUnd(/** @type {Object} */(paramX).mapTo) ? /** @type {Object} */(paramX).mapTo : 'translateX');\n    const yProp = /** @type {String} */(isObj(paramY) && !isUnd(/** @type {Object} */(paramY).mapTo) ? /** @type {Object} */(paramY).mapTo : 'translateY');\n    const container = parseDraggableFunctionParameter(parameters.container, this);\n    this.containerArray = isArr(container) ? container : null;\n    this.$container = /** @type {HTMLElement} */(container && !this.containerArray ? parseTargets(/** @type {DOMTarget} */(container))[0] : doc.body);\n    this.useWin = this.$container === doc.body;\n    /** @type {Window | HTMLElement} */\n    this.$scrollContainer = this.useWin ? win : this.$container;\n    this.$target = /** @type {HTMLElement} */(isObj(target) ? new DOMProxy(target) : parseTargets(target)[0]);\n    this.$trigger = /** @type {HTMLElement} */(parseTargets(trigger ? trigger : target)[0]);\n    this.fixed = getTargetValue(this.$target, 'position') === 'fixed';\n    // Refreshable parameters\n    this.isFinePointer = true;\n    /** @type {[Number, Number, Number, Number]} */\n    this.containerPadding = [0, 0, 0, 0];\n    /** @type {Number} */\n    this.containerFriction = 0;\n    /** @type {Number} */\n    this.releaseContainerFriction = 0;\n    /** @type {Number|Array<Number>} */\n    this.snapX = 0;\n    /** @type {Number|Array<Number>} */\n    this.snapY = 0;\n    /** @type {Number} */\n    this.scrollSpeed = 0;\n    /** @type {Number} */\n    this.scrollThreshold = 0;\n    /** @type {Number} */\n    this.dragSpeed = 0;\n    /** @type {Number} */\n    this.maxVelocity = 0;\n    /** @type {Number} */\n    this.minVelocity = 0;\n    /** @type {Number} */\n    this.velocityMultiplier = 0;\n    /** @type {Boolean|DraggableCursorParams} */\n    this.cursor = false;\n    /** @type {Spring} */\n    this.releaseXSpring = hasSpring ? /** @type {Spring} */(ease) : createSpring({\n      mass: setValue(parameters.releaseMass, 1),\n      stiffness: setValue(parameters.releaseStiffness, 80),\n      damping: setValue(parameters.releaseDamping, 20),\n    });\n    /** @type {Spring} */\n    this.releaseYSpring = hasSpring ? /** @type {Spring} */(ease) : createSpring({\n      mass: setValue(parameters.releaseMass, 1),\n      stiffness: setValue(parameters.releaseStiffness, 80),\n      damping: setValue(parameters.releaseDamping, 20),\n    });\n    /** @type {EasingFunction} */\n    this.releaseEase = customEase || eases.outQuint;\n    /** @type {Boolean} */\n    this.hasReleaseSpring = hasSpring;\n    /** @type {Callback<this>} */\n    this.onGrab = parameters.onGrab || noop;\n    /** @type {Callback<this>} */\n    this.onDrag = parameters.onDrag || noop;\n    /** @type {Callback<this>} */\n    this.onRelease = parameters.onRelease || noop;\n    /** @type {Callback<this>} */\n    this.onUpdate = parameters.onUpdate || noop;\n    /** @type {Callback<this>} */\n    this.onSettle = parameters.onSettle || noop;\n    /** @type {Callback<this>} */\n    this.onSnap = parameters.onSnap || noop;\n    /** @type {Callback<this>} */\n    this.onResize = parameters.onResize || noop;\n    /** @type {Callback<this>} */\n    this.onAfterResize = parameters.onAfterResize || noop;\n    /** @type {[Number, Number]} */\n    this.disabled = [0, 0];\n    /** @type {AnimatableParams} */\n    const animatableParams = {};\n    if (modifier) animatableParams.modifier = modifier;\n    if (isUnd(paramX) || paramX === true) {\n      animatableParams[xProp] = 0;\n    } else if (isObj(paramX)) {\n      const paramXObject = /** @type {DraggableAxisParam} */(paramX);\n      const animatableXParams = {};\n      if (paramXObject.modifier) animatableXParams.modifier = paramXObject.modifier;\n      if (paramXObject.composition) animatableXParams.composition = paramXObject.composition;\n      animatableParams[xProp] = animatableXParams;\n    } else if (paramX === false) {\n      animatableParams[xProp] = 0;\n      this.disabled[0] = 1;\n    }\n    if (isUnd(paramY) || paramY === true) {\n      animatableParams[yProp] = 0;\n    } else if (isObj(paramY)) {\n      const paramYObject = /** @type {DraggableAxisParam} */(paramY);\n      const animatableYParams = {};\n      if (paramYObject.modifier) animatableYParams.modifier = paramYObject.modifier;\n      if (paramYObject.composition) animatableYParams.composition = paramYObject.composition;\n      animatableParams[yProp] = animatableYParams;\n    } else if (paramY === false) {\n      animatableParams[yProp] = 0;\n      this.disabled[1] = 1;\n    }\n    /** @type {AnimatableObject} */\n    this.animate = /** @type {AnimatableObject} */(new Animatable(this.$target, animatableParams));\n    // Internal props\n    this.xProp = xProp;\n    this.yProp = yProp;\n    this.destX = 0;\n    this.destY = 0;\n    this.deltaX = 0;\n    this.deltaY = 0;\n    this.scroll = {x: 0, y: 0};\n    /** @type {[Number, Number, Number, Number]} */\n    this.coords = [this.x, this.y, 0, 0]; // x, y, temp x, temp y\n    /** @type {[Number, Number]} */\n    this.snapped = [0, 0]; // x, y\n    /** @type {[Number, Number, Number, Number, Number, Number, Number, Number]} */\n    this.pointer = [0, 0, 0, 0, 0, 0, 0, 0]; // x1, y1, x2, y2, temp x1, temp y1, temp x2, temp y2\n    /** @type {[Number, Number]} */\n    this.scrollView = [0, 0]; // w, h\n    /** @type {[Number, Number, Number, Number]} */\n    this.dragArea = [0, 0, 0, 0]; // x, y, w, h\n    /** @type {[Number, Number, Number, Number]} */\n    this.containerBounds = [-1e12, maxValue, maxValue, -1e12]; // t, r, b, l\n    /** @type {[Number, Number, Number, Number]} */\n    this.scrollBounds = [0, 0, 0, 0]; // t, r, b, l\n    /** @type {[Number, Number, Number, Number]} */\n    this.targetBounds = [0, 0, 0, 0]; // t, r, b, l\n    /** @type {[Number, Number]} */\n    this.window = [0, 0]; // w, h\n    /** @type {[Number, Number, Number]} */\n    this.velocityStack = [0, 0, 0];\n    /** @type {Number} */\n    this.velocityStackIndex = 0;\n    /** @type {Number} */\n    this.velocityTime = now();\n    /** @type {Number} */\n    this.velocity = 0;\n    /** @type {Number} */\n    this.angle = 0;\n    /** @type {JSAnimation} */\n    this.cursorStyles = null;\n    /** @type {JSAnimation} */\n    this.triggerStyles = null;\n    /** @type {JSAnimation} */\n    this.bodyStyles = null;\n    /** @type {JSAnimation} */\n    this.targetStyles = null;\n    /** @type {JSAnimation} */\n    this.touchActionStyles = null;\n    this.transforms = new Transforms(this.$target);\n    this.overshootCoords = { x: 0, y: 0 };\n    this.overshootXTicker = new Timer({ autoplay: false }, null, 0).init();\n    this.overshootYTicker = new Timer({ autoplay: false }, null, 0).init();\n    this.updateTicker = new Timer({ autoplay: false }, null, 0).init();\n    this.overshootXTicker.onUpdate = () => {\n      if (this.disabled[0]) return;\n      this.updated = true;\n      this.manual = true;\n      this.animate[this.xProp](this.overshootCoords.x, 0);\n    };\n    this.overshootXTicker.onComplete = () => {\n      if (this.disabled[0]) return;\n      this.manual = false;\n      this.animate[this.xProp](this.overshootCoords.x, 0);\n    };\n    this.overshootYTicker.onUpdate = () => {\n      if (this.disabled[1]) return;\n      this.updated = true;\n      this.manual = true;\n      this.animate[this.yProp](this.overshootCoords.y, 0);\n    };\n    this.overshootYTicker.onComplete = () => {\n      if (this.disabled[1]) return;\n      this.manual = false;\n      this.animate[this.yProp](this.overshootCoords.y, 0);\n    };\n    this.updateTicker.onUpdate = () => this.update();\n    this.contained = !isUnd(container);\n    this.manual = false;\n    this.grabbed = false;\n    this.dragged = false;\n    this.updated = false;\n    this.released = false;\n    this.canScroll = false;\n    this.enabled = false;\n    this.initialized = false;\n    this.activeProp = this.disabled[1] ? xProp : yProp;\n    this.animate.animations[this.activeProp].onRender = () => {\n      const hasUpdated = this.updated;\n      const hasMoved = this.grabbed && hasUpdated;\n      const hasReleased = !hasMoved && this.released;\n      const x = this.x;\n      const y = this.y;\n      const dx = x - this.coords[2];\n      const dy = y - this.coords[3];\n      this.deltaX = dx;\n      this.deltaY = dy;\n      this.coords[2] = x;\n      this.coords[3] = y;\n      // Check if dx or dy are not 0 to check if the draggable has actually moved https://github.com/juliangarnier/anime/issues/1032\n      if (hasUpdated && (dx || dy)) {\n        this.onUpdate(this);\n      }\n      if (!hasReleased) {\n        this.updated = false;\n      } else {\n        this.computeVelocity(dx, dy);\n        this.angle = atan2(dy, dx);\n      }\n    };\n    this.animate.animations[this.activeProp].onComplete = () => {\n      if ((!this.grabbed && this.released)) {\n        // Set eleased to false before calling onSettle to avoid recursion\n        this.released = false;\n      }\n      if (!this.manual) {\n        this.deltaX = 0;\n        this.deltaY = 0;\n        this.velocity = 0;\n        this.velocityStack[0] = 0;\n        this.velocityStack[1] = 0;\n        this.velocityStack[2] = 0;\n        this.velocityStackIndex = 0;\n        this.onSettle(this);\n      }\n    };\n    this.resizeTicker = new Timer({\n      autoplay: false,\n      duration: 150 * globals.timeScale,\n      onComplete: () => {\n        this.onResize(this);\n        this.refresh();\n        this.onAfterResize(this);\n      },\n    }).init();\n    this.parameters = parameters;\n    this.resizeObserver = new ResizeObserver(() => {\n      if (this.initialized) {\n        this.resizeTicker.restart();\n      } else {\n        this.initialized = true;\n      }\n    });\n    this.enable();\n    this.refresh();\n    this.resizeObserver.observe(this.$container);\n    if (!isObj(target)) this.resizeObserver.observe(this.$target);\n  }\n\n  /**\n   * @param  {Number} dx\n   * @param  {Number} dy\n   * @return {Number}\n   */\n  computeVelocity(dx, dy) {\n    const prevTime = this.velocityTime;\n    const curTime = now();\n    const elapsed = curTime - prevTime;\n    if (elapsed < 17) return this.velocity;\n    this.velocityTime = curTime;\n    const velocityStack = this.velocityStack;\n    const vMul = this.velocityMultiplier;\n    const minV = this.minVelocity;\n    const maxV = this.maxVelocity;\n    const vi = this.velocityStackIndex;\n    velocityStack[vi] = round(clamp((sqrt(dx * dx + dy * dy) / elapsed) * vMul, minV, maxV), 5);\n    const velocity = max(velocityStack[0], velocityStack[1], velocityStack[2]);\n    this.velocity = velocity;\n    this.velocityStackIndex = (vi + 1) % 3;\n    return velocity;\n  }\n\n  /**\n   * @param {Number}  x\n   * @param {Boolean} [muteUpdateCallback]\n   * @return {this}\n   */\n  setX(x, muteUpdateCallback = false) {\n    if (this.disabled[0]) return;\n    const v = round(x, 5);\n    this.overshootXTicker.pause();\n    this.manual = true;\n    this.updated = !muteUpdateCallback;\n    this.destX = v;\n    this.snapped[0] = snap(v, this.snapX);\n    this.animate[this.xProp](v, 0);\n    this.manual = false;\n    return this;\n  }\n\n  /**\n   * @param {Number}  y\n   * @param {Boolean} [muteUpdateCallback]\n   * @return {this}\n   */\n  setY(y, muteUpdateCallback = false) {\n    if (this.disabled[1]) return;\n    const v = round(y, 5);\n    this.overshootYTicker.pause();\n    this.manual = true;\n    this.updated = !muteUpdateCallback;\n    this.destY = v;\n    this.snapped[1] = snap(v, this.snapY);\n    this.animate[this.yProp](v, 0);\n    this.manual = false;\n    return this;\n  }\n\n  get x() {\n    return round(/** @type {Number} */(this.animate[this.xProp]()), globals.precision);\n  }\n\n  set x(x) {\n    this.setX(x, false);\n  }\n\n  get y() {\n    return round(/** @type {Number} */(this.animate[this.yProp]()), globals.precision);\n  }\n\n  set y(y) {\n    this.setY(y, false);\n  }\n\n  get progressX() {\n    return mapRange(this.x, this.containerBounds[3], this.containerBounds[1], 0, 1);\n  }\n\n  set progressX(x) {\n    this.setX(mapRange(x, 0, 1, this.containerBounds[3], this.containerBounds[1]), false);\n  }\n\n  get progressY() {\n    return mapRange(this.y, this.containerBounds[0], this.containerBounds[2], 0, 1);\n  }\n\n  set progressY(y) {\n    this.setY(mapRange(y, 0, 1, this.containerBounds[0], this.containerBounds[2]), false);\n  }\n\n  updateScrollCoords() {\n    const sx = round(this.useWin ? win.scrollX : this.$container.scrollLeft, 0);\n    const sy = round(this.useWin ? win.scrollY : this.$container.scrollTop, 0);\n    const [ cpt, cpr, cpb, cpl ] = this.containerPadding;\n    const threshold = this.scrollThreshold;\n    this.scroll.x = sx;\n    this.scroll.y = sy;\n    this.scrollBounds[0] = sy - this.targetBounds[0] + cpt - threshold;\n    this.scrollBounds[1] = sx - this.targetBounds[1] - cpr + threshold;\n    this.scrollBounds[2] = sy - this.targetBounds[2] - cpb + threshold;\n    this.scrollBounds[3] = sx - this.targetBounds[3] + cpl - threshold;\n  }\n\n  updateBoundingValues() {\n    const $container = this.$container;\n    const cx = this.x;\n    const cy = this.y;\n    const cx2 = this.coords[2];\n    const cy2 =  this.coords[3];\n    // Prevents interfering with the scroll area in cases the target is outside of the container\n    // Make sure the temp coords are also adjuset to prevents wrong delta calculation on updates\n    this.coords[2] = 0;\n    this.coords[3] = 0;\n    this.setX(0, true);\n    this.setY(0, true);\n    this.transforms.remove();\n    const iw = this.window[0] = win.innerWidth;\n    const ih = this.window[1] = win.innerHeight;\n    const uw = this.useWin;\n    const sw = $container.scrollWidth;\n    const sh = $container.scrollHeight;\n    const fx = this.fixed;\n    const transformContainerRect = $container.getBoundingClientRect();\n    const [ cpt, cpr, cpb, cpl ] = this.containerPadding;\n    this.dragArea[0] = uw ? 0 : transformContainerRect.left;\n    this.dragArea[1] = uw ? 0 : transformContainerRect.top;\n    this.scrollView[0] = uw ? clamp(sw, iw, sw) : sw;\n    this.scrollView[1] = uw ? clamp(sh, ih, sh) : sh;\n    this.updateScrollCoords();\n    const { width, height, left, top, right, bottom } = $container.getBoundingClientRect();\n    this.dragArea[2] = round(uw ? clamp(width, iw, iw) : width, 0);\n    this.dragArea[3] = round(uw ? clamp(height, ih, ih) : height, 0);\n    const containerOverflow = getTargetValue($container, 'overflow');\n    const visibleOverflow = containerOverflow === 'visible';\n    const hiddenOverflow = containerOverflow === 'hidden';\n    this.canScroll = fx ? false :\n      this.contained &&\n      (($container === doc.body && visibleOverflow) || (!hiddenOverflow && !visibleOverflow)) &&\n      (sw > this.dragArea[2] + cpl - cpr || sh > this.dragArea[3] + cpt - cpb) &&\n      (!this.containerArray || (this.containerArray && !isArr(this.containerArray)));\n    if (this.contained) {\n      const sx = this.scroll.x;\n      const sy = this.scroll.y;\n      const canScroll = this.canScroll;\n      const targetRect = this.$target.getBoundingClientRect();\n      const hiddenLeft = canScroll ? uw ? 0 : $container.scrollLeft : 0;\n      const hiddenTop = canScroll ? uw ? 0 : $container.scrollTop : 0;\n      const hiddenRight = canScroll ? this.scrollView[0] - hiddenLeft - width : 0;\n      const hiddenBottom = canScroll ? this.scrollView[1] - hiddenTop - height : 0;\n      this.targetBounds[0] = round((targetRect.top + sy) - (uw ? 0 : top), 0);\n      this.targetBounds[1] = round((targetRect.right + sx) - (uw ? iw : right), 0);\n      this.targetBounds[2] = round((targetRect.bottom + sy) - (uw ? ih : bottom), 0);\n      this.targetBounds[3] = round((targetRect.left + sx) - (uw ? 0 : left), 0);\n      if (this.containerArray) {\n        this.containerBounds[0] = this.containerArray[0] + cpt;\n        this.containerBounds[1] = this.containerArray[1] - cpr;\n        this.containerBounds[2] = this.containerArray[2] - cpb;\n        this.containerBounds[3] = this.containerArray[3] + cpl;\n      } else {\n        this.containerBounds[0] = -round(targetRect.top - (fx ? clamp(top, 0, ih) : top) + hiddenTop - cpt, 0);\n        this.containerBounds[1] = -round(targetRect.right - (fx ? clamp(right, 0, iw) : right) - hiddenRight + cpr, 0);\n        this.containerBounds[2] = -round(targetRect.bottom - (fx ? clamp(bottom, 0, ih) : bottom) - hiddenBottom + cpb, 0);\n        this.containerBounds[3] = -round(targetRect.left - (fx ? clamp(left, 0, iw) : left) + hiddenLeft - cpl, 0);\n      }\n    }\n    this.transforms.revert();\n    // Restore coordinates\n    this.coords[2] = cx2;\n    this.coords[3] = cy2;\n    this.setX(cx, true);\n    this.setY(cy, true);\n  }\n\n  /**\n   * Returns 0 if not OB, 1 if x is OB, 2 if y is OB, 3 if both x and y are OB\n   *\n   * @param  {Array} bounds\n   * @param  {Number} x\n   * @param  {Number} y\n   * @return {Number}\n   */\n  isOutOfBounds(bounds, x, y) {\n    if (!this.contained) return 0;\n    const [ bt, br, bb, bl ] = bounds;\n    const [ dx, dy ] = this.disabled;\n    const obx = !dx && x < bl || !dx && x > br;\n    const oby = !dy && y < bt || !dy && y > bb;\n    return obx && !oby ? 1 : !obx && oby ? 2 : obx && oby ? 3 : 0;\n  }\n\n  refresh() {\n    const params = this.parameters;\n    const paramX = params.x;\n    const paramY = params.y;\n    const container = parseDraggableFunctionParameter(params.container, this);\n    const cp = parseDraggableFunctionParameter(params.containerPadding, this) || 0;\n    const containerPadding = /** @type {[Number, Number, Number, Number]} */(isArr(cp) ? cp : [cp, cp, cp, cp]);\n    const cx = this.x;\n    const cy = this.y;\n    const parsedCursorStyles = parseDraggableFunctionParameter(params.cursor, this);\n    const cursorStyles = { onHover: 'grab', onGrab: 'grabbing' };\n    if (parsedCursorStyles) {\n      const { onHover, onGrab } = /** @type {DraggableCursorParams} */(parsedCursorStyles);\n      if (onHover) cursorStyles.onHover = onHover;\n      if (onGrab) cursorStyles.onGrab = onGrab;\n    }\n    this.containerArray = isArr(container) ? container : null;\n    this.$container = /** @type {HTMLElement} */(container && !this.containerArray ? parseTargets(/** @type {DOMTarget} */(container))[0] : doc.body);\n    this.useWin = this.$container === doc.body;\n    /** @type {Window | HTMLElement} */\n    this.$scrollContainer = this.useWin ? win : this.$container;\n    this.isFinePointer = matchMedia('(pointer:fine)').matches;\n    this.containerPadding = setValue(containerPadding, [0, 0, 0, 0]);\n    this.containerFriction = clamp(setValue(parseDraggableFunctionParameter(params.containerFriction, this), .8), 0, 1);\n    this.releaseContainerFriction = clamp(setValue(parseDraggableFunctionParameter(params.releaseContainerFriction, this), this.containerFriction), 0, 1);\n    this.snapX = parseDraggableFunctionParameter(isObj(paramX) && !isUnd(paramX.snap) ? paramX.snap : params.snap, this);\n    this.snapY = parseDraggableFunctionParameter(isObj(paramY) && !isUnd(paramY.snap) ? paramY.snap : params.snap, this);\n    this.scrollSpeed = setValue(parseDraggableFunctionParameter(params.scrollSpeed, this), 1.5);\n    this.scrollThreshold = setValue(parseDraggableFunctionParameter(params.scrollThreshold, this), 20);\n    this.dragSpeed = setValue(parseDraggableFunctionParameter(params.dragSpeed, this), 1);\n    this.minVelocity = setValue(parseDraggableFunctionParameter(params.minVelocity, this), 0);\n    this.maxVelocity = setValue(parseDraggableFunctionParameter(params.maxVelocity, this), 50);\n    this.velocityMultiplier = setValue(parseDraggableFunctionParameter(params.velocityMultiplier, this), 1);\n    this.cursor = parsedCursorStyles === false ? false : cursorStyles;\n    this.updateBoundingValues();\n\n    // const ob = this.isOutOfBounds(this.containerBounds, this.x, this.y);\n    // if (ob === 1 || ob === 3) this.progressX = px;\n    // if (ob === 2 || ob === 3) this.progressY = py;\n\n    // if (this.initialized && this.contained) {\n    //   if (this.progressX !== px) this.progressX = px;\n    //   if (this.progressY !== py) this.progressY = py;\n    // }\n\n    const [ bt, br, bb, bl ] = this.containerBounds;\n    this.setX(clamp(cx, bl, br), true);\n    this.setY(clamp(cy, bt, bb), true);\n  }\n\n  update() {\n    this.updateScrollCoords();\n    if (this.canScroll) {\n      const [ cpt, cpr, cpb, cpl ] = this.containerPadding;\n      const [ sw, sh ] = this.scrollView;\n      const daw = this.dragArea[2];\n      const dah = this.dragArea[3];\n      const csx = this.scroll.x;\n      const csy = this.scroll.y;\n      const nsw = this.$container.scrollWidth;\n      const nsh = this.$container.scrollHeight;\n      const csw = this.useWin ? clamp(nsw, this.window[0], nsw) : nsw;\n      const csh = this.useWin ? clamp(nsh, this.window[1], nsh) : nsh;\n      const swd = sw - csw;\n      const shd = sh - csh;\n      // Handle cases where the scrollarea dimensions changes during drag\n      if (this.dragged && swd > 0) {\n        this.coords[0] -= swd;\n        this.scrollView[0] = csw;\n      }\n      if (this.dragged && shd > 0) {\n        this.coords[1] -= shd;\n        this.scrollView[1] = csh;\n      }\n      // Handle autoscroll when target is at the edges of the scroll bounds\n      const s = this.scrollSpeed * 10;\n      const threshold = this.scrollThreshold;\n      const [ x, y ] = this.coords;\n      const [ st, sr, sb, sl ] = this.scrollBounds;\n      const t = round(clamp((y - st + cpt) / threshold, -1, 0) * s, 0);\n      const r = round(clamp((x - sr - cpr) / threshold, 0, 1) * s, 0);\n      const b = round(clamp((y - sb - cpb) / threshold, 0, 1) * s, 0);\n      const l = round(clamp((x - sl + cpl) / threshold, -1, 0) * s, 0);\n      if (t || b || l || r) {\n        const [nx, ny] = this.disabled;\n        let scrollX = csx;\n        let scrollY = csy;\n        if (!nx) {\n          scrollX = round(clamp(csx + (l || r), 0, sw - daw), 0);\n          this.coords[0] -= csx - scrollX;\n        }\n        if (!ny) {\n          scrollY = round(clamp(csy + (t || b), 0, sh - dah), 0);\n          this.coords[1] -= csy - scrollY;\n        }\n        // Note: Safari mobile requires to use different scroll methods depending if using the window or not\n        if (this.useWin) {\n          this.$scrollContainer.scrollBy(-(csx - scrollX), -(csy - scrollY));\n        } else {\n          this.$scrollContainer.scrollTo(scrollX, scrollY);\n        }\n      }\n    }\n    const [ ct, cr, cb, cl ] = this.containerBounds;\n    const [ px1, py1, px2, py2, px3, py3 ] = this.pointer;\n    this.coords[0] += (px1 - px3) * this.dragSpeed;\n    this.coords[1] += (py1 - py3) * this.dragSpeed;\n    this.pointer[4] = px1;\n    this.pointer[5] = py1;\n    const [ cx, cy ] = this.coords;\n    const [ sx, sy ] = this.snapped;\n    const cf = (1 - this.containerFriction) * this.dragSpeed;\n    this.setX(cx > cr ? cr + (cx - cr) * cf : cx < cl ? cl + (cx - cl) * cf : cx, false);\n    this.setY(cy > cb ? cb + (cy - cb) * cf : cy < ct ? ct + (cy - ct) * cf : cy, false);\n    this.computeVelocity(px1 - px3, py1 - py3);\n    this.angle = atan2(py1 - py2, px1 - px2);\n    const [ nsx, nsy ] = this.snapped;\n    if (nsx !== sx && this.snapX || nsy !== sy && this.snapY) {\n      this.onSnap(this);\n    }\n  }\n\n  stop() {\n    this.updateTicker.pause();\n    this.overshootXTicker.pause();\n    this.overshootYTicker.pause();\n    // Pauses the in bounds onRelease animations\n    for (let prop in this.animate.animations) this.animate.animations[prop].pause();\n    remove(this, null, 'x');\n    remove(this, null, 'y');\n    remove(this, null, 'progressX');\n    remove(this, null, 'progressY');\n    remove(this.scroll); // Removes any active animations on the container scroll\n    remove(this.overshootCoords); // Removes active overshoot animations\n    return this;\n  }\n\n  /**\n   * @param {Number} [duration]\n   * @param {Number} [gap]\n   * @param {EasingParam} [ease]\n   * @return {this}\n   */\n  scrollInView(duration, gap = 0, ease = eases.inOutQuad) {\n    this.updateScrollCoords();\n    const x = this.destX;\n    const y = this.destY;\n    const scroll = this.scroll;\n    const scrollBounds = this.scrollBounds;\n    const canScroll = this.canScroll;\n    if (!this.containerArray && this.isOutOfBounds(scrollBounds, x, y)) {\n      const [ st, sr, sb, sl ] = scrollBounds;\n      const t = round(clamp(y - st, -1e12, 0), 0);\n      const r = round(clamp(x - sr, 0, maxValue), 0);\n      const b = round(clamp(y - sb, 0, maxValue), 0);\n      const l = round(clamp(x - sl, -1e12, 0), 0);\n      new JSAnimation(scroll, {\n        x: round(scroll.x + (l ? l - gap : r ? r + gap : 0), 0),\n        y: round(scroll.y + (t ? t - gap : b ? b + gap : 0), 0),\n        duration: isUnd(duration) ? 350 * globals.timeScale : duration,\n        ease,\n        onUpdate: () => {\n          this.canScroll = false;\n          this.$scrollContainer.scrollTo(scroll.x, scroll.y);\n        }\n      }).init().then(() => {\n        this.canScroll = canScroll;\n      });\n    }\n    return this;\n  }\n\n  handleHover() {\n    if (this.isFinePointer && this.cursor && !this.cursorStyles) {\n      this.cursorStyles = setTargetValues(this.$trigger, {\n        cursor: /** @type {DraggableCursorParams} */(this.cursor).onHover\n      });\n    }\n  }\n\n  /**\n   * @param  {Number} [duration]\n   * @param  {Number} [gap]\n   * @param  {EasingParam} [ease]\n   * @return {this}\n   */\n  animateInView(duration, gap = 0, ease = eases.inOutQuad) {\n    this.stop();\n    this.updateBoundingValues();\n    const x = this.x;\n    const y = this.y;\n    const [ cpt, cpr, cpb, cpl ] = this.containerPadding;\n    const bt = this.scroll.y - this.targetBounds[0] + cpt + gap;\n    const br = this.scroll.x - this.targetBounds[1] - cpr - gap;\n    const bb = this.scroll.y - this.targetBounds[2] - cpb - gap;\n    const bl = this.scroll.x - this.targetBounds[3] + cpl + gap;\n    const ob = this.isOutOfBounds([bt, br, bb, bl], x, y);\n    if (ob) {\n      const [ disabledX, disabledY ] = this.disabled;\n      const destX = clamp(snap(x, this.snapX), bl, br);\n      const destY = clamp(snap(y, this.snapY), bt, bb);\n      const dur = isUnd(duration) ? 350 * globals.timeScale : duration;\n      if (!disabledX && (ob === 1 || ob === 3)) this.animate[this.xProp](destX, dur, ease);\n      if (!disabledY && (ob === 2 || ob === 3)) this.animate[this.yProp](destY, dur, ease);\n    }\n    return this;\n  }\n\n  /**\n   * @param {MouseEvent|TouchEvent} e\n   */\n  handleDown(e) {\n    const $eTarget = /** @type {HTMLElement} */(e.target);\n    if (this.grabbed || /** @type {HTMLInputElement}  */($eTarget).type === 'range') return;\n\n    e.stopPropagation();\n\n    this.grabbed = true;\n    this.released = false;\n    this.stop();\n    this.updateBoundingValues();\n    const touches = /** @type {TouchEvent} */(e).changedTouches;\n    const eventX = touches ? touches[0].clientX : /** @type {MouseEvent} */(e).clientX;\n    const eventY = touches ? touches[0].clientY : /** @type {MouseEvent} */(e).clientY;\n    const { x, y } = this.transforms.normalizePoint(eventX, eventY);\n    const [ ct, cr, cb, cl ] = this.containerBounds;\n    const cf = (1 - this.containerFriction) * this.dragSpeed;\n    const cx = this.x;\n    const cy = this.y;\n    this.coords[0] = this.coords[2] = !cf ? cx : cx > cr ? cr + (cx - cr) / cf : cx < cl ? cl + (cx - cl) / cf : cx;\n    this.coords[1] = this.coords[3] = !cf ? cy : cy > cb ? cb + (cy - cb) / cf : cy < ct ? ct + (cy - ct) / cf : cy;\n    this.pointer[0] = x;\n    this.pointer[1] = y;\n    this.pointer[2] = x;\n    this.pointer[3] = y;\n    this.pointer[4] = x;\n    this.pointer[5] = y;\n    this.pointer[6] = x;\n    this.pointer[7] = y;\n    this.deltaX = 0;\n    this.deltaY = 0;\n    this.velocity = 0;\n    this.velocityStack[0] = 0;\n    this.velocityStack[1] = 0;\n    this.velocityStack[2] = 0;\n    this.velocityStackIndex = 0;\n    this.angle = 0;\n    if (this.targetStyles) {\n      this.targetStyles.revert();\n      this.targetStyles = null;\n    }\n    const z = /** @type {Number} */(getTargetValue(this.$target, 'zIndex', false));\n    zIndex = (z > zIndex ? z : zIndex) + 1;\n    this.targetStyles = setTargetValues(this.$target, { zIndex });\n    if (this.triggerStyles) {\n      this.triggerStyles.revert();\n      this.triggerStyles = null;\n    }\n    if (this.cursorStyles) {\n      this.cursorStyles.revert();\n      this.cursorStyles = null;\n    }\n    if (this.isFinePointer && this.cursor) {\n      this.bodyStyles = setTargetValues(doc.body, {\n        cursor: /** @type {DraggableCursorParams} */(this.cursor).onGrab\n      });\n    }\n    this.scrollInView(100, 0, eases.out(3));\n    this.onGrab(this);\n\n    doc.addEventListener('touchmove', this);\n    doc.addEventListener('touchend', this);\n    doc.addEventListener('touchcancel', this);\n    doc.addEventListener('mousemove', this);\n    doc.addEventListener('mouseup', this);\n    doc.addEventListener('selectstart', this);\n  }\n\n  /**\n   * @param {MouseEvent|TouchEvent} e\n   */\n  handleMove(e) {\n    if (!this.grabbed) return;\n    const touches = /** @type {TouchEvent} */(e).changedTouches;\n    const eventX = touches ? touches[0].clientX : /** @type {MouseEvent} */(e).clientX;\n    const eventY = touches ? touches[0].clientY : /** @type {MouseEvent} */(e).clientY;\n    const { x, y } = this.transforms.normalizePoint(eventX, eventY);\n    const movedX = x - this.pointer[6];\n    const movedY = y - this.pointer[7];\n\n    let $parent = /** @type {HTMLElement} */(e.target);\n    let isAtTop = false;\n    let isAtBottom = false;\n    let canTouchScroll = false;\n\n    while (touches && $parent && $parent !== this.$trigger) {\n      const overflowY = getTargetValue($parent, 'overflow-y');\n      if (overflowY !== 'hidden' && overflowY !== 'visible') {\n        const { scrollTop, scrollHeight, clientHeight } = $parent;\n        if (scrollHeight > clientHeight) {\n          canTouchScroll = true;\n          isAtTop = scrollTop <= 3;\n          isAtBottom = scrollTop >= (scrollHeight - clientHeight) - 3;\n          break;\n        }\n      }\n      $parent = /** @type {HTMLElement} */($parent.parentNode);\n    }\n\n    if (canTouchScroll && ((!isAtTop && !isAtBottom) || (isAtTop && movedY < 0) || (isAtBottom && movedY > 0))) {\n\n      this.pointer[0] = x;\n      this.pointer[1] = y;\n      this.pointer[2] = x;\n      this.pointer[3] = y;\n      this.pointer[4] = x;\n      this.pointer[5] = y;\n      this.pointer[6] = x;\n      this.pointer[7] = y;\n\n    } else {\n\n      preventDefault(e);\n\n      // Needed to prevents click on handleUp\n      if (!this.triggerStyles) this.triggerStyles = setTargetValues(this.$trigger, { pointerEvents: 'none' });\n      // Needed to prevent page scroll while dragging on touch devvice\n      this.$trigger.addEventListener('touchstart', preventDefault, { passive: false });\n      this.$trigger.addEventListener('touchmove', preventDefault, { passive: false });\n      this.$trigger.addEventListener('touchend', preventDefault);\n\n\n      if ((!this.disabled[0] && abs(movedX) > 3) || (!this.disabled[1] && abs(movedY) > 3)) {\n\n        this.updateTicker.resume();\n        this.pointer[2] = this.pointer[0];\n        this.pointer[3] = this.pointer[1];\n        this.pointer[0] = x;\n        this.pointer[1] = y;\n        this.dragged = true;\n        this.released = false;\n        this.onDrag(this);\n      }\n    }\n  }\n\n  handleUp() {\n\n    if (!this.grabbed) return;\n\n    this.updateTicker.pause();\n\n    if (this.triggerStyles) {\n      this.triggerStyles.revert();\n      this.triggerStyles = null;\n    }\n\n    if (this.bodyStyles) {\n      this.bodyStyles.revert();\n      this.bodyStyles = null;\n    }\n\n    const [ disabledX, disabledY ] = this.disabled;\n    const [ px1, py1, px2, py2, px3, py3 ] = this.pointer;\n    const [ ct, cr, cb, cl ] = this.containerBounds;\n    const [ sx, sy ] = this.snapped;\n    const springX = this.releaseXSpring;\n    const springY = this.releaseYSpring;\n    const releaseEase = this.releaseEase;\n    const hasReleaseSpring = this.hasReleaseSpring;\n    const overshootCoords = this.overshootCoords;\n    const cx = this.x;\n    const cy = this.y;\n    const pv = this.computeVelocity(px1 - px3, py1 - py3);\n    const pa = this.angle = atan2(py1 - py2, px1 - px2);\n    const ds = pv * 150;\n    const cf = (1 - this.releaseContainerFriction) * this.dragSpeed;\n    const nx = cx + (cos(pa) * ds);\n    const ny = cy + (sin(pa) * ds);\n    const bx = nx > cr ? cr + (nx - cr) * cf : nx < cl ? cl + (nx - cl) * cf : nx;\n    const by = ny > cb ? cb + (ny - cb) * cf : ny < ct ? ct + (ny - ct) * cf : ny;\n    const dx = this.destX = clamp(round(snap(bx, this.snapX), 5), cl, cr);\n    const dy = this.destY = clamp(round(snap(by, this.snapY), 5), ct, cb);\n    const ob = this.isOutOfBounds(this.containerBounds, nx, ny);\n\n    let durationX = 0;\n    let durationY = 0;\n    let easeX = releaseEase;\n    let easeY = releaseEase;\n    let longestReleaseDuration = 0;\n\n    overshootCoords.x = cx;\n    overshootCoords.y = cy;\n\n    if (!disabledX) {\n      const directionX = dx === cr ? cx > cr ? -1 : 1 : cx < cl ? -1 : 1;\n      const distanceX = round(cx - dx, 0);\n      springX.velocity = disabledY && hasReleaseSpring ? distanceX ? (ds * directionX) / abs(distanceX) : 0 : pv;\n      const { ease, duration, restDuration } = springX;\n      durationX = cx === dx ? 0 : hasReleaseSpring ? duration : duration - (restDuration * globals.timeScale);\n      if (hasReleaseSpring) easeX = ease;\n      if (durationX > longestReleaseDuration) longestReleaseDuration = durationX;\n    }\n\n    if (!disabledY) {\n      const directionY = dy === cb ? cy > cb ? -1 : 1 : cy < ct ? -1 : 1;\n      const distanceY = round(cy - dy, 0);\n      springY.velocity = disabledX && hasReleaseSpring ? distanceY ? (ds * directionY) / abs(distanceY) : 0 : pv;\n      const { ease, duration, restDuration } = springY;\n      durationY = cy === dy ? 0 : hasReleaseSpring ? duration : duration - (restDuration * globals.timeScale);\n      if (hasReleaseSpring) easeY = ease;\n      if (durationY > longestReleaseDuration) longestReleaseDuration = durationY;\n    }\n\n    if (!hasReleaseSpring && ob && cf && (durationX || durationY)) {\n\n        const composition = compositionTypes.blend;\n\n        new JSAnimation(overshootCoords, {\n          x: { to: bx, duration: durationX * .65 },\n          y: { to: by, duration: durationY * .65 },\n          ease: releaseEase,\n          composition,\n        }).init();\n\n        new JSAnimation(overshootCoords, {\n          x: { to: dx, duration: durationX },\n          y: { to: dy, duration: durationY },\n          ease: releaseEase,\n          composition,\n        }).init();\n\n        this.overshootXTicker.stretch(durationX).restart();\n        this.overshootYTicker.stretch(durationY).restart();\n\n    } else {\n\n      if (!disabledX) this.animate[this.xProp](dx, durationX, easeX);\n      if (!disabledY) this.animate[this.yProp](dy, durationY, easeY);\n\n    }\n\n    this.scrollInView(longestReleaseDuration, this.scrollThreshold, releaseEase);\n\n    let hasSnapped = false;\n\n    if (dx !== sx) {\n      this.snapped[0] = dx;\n      if (this.snapX) hasSnapped = true;\n    }\n\n    if (dy !== sy && this.snapY) {\n      this.snapped[1] = dy;\n      if (this.snapY) hasSnapped = true;\n    }\n\n    if (hasSnapped) this.onSnap(this);\n\n    this.grabbed = false;\n    this.dragged = false;\n    this.updated = true;\n    this.released = true;\n\n    // It's important to trigger the callback after the release animations to be able to cancel them\n    this.onRelease(this);\n\n    this.$trigger.removeEventListener('touchstart', preventDefault);\n    this.$trigger.removeEventListener('touchmove', preventDefault);\n    this.$trigger.removeEventListener('touchend', preventDefault);\n\n    doc.removeEventListener('touchmove', this);\n    doc.removeEventListener('touchend', this);\n    doc.removeEventListener('touchcancel', this);\n    doc.removeEventListener('mousemove', this);\n    doc.removeEventListener('mouseup', this);\n    doc.removeEventListener('selectstart', this);\n  }\n\n  reset() {\n    this.stop();\n    this.resizeTicker.pause();\n    this.grabbed = false;\n    this.dragged = false;\n    this.updated = false;\n    this.released = false;\n    this.canScroll = false;\n    this.setX(0, true);\n    this.setY(0, true);\n    this.coords[0] = 0;\n    this.coords[1] = 0;\n    this.pointer[0] = 0;\n    this.pointer[1] = 0;\n    this.pointer[2] = 0;\n    this.pointer[3] = 0;\n    this.pointer[4] = 0;\n    this.pointer[5] = 0;\n    this.pointer[6] = 0;\n    this.pointer[7] = 0;\n    this.velocity = 0;\n    this.velocityStack[0] = 0;\n    this.velocityStack[1] = 0;\n    this.velocityStack[2] = 0;\n    this.velocityStackIndex = 0;\n    this.angle = 0;\n    return this;\n  }\n\n  enable() {\n    if (!this.enabled) {\n      this.enabled = true;\n      this.$target.classList.remove('is-disabled');\n      this.touchActionStyles = setTargetValues(this.$trigger, {\n        touchAction: this.disabled[0] ? 'pan-x' : this.disabled[1] ? 'pan-y' : 'none'\n      });\n      this.$trigger.addEventListener('touchstart', this, { passive: true });\n      this.$trigger.addEventListener('mousedown', this, { passive: true });\n      this.$trigger.addEventListener('mouseenter', this);\n    }\n    return this;\n  }\n\n  disable() {\n    this.enabled = false;\n    this.grabbed = false;\n    this.dragged = false;\n    this.updated = false;\n    this.released = false;\n    this.canScroll = false;\n    this.touchActionStyles.revert();\n    if (this.cursorStyles) {\n      this.cursorStyles.revert();\n      this.cursorStyles = null;\n    }\n    if (this.triggerStyles) {\n      this.triggerStyles.revert();\n      this.triggerStyles = null;\n    }\n    if (this.bodyStyles) {\n      this.bodyStyles.revert();\n      this.bodyStyles = null;\n    }\n    if (this.targetStyles) {\n      this.targetStyles.revert();\n      this.targetStyles = null;\n    }\n    this.$target.classList.add('is-disabled');\n    this.$trigger.removeEventListener('touchstart', this);\n    this.$trigger.removeEventListener('mousedown', this);\n    this.$trigger.removeEventListener('mouseenter', this);\n    doc.removeEventListener('touchmove', this);\n    doc.removeEventListener('touchend', this);\n    doc.removeEventListener('touchcancel', this);\n    doc.removeEventListener('mousemove', this);\n    doc.removeEventListener('mouseup', this);\n    doc.removeEventListener('selectstart', this);\n    return this;\n  }\n\n  revert() {\n    this.reset();\n    this.disable();\n    this.$target.classList.remove('is-disabled');\n    this.updateTicker.revert();\n    this.overshootXTicker.revert();\n    this.overshootYTicker.revert();\n    this.resizeTicker.revert();\n    this.animate.revert();\n    this.resizeObserver.disconnect();\n    return this;\n  }\n\n  /**\n   * @param {Event} e\n   */\n  handleEvent(e) {\n    switch (e.type) {\n      case 'mousedown':\n        this.handleDown(/** @type {MouseEvent} */(e));\n        break;\n      case 'touchstart':\n        this.handleDown(/** @type {TouchEvent} */(e));\n        break;\n      case 'mousemove':\n        this.handleMove(/** @type {MouseEvent} */(e));\n        break;\n      case 'touchmove':\n        this.handleMove(/** @type {TouchEvent} */(e));\n        break;\n      case 'mouseup':\n        this.handleUp();\n        break;\n      case 'touchend':\n        this.handleUp();\n        break;\n      case 'touchcancel':\n        this.handleUp();\n        break;\n      case 'mouseenter':\n        this.handleHover();\n        break;\n      case 'selectstart':\n        preventDefault(e);\n        break;\n    }\n  }\n}\n\n/**\n * @param {TargetsParam} target\n * @param {DraggableParams} [parameters]\n * @return {Draggable}\n */\nconst createDraggable = (target, parameters) => new Draggable(target, parameters);\n\n\n\n\nclass Scope {\n  /** @param {ScopeParams} [parameters] */\n  constructor(parameters = {}) {\n    if (scope.current) scope.current.register(this);\n    const rootParam = parameters.root;\n    /** @type {Document|DOMTarget} */\n    let root = doc;\n    if (rootParam) {\n      root = /** @type {ReactRef} */(rootParam).current ||\n             /** @type {AngularRef} */(rootParam).nativeElement ||\n             parseTargets(/** @type {DOMTargetSelector} */(rootParam))[0] ||\n             doc;\n    }\n    const scopeDefaults = parameters.defaults;\n    const globalDefault = globals.defaults;\n    const mediaQueries = parameters.mediaQueries;\n    /** @type {DefaultsParams} */\n    this.defaults = scopeDefaults ? mergeObjects(scopeDefaults, globalDefault) : globalDefault;\n    /** @type {Document|DOMTarget} */\n    this.root = root;\n    /** @type {Array<ScopeConstructorCallback>} */\n    this.constructors = [];\n    /** @type {Array<ScopeCleanupCallback>} */\n    this.revertConstructors = [];\n    /** @type {Array<Revertible>} */\n    this.revertibles = [];\n    /** @type {Array<ScopeConstructorCallback | ((scope: this) => Tickable)>} */\n    this.constructorsOnce = [];\n    /** @type {Array<ScopeCleanupCallback>} */\n    this.revertConstructorsOnce = [];\n    /** @type {Array<Revertible>} */\n    this.revertiblesOnce = [];\n    /** @type {Boolean} */\n    this.once = false;\n    /** @type {Number} */\n    this.onceIndex = 0;\n    /** @type {Record<String, ScopeMethod>} */\n    this.methods = {};\n    /** @type {Record<String, Boolean>} */\n    this.matches = {};\n    /** @type {Record<String, MediaQueryList>} */\n    this.mediaQueryLists = {};\n    /** @type {Record<String, any>} */\n    this.data = {};\n    if (mediaQueries) {\n      for (let mq in mediaQueries) {\n        const _mq = win.matchMedia(mediaQueries[mq]);\n        this.mediaQueryLists[mq] = _mq;\n        _mq.addEventListener('change', this);\n      }\n    }\n  }\n\n  /**\n   * @param {Revertible} revertible\n   */\n  register(revertible) {\n    const store = this.once ? this.revertiblesOnce : this.revertibles;\n    store.push(revertible);\n  }\n\n  /**\n   * @template T\n   * @param {ScopedCallback<T>} cb\n   * @return {T}\n   */\n  execute(cb) {\n    let activeScope = scope.current;\n    let activeRoot = scope.root;\n    let activeDefaults = globals.defaults;\n    scope.current = this;\n    scope.root = this.root;\n    globals.defaults = this.defaults;\n    const mqs = this.mediaQueryLists;\n    for (let mq in mqs) this.matches[mq] = mqs[mq].matches;\n    const returned = cb(this);\n    scope.current = activeScope;\n    scope.root = activeRoot;\n    globals.defaults = activeDefaults;\n    return returned;\n  }\n\n  /**\n   * @return {this}\n   */\n  refresh() {\n    this.onceIndex = 0;\n    this.execute(() => {\n      let i = this.revertibles.length;\n      let y = this.revertConstructors.length;\n      while (i--) this.revertibles[i].revert();\n      while (y--) this.revertConstructors[y](this);\n      this.revertibles.length = 0;\n      this.revertConstructors.length = 0;\n      this.constructors.forEach((/** @type {ScopeConstructorCallback} */constructor) => {\n        const revertConstructor = constructor(this);\n        if (isFnc(revertConstructor)) {\n          this.revertConstructors.push(revertConstructor);\n        }\n      });\n    });\n    return this;\n  }\n\n  /**\n   * @overload\n   * @param {String} a1\n   * @param {ScopeMethod} a2\n   * @return {this}\n   *\n   * @overload\n   * @param {ScopeConstructorCallback} a1\n   * @return {this}\n   *\n   * @param {String|ScopeConstructorCallback} a1\n   * @param {ScopeMethod} [a2]\n   */\n  add(a1, a2) {\n    this.once = false;\n    if (isFnc(a1)) {\n      const constructor = /** @type {ScopeConstructorCallback} */(a1);\n      this.constructors.push(constructor);\n      this.execute(() => {\n        const revertConstructor = constructor(this);\n        if (isFnc(revertConstructor)) {\n          this.revertConstructors.push(revertConstructor);\n        }\n      });\n    } else {\n      this.methods[/** @type {String} */(a1)] = (/** @type {any} */...args) => this.execute(() => a2(...args));\n    }\n    return this;\n  }\n\n  /**\n   * @param {ScopeConstructorCallback} scopeConstructorCallback\n   * @return {this}\n   */\n  addOnce(scopeConstructorCallback) {\n    this.once = true;\n    if (isFnc(scopeConstructorCallback)) {\n      const currentIndex = this.onceIndex++;\n      const tracked = this.constructorsOnce[currentIndex];\n      if (tracked) return this;\n      const constructor = /** @type {ScopeConstructorCallback} */(scopeConstructorCallback);\n      this.constructorsOnce[currentIndex] = constructor;\n      this.execute(() => {\n        const revertConstructor = constructor(this);\n        if (isFnc(revertConstructor)) {\n          this.revertConstructorsOnce.push(revertConstructor);\n        }\n      });\n    }\n    return this;\n  }\n\n  /**\n   * @param  {(scope: this) => Tickable} cb\n   * @return {Tickable}\n   */\n  keepTime(cb) {\n    this.once = true;\n    const currentIndex = this.onceIndex++;\n    const tracked = /** @type {(scope: this) => Tickable} */(this.constructorsOnce[currentIndex]);\n    if (isFnc(tracked)) return tracked(this);\n    const constructor = /** @type {(scope: this) => Tickable} */(createRefreshable(cb));\n    this.constructorsOnce[currentIndex] = constructor;\n    let trackedTickable;\n    this.execute(() => {\n      trackedTickable = constructor(this);\n    });\n    return trackedTickable;\n  }\n\n  /**\n   * @param {Event} e\n   */\n  handleEvent(e) {\n    switch (e.type) {\n      case 'change':\n        this.refresh();\n        break;\n    }\n  }\n\n  revert() {\n    const revertibles = this.revertibles;\n    const revertConstructors = this.revertConstructors;\n    const revertiblesOnce = this.revertiblesOnce;\n    const revertConstructorsOnce = this.revertConstructorsOnce;\n    const mqs = this.mediaQueryLists;\n    let i = revertibles.length;\n    let j = revertConstructors.length;\n    let k = revertiblesOnce.length;\n    let l = revertConstructorsOnce.length;\n    while (i--) revertibles[i].revert();\n    while (j--) revertConstructors[j](this);\n    while (k--) revertiblesOnce[k].revert();\n    while (l--) revertConstructorsOnce[l](this);\n    for (let mq in mqs) mqs[mq].removeEventListener('change', this);\n    revertibles.length = 0;\n    revertConstructors.length = 0;\n    this.constructors.length = 0;\n    revertiblesOnce.length = 0;\n    revertConstructorsOnce.length = 0;\n    this.constructorsOnce.length = 0;\n    this.onceIndex = 0;\n    this.matches = {};\n    this.methods = {};\n    this.mediaQueryLists = {};\n    this.data = {};\n  }\n}\n\n/**\n * @param {ScopeParams} [params]\n * @return {Scope}\n */\nconst createScope = params => new Scope(params);\n\n/**\n * @typedef {String|Number} ScrollThresholdValue\n */\n\n/**\n * @return {Number}\n */\nconst getMaxViewHeight = () => {\n  const $el = doc.createElement('div');\n  doc.body.appendChild($el);\n  $el.style.height = '100lvh';\n  const height = $el.offsetHeight;\n  doc.body.removeChild($el);\n  return height;\n};\n\n/**\n * @template {ScrollThresholdValue|String|Number|Boolean|Function|Object} T\n * @param {T | ((observer: ScrollObserver) => T)} value\n * @param {ScrollObserver} scroller\n * @return {T}\n */\nconst parseScrollObserverFunctionParameter = (value, scroller) => value && isFnc(value) ? /** @type {Function} */(value)(scroller) : value;\n\nconst scrollContainers = new Map();\n\nclass ScrollContainer {\n  /**\n   * @param {HTMLElement} $el\n   */\n  constructor($el) {\n    /** @type {HTMLElement} */\n    this.element = $el;\n    /** @type {Boolean} */\n    this.useWin = this.element === doc.body;\n    /** @type {Number} */\n    this.winWidth = 0;\n    /** @type {Number} */\n    this.winHeight = 0;\n    /** @type {Number} */\n    this.width = 0;\n    /** @type {Number} */\n    this.height = 0;\n    /** @type {Number} */\n    this.left = 0;\n    /** @type {Number} */\n    this.top = 0;\n    /** @type {Number} */\n    this.zIndex = 0;\n    /** @type {Number} */\n    this.scrollX = 0;\n    /** @type {Number} */\n    this.scrollY = 0;\n    /** @type {Number} */\n    this.prevScrollX = 0;\n    /** @type {Number} */\n    this.prevScrollY = 0;\n    /** @type {Number} */\n    this.scrollWidth = 0;\n    /** @type {Number} */\n    this.scrollHeight = 0;\n    /** @type {Number} */\n    this.velocity = 0;\n    /** @type {Boolean} */\n    this.backwardX = false;\n    /** @type {Boolean} */\n    this.backwardY = false;\n    /** @type {Timer} */\n    this.scrollTicker = new Timer({\n      autoplay: false,\n      onBegin: () => this.dataTimer.resume(),\n      onUpdate: () => {\n        const backwards = this.backwardX || this.backwardY;\n        forEachChildren(this, (/** @type {ScrollObserver} */child) => child.handleScroll(), backwards);\n      },\n      onComplete: () => this.dataTimer.pause()\n    }).init();\n    /** @type {Timer} */\n    this.dataTimer = new Timer({\n      autoplay: false,\n      frameRate: 30,\n      onUpdate: self => {\n        const dt = self.deltaTime;\n        const px = this.prevScrollX;\n        const py = this.prevScrollY;\n        const nx = this.scrollX;\n        const ny = this.scrollY;\n        const dx = px - nx;\n        const dy = py - ny;\n        this.prevScrollX = nx;\n        this.prevScrollY = ny;\n        if (dx) this.backwardX = px > nx;\n        if (dy) this.backwardY = py > ny;\n        this.velocity = round(dt > 0 ? Math.sqrt(dx * dx + dy * dy) / dt : 0, 5);\n      }\n    }).init();\n    /** @type {Timer} */\n    this.resizeTicker = new Timer({\n      autoplay: false,\n      duration: 250 * globals.timeScale,\n      onComplete: () => {\n        this.updateWindowBounds();\n        this.refreshScrollObservers();\n        this.handleScroll();\n      }\n    }).init();\n    /** @type {Timer} */\n    this.wakeTicker = new Timer({\n      autoplay: false,\n      duration: 500 * globals.timeScale,\n      onBegin: () => {\n        this.scrollTicker.resume();\n      },\n      onComplete: () => {\n        this.scrollTicker.pause();\n      }\n    }).init();\n    /** @type {ScrollObserver} */\n    this._head = null;\n    /** @type {ScrollObserver} */\n    this._tail = null;\n    this.updateScrollCoords();\n    this.updateWindowBounds();\n    this.updateBounds();\n    this.refreshScrollObservers();\n    this.handleScroll();\n    this.resizeObserver = new ResizeObserver(() => this.resizeTicker.restart());\n    this.resizeObserver.observe(this.element);\n    (this.useWin ? win : this.element).addEventListener('scroll', this, false);\n  }\n\n  updateScrollCoords() {\n    const useWin = this.useWin;\n    const $el = this.element;\n    this.scrollX = round(useWin ? win.scrollX : $el.scrollLeft, 0);\n    this.scrollY = round(useWin ? win.scrollY : $el.scrollTop, 0);\n  }\n\n  updateWindowBounds() {\n    this.winWidth = win.innerWidth;\n    this.winHeight = getMaxViewHeight();\n  }\n\n  updateBounds() {\n    const style = getComputedStyle(this.element);\n    const $el = this.element;\n    this.scrollWidth = $el.scrollWidth + parseFloat(style.marginLeft) + parseFloat(style.marginRight);\n    this.scrollHeight = $el.scrollHeight + parseFloat(style.marginTop) + parseFloat(style.marginBottom);\n    this.updateWindowBounds();\n    let width, height;\n    if (this.useWin) {\n      width = this.winWidth;\n      height = this.winHeight;\n    } else {\n      const elRect = $el.getBoundingClientRect();\n      width = elRect.width;\n      height = elRect.height;\n      this.top = elRect.top;\n      this.left = elRect.left;\n    }\n    this.width = width;\n    this.height = height;\n  }\n\n  refreshScrollObservers() {\n    forEachChildren(this, (/** @type {ScrollObserver} */child) => {\n      if (child._debug) {\n        child.removeDebug();\n      }\n    });\n    this.updateBounds();\n    forEachChildren(this, (/** @type {ScrollObserver} */child) => {\n      child.refresh();\n      if (child._debug) {\n        child.debug();\n      }\n    });\n  }\n\n  refresh() {\n    this.updateWindowBounds();\n    this.updateBounds();\n    this.refreshScrollObservers();\n    this.handleScroll();\n  }\n\n  handleScroll() {\n    this.updateScrollCoords();\n    this.wakeTicker.restart();\n  }\n\n  /**\n   * @param {Event} e\n   */\n  handleEvent(e) {\n    switch (e.type) {\n      case 'scroll':\n        this.handleScroll();\n        break;\n    }\n  }\n\n  revert() {\n    this.scrollTicker.cancel();\n    this.dataTimer.cancel();\n    this.resizeTicker.cancel();\n    this.wakeTicker.cancel();\n    this.resizeObserver.disconnect();\n    (this.useWin ? win : this.element).removeEventListener('scroll', this);\n    scrollContainers.delete(this.element);\n  }\n}\n\n/**\n * @param {TargetsParam} target\n * @return {ScrollContainer}\n */\nconst registerAndGetScrollContainer = target => {\n  const $el = /** @type {HTMLElement} */(target ? parseTargets(target)[0] || doc.body : doc.body);\n  let scrollContainer = scrollContainers.get($el);\n  if (!scrollContainer) {\n    scrollContainer = new ScrollContainer($el);\n    scrollContainers.set($el, scrollContainer);\n  }\n  return scrollContainer;\n};\n\n/**\n * @param {HTMLElement} $el\n * @param {Number|string} v\n * @param {Number} size\n * @param {Number} [under]\n * @param {Number} [over]\n * @return {Number}\n */\nconst convertValueToPx = ($el, v, size, under, over) => {\n  const clampMin = v === 'min';\n  const clampMax = v === 'max';\n  const value = v === 'top' || v === 'left' || v === 'start' || clampMin ? 0 :\n                v === 'bottom' || v === 'right' || v === 'end' || clampMax ? '100%' :\n                v === 'center' ? '50%' :\n                v;\n  const { n, u } = decomposeRawValue(value, decomposedOriginalValue);\n  let px = n;\n  if (u === '%') {\n    px = (n / 100) * size;\n  } else if (u) {\n    px = convertValueUnit($el, decomposedOriginalValue, 'px', true).n;\n  }\n  if (clampMax && under < 0) px += under;\n  if (clampMin && over > 0) px += over;\n  return px;\n};\n\n/**\n * @param {HTMLElement} $el\n * @param {ScrollThresholdValue} v\n * @param {Number} size\n * @param {Number} [under]\n * @param {Number} [over]\n * @return {Number}\n */\nconst parseBoundValue = ($el, v, size, under, over) => {\n  /** @type {Number} */\n  let value;\n  if (isStr(v)) {\n    const matchedOperator = relativeValuesExecRgx.exec(/** @type {String} */(v));\n    if (matchedOperator) {\n      const splitter = matchedOperator[0];\n      const operator = splitter[0];\n      const splitted = /** @type {String} */(v).split(splitter);\n      const clampMin = splitted[0] === 'min';\n      const clampMax = splitted[0] === 'max';\n      const valueAPx = convertValueToPx($el, splitted[0], size, under, over);\n      const valueBPx = convertValueToPx($el, splitted[1], size, under, over);\n      if (clampMin) {\n        const min = getRelativeValue(convertValueToPx($el, 'min', size), valueBPx, operator);\n        value = min < valueAPx ? valueAPx : min;\n      } else if (clampMax) {\n        const max = getRelativeValue(convertValueToPx($el, 'max', size), valueBPx, operator);\n        value = max > valueAPx ? valueAPx : max;\n      } else {\n        value = getRelativeValue(valueAPx, valueBPx, operator);\n      }\n    } else {\n      value = convertValueToPx($el, v, size, under, over);\n    }\n  } else {\n    value = /** @type {Number} */(v);\n  }\n  return round(value, 0);\n};\n\n/**\n * @param {JSAnimation} linked\n * @return {HTMLElement}\n */\nconst getAnimationDomTarget = linked => {\n  let $linkedTarget;\n  const linkedTargets = linked.targets;\n  for (let i = 0, l = linkedTargets.length; i < l; i++) {\n    const target = linkedTargets[i];\n    if (target[isDomSymbol]) {\n      $linkedTarget = /** @type {HTMLElement} */(target);\n      break;\n    }\n  }\n  return $linkedTarget;\n};\n\nlet scrollerIndex = 0;\n\nconst debugColors$1 = ['#FF4B4B','#FF971B','#FFC730','#F9F640','#7AFF5A','#18FF74','#17E09B','#3CFFEC','#05DBE9','#33B3F1','#638CF9','#C563FE','#FF4FCF','#F93F8A'];\n\n/**\n * @typedef {Object} ScrollThresholdParam\n * @property {ScrollThresholdValue} [target]\n * @property {ScrollThresholdValue} [container]\n */\n\n/**\n * @callback ScrollObserverAxisCallback\n * @param {ScrollObserver} self\n * @return {'x'|'y'}\n */\n\n/**\n * @callback ScrollThresholdCallback\n * @param {ScrollObserver} self\n * @return {ScrollThresholdValue|ScrollThresholdParam}\n */\n\n/**\n * @typedef {Object} ScrollObserverParams\n * @property {Number|String} [id]\n * @property {Boolean|Number|String|EasingParam} [sync]\n * @property {TargetsParam} [container]\n * @property {TargetsParam} [target]\n * @property {'x'|'y'|ScrollObserverAxisCallback|((observer: ScrollObserver) => 'x'|'y'|ScrollObserverAxisCallback)} [axis]\n * @property {ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback|((observer: ScrollObserver) => ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback)} [enter]\n * @property {ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback|((observer: ScrollObserver) => ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback)} [leave]\n * @property {Boolean|((observer: ScrollObserver) => Boolean)} [repeat]\n * @property {Boolean} [debug]\n * @property {Callback<ScrollObserver>} [onEnter]\n * @property {Callback<ScrollObserver>} [onLeave]\n * @property {Callback<ScrollObserver>} [onEnterForward]\n * @property {Callback<ScrollObserver>} [onLeaveForward]\n * @property {Callback<ScrollObserver>} [onEnterBackward]\n * @property {Callback<ScrollObserver>} [onLeaveBackward]\n * @property {Callback<ScrollObserver>} [onUpdate]\n * @property {Callback<ScrollObserver>} [onSyncComplete]\n */\n\nclass ScrollObserver {\n  /**\n   * @param {ScrollObserverParams} parameters\n   */\n  constructor(parameters = {}) {\n    if (scope.current) scope.current.register(this);\n    const syncMode = setValue(parameters.sync, 'play pause');\n    const ease = syncMode ? parseEasings(/** @type {EasingParam} */(syncMode)) : null;\n    const isLinear = syncMode && (syncMode === 'linear' || syncMode === none);\n    const isEase = syncMode && !(ease === none && !isLinear);\n    const isSmooth = syncMode && (isNum(syncMode) || syncMode === true || isLinear);\n    const isMethods = syncMode && (isStr(syncMode) && !isEase && !isSmooth);\n    const syncMethods = isMethods ? /** @type {String} */(syncMode).split(' ').map(\n      (/** @type {String} */m) => () => {\n        const linked = this.linked;\n        return linked && linked[m] ? linked[m]() : null;\n      }\n    ) : null;\n    const biDirSync = isMethods && syncMethods.length > 2;\n    /** @type {Number} */\n    this.index = scrollerIndex++;\n    /** @type {String|Number} */\n    this.id = !isUnd(parameters.id) ? parameters.id : this.index;\n    /** @type {ScrollContainer} */\n    this.container = registerAndGetScrollContainer(parameters.container);\n    /** @type {HTMLElement} */\n    this.target = null;\n    /** @type {Tickable|WAAPIAnimation} */\n    this.linked = null;\n    /** @type {Boolean} */\n    this.repeat = null;\n    /** @type {Boolean} */\n    this.horizontal = null;\n    /** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */\n    this.enter = null;\n    /** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */\n    this.leave = null;\n    /** @type {Boolean} */\n    this.sync = isEase || isSmooth || !!syncMethods;\n    /** @type {EasingFunction} */\n    this.syncEase = isEase ? ease : null;\n    /** @type {Number} */\n    this.syncSmooth = isSmooth ? syncMode === true || isLinear ? 1 : /** @type {Number} */(syncMode) : null;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncEnter = syncMethods && !biDirSync && syncMethods[0] ? syncMethods[0] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncLeave = syncMethods && !biDirSync && syncMethods[1] ? syncMethods[1] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncEnterForward = syncMethods && biDirSync && syncMethods[0] ? syncMethods[0] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncLeaveForward = syncMethods && biDirSync && syncMethods[1] ? syncMethods[1] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncEnterBackward = syncMethods && biDirSync && syncMethods[2] ? syncMethods[2] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncLeaveBackward = syncMethods && biDirSync && syncMethods[3] ? syncMethods[3] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onEnter = parameters.onEnter || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onLeave = parameters.onLeave || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onEnterForward = parameters.onEnterForward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onLeaveForward = parameters.onLeaveForward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onEnterBackward = parameters.onEnterBackward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onLeaveBackward = parameters.onLeaveBackward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onUpdate = parameters.onUpdate || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncComplete = parameters.onSyncComplete || noop;\n    /** @type {Boolean} */\n    this.reverted = false;\n    /** @type {Boolean} */\n    this.completed = false;\n    /** @type {Boolean} */\n    this.began = false;\n    /** @type {Boolean} */\n    this.isInView = false;\n    /** @type {Boolean} */\n    this.forceEnter = false;\n    /** @type {Boolean} */\n    this.hasEntered = false;\n    // /** @type {Array.<Number>} */\n    // this.offsets = [];\n    /** @type {Number} */\n    this.offset = 0;\n    /** @type {Number} */\n    this.offsetStart = 0;\n    /** @type {Number} */\n    this.offsetEnd = 0;\n    /** @type {Number} */\n    this.distance = 0;\n    /** @type {Number} */\n    this.prevProgress = 0;\n    /** @type {Array} */\n    this.thresholds = ['start', 'end', 'end', 'start'];\n    /** @type {[Number, Number, Number, Number]} */\n    this.coords = [0, 0, 0, 0];\n    /** @type {JSAnimation} */\n    this.debugStyles = null;\n    /** @type {HTMLElement} */\n    this.$debug = null;\n    /** @type {ScrollObserverParams} */\n    this._params = parameters;\n    /** @type {Boolean} */\n    this._debug = setValue(parameters.debug, false);\n    /** @type {ScrollObserver} */\n    this._next = null;\n    /** @type {ScrollObserver} */\n    this._prev = null;\n    addChild(this.container, this);\n    // Wait for the next frame to add to the container in order to handle calls to link()\n    sync(() => {\n      if (this.reverted) return;\n      if (!this.target) {\n        const target = /** @type {HTMLElement} */(parseTargets(parameters.target)[0]);\n        this.target = target || doc.body;\n        this.refresh();\n      }\n      if (this._debug) this.debug();\n    });\n  }\n\n  /**\n   * @param {Tickable|WAAPIAnimation} linked\n   */\n  link(linked) {\n    if (linked) {\n      // Make sure to pause the linked object in case it's added later\n      linked.pause();\n      this.linked = linked;\n      // Try to use a target of the linked object if no target parameters specified\n      if (!this._params.target) {\n        /** @type {HTMLElement} */\n        let $linkedTarget;\n        if (!isUnd(/** @type {JSAnimation} */(linked).targets)) {\n          $linkedTarget = getAnimationDomTarget(/** @type {JSAnimation} */(linked));\n        } else {\n          forEachChildren(/** @type {Timeline} */(linked), (/** @type {JSAnimation} */child) => {\n            if (child.targets && !$linkedTarget) {\n              $linkedTarget = getAnimationDomTarget(/** @type {JSAnimation} */(child));\n            }\n          });\n        }\n        // Fallback to body if no target found\n        this.target = $linkedTarget || doc.body;\n        this.refresh();\n      }\n    }\n    return this;\n  }\n\n  get velocity() {\n    return this.container.velocity;\n  }\n\n  get backward() {\n    return this.horizontal ? this.container.backwardX : this.container.backwardY;\n  }\n\n  get scroll() {\n    return this.horizontal ? this.container.scrollX : this.container.scrollY;\n  }\n\n  get progress() {\n    const p = (this.scroll - this.offsetStart) / this.distance;\n    return p === Infinity || isNaN(p) ? 0 : round(clamp(p, 0, 1), 6);\n  }\n\n  refresh() {\n    this.reverted = false;\n    const params = this._params;\n    this.repeat = setValue(parseScrollObserverFunctionParameter(params.repeat, this), true);\n    this.horizontal = setValue(parseScrollObserverFunctionParameter(params.axis, this), 'y') === 'x';\n    this.enter = setValue(parseScrollObserverFunctionParameter(params.enter, this), 'end start');\n    this.leave = setValue(parseScrollObserverFunctionParameter(params.leave, this), 'start end');\n    this.updateBounds();\n    this.handleScroll();\n    return this;\n  }\n\n  removeDebug() {\n    if (this.$debug) {\n      this.$debug.parentNode.removeChild(this.$debug);\n      this.$debug = null;\n    }\n    if (this.debugStyles) {\n      this.debugStyles.revert();\n      this.$debug = null;\n    }\n    return this;\n  }\n\n  debug() {\n    this.removeDebug();\n    const container = this.container;\n    const isHori = this.horizontal;\n    const $existingDebug = container.element.querySelector(':scope > .animejs-onscroll-debug');\n    const $debug = doc.createElement('div');\n    const $thresholds = doc.createElement('div');\n    const $triggers = doc.createElement('div');\n    const color = debugColors$1[this.index % debugColors$1.length];\n    const useWin = container.useWin;\n    const containerWidth = useWin ? container.winWidth : container.width;\n    const containerHeight = useWin ? container.winHeight : container.height;\n    const scrollWidth = container.scrollWidth;\n    const scrollHeight = container.scrollHeight;\n    const size = this.container.width > 360 ? 320 : 260;\n    const offLeft = isHori ? 0 : 10;\n    const offTop = isHori ? 10 : 0;\n    const half = isHori ? 24 : size / 2;\n    const labelHeight = isHori ? half : 15;\n    const labelWidth = isHori ? 60 : half;\n    const labelSize = isHori ? labelWidth : labelHeight;\n    const repeat = isHori ? 'repeat-x' : 'repeat-y';\n    /**\n     * @param {Number} v\n     * @return {String}\n     */\n    const gradientOffset = v => isHori ? '0px '+(v)+'px' : (v)+'px'+' 2px';\n    /**\n     * @param {String} c\n     * @return {String}\n     */\n    const lineCSS = (c) => `linear-gradient(${isHori ? 90 : 0}deg, ${c} 2px, transparent 1px)`;\n    /**\n     * @param {String} p\n     * @param {Number} l\n     * @param {Number} t\n     * @param {Number} w\n     * @param {Number} h\n     * @return {String}\n     */\n    const baseCSS = (p, l, t, w, h) => `position:${p};left:${l}px;top:${t}px;width:${w}px;height:${h}px;`;\n    $debug.style.cssText = `${baseCSS('absolute', offLeft, offTop, isHori ? scrollWidth : size, isHori ? size : scrollHeight)}\n      pointer-events: none;\n      z-index: ${this.container.zIndex++};\n      display: flex;\n      flex-direction: ${isHori ? 'column' : 'row'};\n      filter: drop-shadow(0px 1px 0px rgba(0,0,0,.75));\n    `;\n    $thresholds.style.cssText = `${baseCSS('sticky', 0, 0, isHori ? containerWidth : half, isHori ? half : containerHeight)}`;\n    if (!$existingDebug) {\n      $thresholds.style.cssText += `background:\n        ${lineCSS('#FFFF')}${gradientOffset(half-10)} / ${isHori ? '100px 100px' : '100px 100px'} ${repeat},\n        ${lineCSS('#FFF8')}${gradientOffset(half-10)} / ${isHori ? '10px 10px' : '10px 10px'} ${repeat};\n      `;\n    }\n    $triggers.style.cssText = `${baseCSS('relative', 0, 0, isHori ? scrollWidth : half, isHori ? half : scrollHeight)}`;\n    if (!$existingDebug) {\n      $triggers.style.cssText += `background:\n        ${lineCSS('#FFFF')}${gradientOffset(0)} / ${isHori ? '100px 10px' : '10px 100px'} ${repeat},\n        ${lineCSS('#FFF8')}${gradientOffset(0)} / ${isHori ? '10px 0px' : '0px 10px'} ${repeat};\n      `;\n    }\n    const labels = [' enter: ', ' leave: '];\n    this.coords.forEach((v, i) => {\n      const isView = i > 1;\n      const value = (isView ? 0 : this.offset) + v;\n      const isTail = i % 2;\n      const isFirst = value < labelSize;\n      const isOver = value > (isView ? isHori ? containerWidth : containerHeight : isHori ? scrollWidth : scrollHeight) - labelSize;\n      const isFlip = (isView ? isTail && !isFirst : !isTail && !isFirst) || isOver;\n      const $label = doc.createElement('div');\n      const $text = doc.createElement('div');\n      const dirProp = isHori ? isFlip ? 'right' : 'left' : isFlip ? 'bottom' : 'top';\n      const flipOffset = isFlip ? (isHori ? labelWidth : labelHeight) + (!isView ? isHori ? -1 : -2 : isHori ? -1 : isOver ? 0 : -2) : !isView ? isHori ? 1 : 0 : isHori ? 1 : 0;\n      // $text.innerHTML = `${!isView ? '' : labels[isTail] + ' '}${this.id}: ${this.thresholds[i]} ${isView ? '' : labels[isTail]}`;\n      $text.innerHTML = `${this.id}${labels[isTail]}${this.thresholds[i]}`;\n      $label.style.cssText = `${baseCSS('absolute', 0, 0, labelWidth, labelHeight)}\n        display: flex;\n        flex-direction: ${isHori ? 'column' : 'row'};\n        justify-content: flex-${isView ? 'start' : 'end'};\n        align-items: flex-${isFlip ? 'end' : 'start'};\n        border-${dirProp}: 2px ${isTail ? 'solid' : 'solid'} ${color};\n      `;\n      $text.style.cssText = `\n        overflow: hidden;\n        max-width: ${(size / 2) - 10}px;\n        height: ${labelHeight};\n        margin-${isHori ? isFlip ? 'right' : 'left' : isFlip ? 'bottom' : 'top'}: -2px;\n        padding: 1px;\n        font-family: ui-monospace, monospace;\n        font-size: 10px;\n        letter-spacing: -.025em;\n        line-height: 9px;\n        font-weight: 600;\n        text-align: ${isHori && isFlip || !isHori && !isView ? 'right' : 'left'};\n        white-space: pre;\n        text-overflow: ellipsis;\n        color: ${isTail ? color : 'rgba(0,0,0,.75)'};\n        background-color: ${isTail ? 'rgba(0,0,0,.65)' : color};\n        border: 2px solid ${isTail ? color : 'transparent'};\n        border-${isHori ? isFlip ? 'top-left' : 'top-right' : isFlip ? 'top-left' : 'bottom-left'}-radius: 5px;\n        border-${isHori ? isFlip ? 'bottom-left' : 'bottom-right' : isFlip ? 'top-right' : 'bottom-right'}-radius: 5px;\n      `;\n      $label.appendChild($text);\n      let position = value - flipOffset + (isHori ? 1 : 0);\n      $label.style[isHori ? 'left' : 'top'] = `${position}px`;\n      // $label.style[isHori ? 'left' : 'top'] = value - flipOffset + (!isFlip && isFirst && !isView ? 1 : isFlip ? 0 : -2) + 'px';\n      (isView ? $thresholds : $triggers).appendChild($label);\n    });\n\n    $debug.appendChild($thresholds);\n    $debug.appendChild($triggers);\n    container.element.appendChild($debug);\n\n    if (!$existingDebug) $debug.classList.add('animejs-onscroll-debug');\n    this.$debug = $debug;\n    const containerPosition = getTargetValue(container.element, 'position');\n    if (containerPosition === 'static') {\n      this.debugStyles = setTargetValues(container.element, { position: 'relative '});\n    }\n\n  }\n\n  updateBounds() {\n    if (this._debug) {\n      this.removeDebug();\n    }\n    let stickys;\n    const $target = this.target;\n    const container = this.container;\n    const isHori = this.horizontal;\n    const linked = this.linked;\n    let linkedTime;\n    let $el = $target;\n    // let offsetX = 0;\n    // let offsetY = 0;\n    // let $offsetParent = $el;\n    /** @type {Element} */\n    if (linked) {\n      linkedTime = linked.currentTime;\n      linked.seek(0, true);\n    }\n    /* Old implementation to get offset and targetSize before fixing https://github.com/juliangarnier/anime/issues/1021\n    // const isContainerStatic = getTargetValue(container.element, 'position') === 'static' ? setTargetValues(container.element, { position: 'relative '}) : false;\n    // while ($el && $el !== container.element && $el !== doc.body) {\n    //   const isSticky = getTargetValue($el, 'position') === 'sticky' ?\n    //                    setTargetValues($el, { position: 'static' }) :\n    //                    false;\n    //   if ($el === $offsetParent) {\n    //     offsetX += $el.offsetLeft || 0;\n    //     offsetY += $el.offsetTop || 0;\n    //     $offsetParent = $el.offsetParent;\n    //   }\n    //   $el = /** @type {HTMLElement} */($el.parentElement);\n    //   if (isSticky) {\n    //     if (!stickys) stickys = [];\n    //     stickys.push(isSticky);\n    //   }\n    // }\n    // if (isContainerStatic) isContainerStatic.revert();\n    // const offset = isHori ? offsetX : offsetY;\n    // const targetSize = isHori ? $target.offsetWidth : $target.offsetHeight;\n\n    while ($el && $el !== container.element && $el !== doc.body) {\n      const isSticky = getTargetValue($el, 'position') === 'sticky' ? setTargetValues($el, { position: 'static' }) : false;\n      $el = $el.parentElement;\n      if (isSticky) {\n        if (!stickys) stickys = [];\n        stickys.push(isSticky);\n      }\n    }\n    const rect = $target.getBoundingClientRect();\n    const offset = isHori ? rect.left + container.scrollX - container.left : rect.top + container.scrollY - container.top;\n    const targetSize = isHori ? rect.width : rect.height;\n    const containerSize = isHori ? container.width : container.height;\n    const scrollSize = isHori ? container.scrollWidth : container.scrollHeight;\n    const maxScroll = scrollSize - containerSize;\n    const enter = this.enter;\n    const leave = this.leave;\n\n    /** @type {ScrollThresholdValue} */\n    let enterTarget = 'start';\n    /** @type {ScrollThresholdValue} */\n    let leaveTarget = 'end';\n    /** @type {ScrollThresholdValue} */\n    let enterContainer = 'end';\n    /** @type {ScrollThresholdValue} */\n    let leaveContainer = 'start';\n\n    if (isStr(enter)) {\n      const splitted = /** @type {String} */(enter).split(' ');\n      enterContainer = splitted[0];\n      enterTarget = splitted.length > 1 ? splitted[1] : enterTarget;\n    } else if (isObj(enter)) {\n      const e = /** @type {ScrollThresholdParam} */(enter);\n      if (!isUnd(e.container)) enterContainer = e.container;\n      if (!isUnd(e.target)) enterTarget = e.target;\n    } else if (isNum(enter)) {\n      enterContainer = /** @type {Number} */(enter);\n    }\n\n    if (isStr(leave)) {\n      const splitted = /** @type {String} */(leave).split(' ');\n      leaveContainer = splitted[0];\n      leaveTarget = splitted.length > 1 ? splitted[1] : leaveTarget;\n    } else if (isObj(leave)) {\n      const t = /** @type {ScrollThresholdParam} */(leave);\n      if (!isUnd(t.container)) leaveContainer = t.container;\n      if (!isUnd(t.target)) leaveTarget = t.target;\n    } else if (isNum(leave)) {\n      leaveContainer = /** @type {Number} */(leave);\n    }\n\n    const parsedEnterTarget = parseBoundValue($target, enterTarget, targetSize);\n    const parsedLeaveTarget = parseBoundValue($target, leaveTarget, targetSize);\n    const under = (parsedEnterTarget + offset) - containerSize;\n    const over = (parsedLeaveTarget + offset) - maxScroll;\n    const parsedEnterContainer = parseBoundValue($target, enterContainer, containerSize, under, over);\n    const parsedLeaveContainer = parseBoundValue($target, leaveContainer, containerSize, under, over);\n    const offsetStart = parsedEnterTarget + offset - parsedEnterContainer;\n    const offsetEnd = parsedLeaveTarget + offset - parsedLeaveContainer;\n    const scrollDelta = offsetEnd - offsetStart;\n    // this.offsets[0] = offsetX;\n    // this.offsets[1] = offsetY;\n    this.offset = offset;\n    this.offsetStart = offsetStart;\n    this.offsetEnd = offsetEnd;\n    this.distance = scrollDelta <= 0 ? 0 : scrollDelta;\n    this.thresholds = [enterTarget, leaveTarget, enterContainer, leaveContainer];\n    this.coords = [parsedEnterTarget, parsedLeaveTarget, parsedEnterContainer, parsedLeaveContainer];\n    if (stickys) {\n      stickys.forEach(sticky => sticky.revert());\n    }\n    if (linked) {\n      linked.seek(linkedTime, true);\n    }\n    if (this._debug) {\n      this.debug();\n    }\n  }\n\n  handleScroll() {\n    const linked = this.linked;\n    const sync = this.sync;\n    const syncEase = this.syncEase;\n    const syncSmooth = this.syncSmooth;\n    const shouldSeek = linked && (syncEase || syncSmooth);\n    const isHori = this.horizontal;\n    const container = this.container;\n    const scroll = this.scroll;\n    const isBefore = scroll <= this.offsetStart;\n    const isAfter = scroll >= this.offsetEnd;\n    const isInView = !isBefore && !isAfter;\n    const isOnTheEdge = scroll === this.offsetStart || scroll === this.offsetEnd;\n    const forceEnter = !this.hasEntered && isOnTheEdge;\n    const $debug = this._debug && this.$debug;\n    let hasUpdated = false;\n    let syncCompleted = false;\n    let p = this.progress;\n\n    if (isBefore && this.began) {\n      this.began = false;\n    }\n\n    if (p > 0 && !this.began) {\n      this.began = true;\n    }\n\n    if (shouldSeek) {\n      const lp = linked.progress;\n      if (syncSmooth && isNum(syncSmooth)) {\n        if (/** @type {Number} */(syncSmooth) < 1) {\n          const step = 0.0001;\n          const snap = lp < p && p === 1 ? step : lp > p && !p ? -1e-4 : 0;\n          p = round(lerp(lp, p, interpolate(.01, .2, /** @type {Number} */(syncSmooth)), false) + snap, 6);\n        }\n      } else if (syncEase) {\n        p = syncEase(p);\n      }\n      hasUpdated = p !== this.prevProgress;\n      syncCompleted = lp === 1;\n      if (hasUpdated && !syncCompleted && (syncSmooth && lp)) {\n        container.wakeTicker.restart();\n      }\n    }\n\n    if ($debug) {\n      const sticky = isHori ? container.scrollY : container.scrollX;\n      $debug.style[isHori ? 'top' : 'left'] = sticky + 10 + 'px';\n    }\n\n    // Trigger enter callbacks if already in view or when entering the view\n    if ((isInView && !this.isInView) || (forceEnter && !this.forceEnter && !this.hasEntered)) {\n      if (isInView) this.isInView = true;\n      if (!this.forceEnter || !this.hasEntered) {\n        if ($debug && isInView) $debug.style.zIndex = `${this.container.zIndex++}`;\n        this.onSyncEnter(this);\n        this.onEnter(this);\n        if (this.backward) {\n          this.onSyncEnterBackward(this);\n          this.onEnterBackward(this);\n        } else {\n          this.onSyncEnterForward(this);\n          this.onEnterForward(this);\n        }\n        this.hasEntered = true;\n        if (forceEnter) this.forceEnter = true;\n      } else if (isInView) {\n        this.forceEnter = false;\n      }\n    }\n\n    if (isInView || !isInView && this.isInView) {\n      hasUpdated = true;\n    }\n\n    if (hasUpdated) {\n      if (shouldSeek) linked.seek(linked.duration * p);\n      this.onUpdate(this);\n    }\n\n    if (!isInView && this.isInView) {\n      this.isInView = false;\n      this.onSyncLeave(this);\n      this.onLeave(this);\n      if (this.backward) {\n        this.onSyncLeaveBackward(this);\n        this.onLeaveBackward(this);\n      } else {\n        this.onSyncLeaveForward(this);\n        this.onLeaveForward(this);\n      }\n      if (sync && !syncSmooth) {\n        syncCompleted = true;\n      }\n    }\n\n    if (p >= 1 && this.began && !this.completed && (sync && syncCompleted || !sync)) {\n      if (sync) {\n        this.onSyncComplete(this);\n      }\n      this.completed = true;\n      if ((!this.repeat && !linked) || (!this.repeat && linked && linked.completed)) {\n        this.revert();\n      }\n    }\n\n    if (p < 1 && this.completed) {\n      this.completed = false;\n    }\n\n    this.prevProgress = p;\n  }\n\n  revert() {\n    if (this.reverted) return;\n    const container = this.container;\n    removeChild(container, this);\n    if (!container._head) {\n      container.revert();\n    }\n    if (this._debug) {\n      this.removeDebug();\n    }\n    this.reverted = true;\n    return this;\n  }\n\n}\n\n/**\n * @param {ScrollObserverParams} [parameters={}]\n * @return {ScrollObserver}\n */\nconst onScroll = (parameters = {}) => new ScrollObserver(parameters);\n\n\n\n\nconst segmenter = !isUnd(Intl) && Intl.Segmenter;\nconst valueRgx = /\\{value\\}/g;\nconst indexRgx = /\\{i\\}/g;\nconst whiteSpaceGroupRgx = /(\\s+)/;\nconst whiteSpaceRgx = /^\\s+$/;\nconst lineType = 'line';\nconst wordType = 'word';\nconst charType = 'char';\nconst dataLine = `data-line`;\n\n/**\n * @typedef {Object} Segment\n * @property {String} segment\n * @property {Boolean} [isWordLike]\n */\n\n/**\n * @typedef {Object} Segmenter\n * @property {function(String): Iterable<Segment>} segment\n */\n\n/** @type {Segmenter} */\nlet wordSegmenter = null;\n/** @type {Segmenter} */\nlet graphemeSegmenter = null;\nlet $splitTemplate = null;\n\n/**\n * @param  {Segment} seg\n * @return {Boolean}\n */\nconst isSegmentWordLike = seg => {\n  return seg.isWordLike ||\n         seg.segment === ' ' || // Consider spaces as words first, then handle them diffrently later\n         isNum(+seg.segment); // Safari doesn't considers numbers as words\n};\n\n/**\n * @param {HTMLElement} $el\n */\nconst setAriaHidden = $el => $el.setAttribute('aria-hidden', 'true');\n\n/**\n * @param {DOMTarget} $el\n * @param {String} type\n * @return {Array<HTMLElement>}\n */\nconst getAllTopLevelElements = ($el, type) => [.../** @type {*} */($el.querySelectorAll(`[data-${type}]:not([data-${type}] [data-${type}])`))];\n\nconst debugColors = { line: '#00D672', word: '#FF4B4B', char: '#5A87FF' };\n\n/**\n * @param {HTMLElement} $el\n */\nconst filterEmptyElements = $el => {\n  if (!$el.childElementCount && !$el.textContent.trim()) {\n    const $parent = $el.parentElement;\n    $el.remove();\n    if ($parent) filterEmptyElements($parent);\n  }\n};\n\n/**\n * @param {HTMLElement} $el\n * @param {Number} lineIndex\n * @param {Set<HTMLElement>} bin\n * @returns {Set<HTMLElement>}\n */\nconst filterLineElements = ($el, lineIndex, bin) => {\n  const dataLineAttr = $el.getAttribute(dataLine);\n  if (dataLineAttr !== null && +dataLineAttr !== lineIndex || $el.tagName === 'BR') bin.add($el);\n  let i = $el.childElementCount;\n  while (i--) filterLineElements(/** @type {HTMLElement} */($el.children[i]), lineIndex, bin);\n  return bin;\n};\n\n/**\n * @param  {'line'|'word'|'char'} type\n * @param  {splitTemplateParams} params\n * @return {String}\n */\nconst generateTemplate = (type, params = {}) => {\n  let template = ``;\n  const classString = isStr(params.class) ? ` class=\"${params.class}\"` : '';\n  const cloneType = setValue(params.clone, false);\n  const wrapType = setValue(params.wrap, false);\n  const overflow = wrapType ? wrapType === true ? 'clip' : wrapType : cloneType ? 'clip' : false;\n  if (wrapType) template += `<span${overflow ? ` style=\"overflow:${overflow};\"` : ''}>`;\n  template += `<span${classString}${cloneType ? ` style=\"position:relative;\"` : ''} data-${type}=\"{i}\">`;\n  if (cloneType) {\n    const left = cloneType === 'left' ? '-100%' : cloneType === 'right' ? '100%' : '0';\n    const top = cloneType === 'top' ? '-100%' : cloneType === 'bottom' ? '100%' : '0';\n    template += `<span>{value}</span>`;\n    template += `<span inert style=\"position:absolute;top:${top};left:${left};white-space:nowrap;\">{value}</span>`;\n  } else {\n    template += `{value}`;\n  }\n  template += `</span>`;\n  if (wrapType) template += `</span>`;\n  return template;\n};\n\n/**\n * @param  {String|SplitFunctionValue} htmlTemplate\n * @param  {Array<HTMLElement>} store\n * @param  {Node|HTMLElement} node\n * @param  {DocumentFragment} $parentFragment\n * @param  {'line'|'word'|'char'} type\n * @param  {Boolean} debug\n * @param  {Number} lineIndex\n * @param  {Number} [wordIndex]\n * @param  {Number} [charIndex]\n * @return {HTMLElement}\n */\nconst processHTMLTemplate = (htmlTemplate, store, node, $parentFragment, type, debug, lineIndex, wordIndex, charIndex) => {\n  const isLine = type === lineType;\n  const isChar = type === charType;\n  const className = `_${type}_`;\n  const template = isFnc(htmlTemplate) ? htmlTemplate(node) : htmlTemplate;\n  const displayStyle = isLine ? 'block' : 'inline-block';\n  $splitTemplate.innerHTML = template\n    .replace(valueRgx, `<i class=\"${className}\"></i>`)\n    .replace(indexRgx, `${isChar ? charIndex : isLine ? lineIndex : wordIndex}`);\n  const $content = $splitTemplate.content;\n  const $highestParent = /** @type {HTMLElement} */($content.firstElementChild);\n  const $split = /** @type {HTMLElement} */($content.querySelector(`[data-${type}]`)) || $highestParent;\n  const $replacables = /** @type {NodeListOf<HTMLElement>} */($content.querySelectorAll(`i.${className}`));\n  const replacablesLength = $replacables.length;\n  if (replacablesLength) {\n    $highestParent.style.display = displayStyle;\n    $split.style.display = displayStyle;\n    $split.setAttribute(dataLine, `${lineIndex}`);\n    if (!isLine) {\n      $split.setAttribute('data-word', `${wordIndex}`);\n      if (isChar) $split.setAttribute('data-char', `${charIndex}`);\n    }\n    let i = replacablesLength;\n    while (i--) {\n      const $replace = $replacables[i];\n      const $closestParent = $replace.parentElement;\n      $closestParent.style.display = displayStyle;\n      if (isLine) {\n        $closestParent.innerHTML = /** @type {HTMLElement} */(node).innerHTML;\n      } else {\n        $closestParent.replaceChild(node.cloneNode(true), $replace);\n      }\n    }\n    store.push($split);\n    $parentFragment.appendChild($content);\n  } else {\n    console.warn(`The expression \"{value}\" is missing from the provided template.`);\n  }\n  if (debug) $highestParent.style.outline = `1px dotted ${debugColors[type]}`;\n  return $highestParent;\n};\n\n/**\n * A class that splits text into words and wraps them in span elements while preserving the original HTML structure.\n * @class\n */\nclass TextSplitter {\n  /**\n   * @param  {HTMLElement|NodeList|String|Array<HTMLElement>} target\n   * @param  {TextSplitterParams} [parameters]\n   */\n  constructor(target, parameters = {}) {\n    // Only init segmenters when needed\n    if (!wordSegmenter) wordSegmenter = segmenter ? new segmenter([], { granularity: wordType }) : {\n      segment: (text) => {\n        const segments = [];\n        const words = text.split(whiteSpaceGroupRgx);\n        for (let i = 0, l = words.length; i < l; i++) {\n          const segment = words[i];\n          segments.push({\n            segment,\n            isWordLike: !whiteSpaceRgx.test(segment), // Consider non-whitespace as word-like\n          });\n        }\n        return segments;\n      }\n    };\n    if (!graphemeSegmenter) graphemeSegmenter = segmenter ? new segmenter([], { granularity: 'grapheme' }) : {\n      segment: text => [...text].map(char => ({ segment: char }))\n    };\n    if (!$splitTemplate && isBrowser) $splitTemplate = doc.createElement('template');\n    if (scope.current) scope.current.register(this);\n    const { words, chars, lines, accessible, includeSpaces, debug } = parameters;\n    const $target = /** @type {HTMLElement} */((target = isArr(target) ? target[0] : target) && /** @type {Node} */(target).nodeType ? target : (getNodeList(target) || [])[0]);\n    const lineParams = lines === true ? {} : lines;\n    const wordParams = words === true || isUnd(words) ? {} : words;\n    const charParams = chars === true ? {} : chars;\n    this.debug = setValue(debug, false);\n    this.includeSpaces = setValue(includeSpaces, false);\n    this.accessible = setValue(accessible, true);\n    this.linesOnly = lineParams && (!wordParams && !charParams);\n    /** @type {String|false|SplitFunctionValue} */\n    this.lineTemplate = isObj(lineParams) ? generateTemplate(lineType, /** @type {splitTemplateParams} */(lineParams)) : lineParams;\n    /** @type {String|false|SplitFunctionValue} */\n    this.wordTemplate = isObj(wordParams) || this.linesOnly ? generateTemplate(wordType, /** @type {splitTemplateParams} */(wordParams)) : wordParams;\n    /** @type {String|false|SplitFunctionValue} */\n    this.charTemplate = isObj(charParams) ? generateTemplate(charType, /** @type {splitTemplateParams} */(charParams)) : charParams;\n    this.$target = $target;\n    this.html = $target && $target.innerHTML;\n    this.lines = [];\n    this.words = [];\n    this.chars = [];\n    this.effects = [];\n    this.effectsCleanups = [];\n    this.cache = null;\n    this.ready = false;\n    this.width = 0;\n    this.resizeTimeout = null;\n    const handleSplit = () => this.html && (lineParams || wordParams || charParams) && this.split();\n    // Make sure this is declared before calling handleSplit() in case revert() is called inside an effect callback\n    this.resizeObserver = new ResizeObserver(() => {\n      // Use a setTimeout instead of a Timer for better tree shaking\n      clearTimeout(this.resizeTimeout);\n      this.resizeTimeout = setTimeout(() => {\n        const currentWidth = /** @type {HTMLElement} */($target).offsetWidth;\n        if (currentWidth === this.width) return;\n        this.width = currentWidth;\n        handleSplit();\n      }, 150);\n    });\n    // Only declare the font ready promise when splitting by lines and not alreay split\n    if (this.lineTemplate && !this.ready) {\n      doc.fonts.ready.then(handleSplit);\n    } else {\n      handleSplit();\n    }\n    $target ? this.resizeObserver.observe($target) : console.warn('No Text Splitter target found.');\n  }\n\n  /**\n   * @param  {(...args: any[]) => Tickable | (() => void)} effect\n   * @return this\n   */\n  addEffect(effect) {\n    if (!isFnc(effect)) return console.warn('Effect must return a function.');\n    const refreshableEffect = createRefreshable(effect);\n    this.effects.push(refreshableEffect);\n    if (this.ready) this.effectsCleanups[this.effects.length - 1] = refreshableEffect(this);\n    return this;\n  }\n\n  revert() {\n    clearTimeout(this.resizeTimeout);\n    this.lines.length = this.words.length = this.chars.length = 0;\n    this.resizeObserver.disconnect();\n    // Make sure to revert the effects after disconnecting the resizeObserver to avoid triggering it in the process\n    this.effectsCleanups.forEach(cleanup => isFnc(cleanup) ? cleanup(this) : cleanup.revert && cleanup.revert());\n    this.$target.innerHTML = this.html;\n    return this;\n  }\n\n  /**\n   * Recursively processes a node and its children\n   * @param {Node} node\n   */\n  splitNode(node) {\n    const wordTemplate = this.wordTemplate;\n    const charTemplate = this.charTemplate;\n    const includeSpaces = this.includeSpaces;\n    const debug = this.debug;\n    const nodeType = node.nodeType;\n    if (nodeType === 3) {\n      const nodeText = node.nodeValue;\n      // If the nodeText is only whitespace, leave it as is\n      if (nodeText.trim()) {\n        const tempWords = [];\n        const words = this.words;\n        const chars = this.chars;\n        const wordSegments = wordSegmenter.segment(nodeText);\n        const $wordsFragment = doc.createDocumentFragment();\n        let prevSeg = null;\n        for (const wordSegment of wordSegments) {\n          const segment = wordSegment.segment;\n          const isWordLike = isSegmentWordLike(wordSegment);\n          // Determine if this segment should be a new word, first segment always becomes a new word\n          if (!prevSeg || (isWordLike && (prevSeg && (isSegmentWordLike(prevSeg))))) {\n            tempWords.push(segment);\n          } else {\n            // Only concatenate if both current and previous are non-word-like and don't contain spaces\n            const lastWordIndex = tempWords.length - 1;\n            const lastWord = tempWords[lastWordIndex];\n            if (!lastWord.includes(' ') && !segment.includes(' ')) {\n              tempWords[lastWordIndex] += segment;\n            } else {\n              tempWords.push(segment);\n            }\n          }\n          prevSeg = wordSegment;\n        }\n\n        for (let i = 0, l = tempWords.length; i < l; i++) {\n          const word = tempWords[i];\n          if (!word.trim()) {\n            // Preserve whitespace only if includeSpaces is false and if the current space is not the first node\n            if (i && includeSpaces) continue;\n            $wordsFragment.appendChild(doc.createTextNode(word));\n          } else {\n            const nextWord = tempWords[i + 1];\n            const hasWordFollowingSpace = includeSpaces && nextWord && !nextWord.trim();\n            const wordToProcess = word;\n            const charSegments = charTemplate ? graphemeSegmenter.segment(wordToProcess) : null;\n            const $charsFragment = charTemplate ? doc.createDocumentFragment() : doc.createTextNode(hasWordFollowingSpace ? word + '\\xa0' : word);\n            if (charTemplate) {\n              const charSegmentsArray = [...charSegments];\n              for (let j = 0, jl = charSegmentsArray.length; j < jl; j++) {\n                const charSegment = charSegmentsArray[j];\n                const isLastChar = j === jl - 1;\n                // If this is the last character and includeSpaces is true with a following space, append the space\n                const charText = isLastChar && hasWordFollowingSpace ? charSegment.segment + '\\xa0' : charSegment.segment;\n                const $charNode = doc.createTextNode(charText);\n                processHTMLTemplate(charTemplate, chars, $charNode, /** @type {DocumentFragment} */($charsFragment), charType, debug, -1, words.length, chars.length);\n              }\n            }\n            if (wordTemplate) {\n              processHTMLTemplate(wordTemplate, words, $charsFragment, $wordsFragment, wordType, debug, -1, words.length, chars.length);\n              // Chars elements must be re-parsed in the split() method if both words and chars are parsed\n            } else if (charTemplate) {\n              $wordsFragment.appendChild($charsFragment);\n            } else {\n              $wordsFragment.appendChild(doc.createTextNode(word));\n            }\n            // Skip the next iteration if we included a space\n            if (hasWordFollowingSpace) i++;\n          }\n        }\n        node.parentNode.replaceChild($wordsFragment, node);\n      }\n    } else if (nodeType === 1) {\n      // Converting to an array is necessary to work around childNodes pottential mutation\n      const childNodes = /** @type {Array<Node>} */([.../** @type {*} */(node.childNodes)]);\n      for (let i = 0, l = childNodes.length; i < l; i++) this.splitNode(childNodes[i]);\n    }\n  }\n\n  /**\n   * @param {Boolean} clearCache\n   * @return {this}\n   */\n  split(clearCache = false) {\n    const $el = this.$target;\n    const isCached = !!this.cache && !clearCache;\n    const lineTemplate = this.lineTemplate;\n    const wordTemplate = this.wordTemplate;\n    const charTemplate = this.charTemplate;\n    const fontsReady = doc.fonts.status !== 'loading';\n    const canSplitLines = lineTemplate && fontsReady;\n    this.ready = !lineTemplate || fontsReady;\n    if (canSplitLines || clearCache) {\n      // No need to revert effects animations here since it's already taken care by the refreshable\n      this.effectsCleanups.forEach(cleanup => isFnc(cleanup) && cleanup(this));\n    }\n    if (!isCached) {\n      if (clearCache) {\n        $el.innerHTML = this.html;\n        this.words.length = this.chars.length = 0;\n      }\n      this.splitNode($el);\n      this.cache = $el.innerHTML;\n    }\n    if (canSplitLines) {\n      if (isCached) $el.innerHTML = this.cache;\n      this.lines.length = 0;\n      if (wordTemplate) this.words = getAllTopLevelElements($el, wordType);\n    }\n    // Always reparse characters after a line reset or if both words and chars are activated\n    if (charTemplate && (canSplitLines || wordTemplate)) {\n      this.chars = getAllTopLevelElements($el, charType);\n    }\n    // Words are used when lines only and prioritized over chars\n    const elementsArray = this.words.length ? this.words : this.chars;\n    let y, linesCount = 0;\n    for (let i = 0, l = elementsArray.length; i < l; i++) {\n      const $el = elementsArray[i];\n      const { top, height } = $el.getBoundingClientRect();\n      if (y && top - y > height * .5) linesCount++;\n      $el.setAttribute(dataLine, `${linesCount}`);\n      const nested = $el.querySelectorAll(`[${dataLine}]`);\n      let c = nested.length;\n      while (c--) nested[c].setAttribute(dataLine, `${linesCount}`);\n      y = top;\n    }\n    if (canSplitLines) {\n      const linesFragment = doc.createDocumentFragment();\n      const parents = new Set();\n      const clones = [];\n      for (let lineIndex = 0; lineIndex < linesCount + 1; lineIndex++) {\n        const $clone = /** @type {HTMLElement} */($el.cloneNode(true));\n        filterLineElements($clone, lineIndex, new Set()).forEach($el => {\n          const $parent = $el.parentElement;\n          if ($parent) parents.add($parent);\n          $el.remove();\n        });\n        clones.push($clone);\n      }\n      parents.forEach(filterEmptyElements);\n      for (let cloneIndex = 0, clonesLength = clones.length; cloneIndex < clonesLength; cloneIndex++) {\n        processHTMLTemplate(lineTemplate, this.lines, clones[cloneIndex], linesFragment, lineType, this.debug, cloneIndex);\n      }\n      $el.innerHTML = '';\n      $el.appendChild(linesFragment);\n      if (wordTemplate) this.words = getAllTopLevelElements($el, wordType);\n      if (charTemplate) this.chars = getAllTopLevelElements($el, charType);\n    }\n    // Remove the word wrappers and clear the words array if lines split only\n    if (this.linesOnly) {\n      const words = this.words;\n      let w = words.length;\n      while (w--) {\n        const $word = words[w];\n        $word.replaceWith($word.textContent);\n      }\n      words.length = 0;\n    }\n    if (this.accessible && (canSplitLines || !isCached)) {\n      const $accessible = doc.createElement('span');\n      // Make the accessible element visually-hidden (https://www.scottohara.me/blog/2017/04/14/inclusively-hidden.html)\n      $accessible.style.cssText = `position:absolute;overflow:hidden;clip:rect(0 0 0 0);clip-path:inset(50%);width:1px;height:1px;white-space:nowrap;`;\n      // $accessible.setAttribute('tabindex', '-1');\n      $accessible.innerHTML = this.html;\n      $el.insertBefore($accessible, $el.firstChild);\n      this.lines.forEach(setAriaHidden);\n      this.words.forEach(setAriaHidden);\n      this.chars.forEach(setAriaHidden);\n    }\n    this.width = /** @type {HTMLElement} */($el).offsetWidth;\n    if (canSplitLines || clearCache) {\n      this.effects.forEach((effect, i) => this.effectsCleanups[i] = effect(this));\n    }\n    return this;\n  }\n\n  refresh() {\n    this.split(true);\n  }\n}\n\n/**\n * @param  {HTMLElement|NodeList|String|Array<HTMLElement>} target\n * @param  {TextSplitterParams} [parameters]\n * @return {TextSplitter}\n */\nconst split = (target, parameters) => new TextSplitter(target, parameters);\n\nconst text = {\n  split,\n};\n\n\n\n\n/**\n * @param  {Number|String|[Number|String,Number|String]} val\n * @param  {StaggerParams} params\n * @return {StaggerFunction}\n */\nconst stagger = (val, params = {}) => {\n  let values = [];\n  let maxValue = 0;\n  const from = params.from;\n  const reversed = params.reversed;\n  const ease = params.ease;\n  const hasEasing = !isUnd(ease);\n  const hasSpring = hasEasing && !isUnd(/** @type {Spring} */(ease).ease);\n  const staggerEase = hasSpring ? /** @type {Spring} */(ease).ease : hasEasing ? parseEasings(ease) : null;\n  const grid = params.grid;\n  const axis = params.axis;\n  const customTotal = params.total;\n  const fromFirst = isUnd(from) || from === 0 || from === 'first';\n  const fromCenter = from === 'center';\n  const fromLast = from === 'last';\n  const fromRandom = from === 'random';\n  const isRange = isArr(val);\n  const useProp = params.use;\n  const val1 = isRange ? parseNumber(val[0]) : parseNumber(val);\n  const val2 = isRange ? parseNumber(val[1]) : 0;\n  const unitMatch = unitsExecRgx.exec((isRange ? val[1] : val) + emptyString);\n  const start = params.start || 0 + (isRange ? val1 : 0);\n  let fromIndex = fromFirst ? 0 : isNum(from) ? from : 0;\n  return (target, i, t, tl) => {\n    const [ registeredTarget ] = registerTargets(target);\n    const total = isUnd(customTotal) ? t : customTotal;\n    const customIndex = !isUnd(useProp) ? isFnc(useProp) ? useProp(registeredTarget, i, total) : getOriginalAnimatableValue(registeredTarget, useProp) : false;\n    const staggerIndex = isNum(customIndex) || isStr(customIndex) && isNum(+customIndex) ? +customIndex : i;\n    if (fromCenter) fromIndex = (total - 1) / 2;\n    if (fromLast) fromIndex = total - 1;\n    if (!values.length) {\n      for (let index = 0; index < total; index++) {\n        if (!grid) {\n          values.push(abs(fromIndex - index));\n        } else {\n          const fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;\n          const fromY = !fromCenter ? floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;\n          const toX = index % grid[0];\n          const toY = floor(index / grid[0]);\n          const distanceX = fromX - toX;\n          const distanceY = fromY - toY;\n          let value = sqrt(distanceX * distanceX + distanceY * distanceY);\n          if (axis === 'x') value = -distanceX;\n          if (axis === 'y') value = -distanceY;\n          values.push(value);\n        }\n        maxValue = max(...values);\n      }\n      if (staggerEase) values = values.map(val => staggerEase(val / maxValue) * maxValue);\n      if (reversed) values = values.map(val => axis ? (val < 0) ? val * -1 : -val : abs(maxValue - val));\n      if (fromRandom) values = shuffle(values);\n    }\n    const spacing = isRange ? (val2 - val1) / maxValue : val1;\n    const offset = tl ? parseTimelinePosition(tl, isUnd(params.start) ? tl.iterationDuration : start) : /** @type {Number} */(start);\n    /** @type {String|Number} */\n    let output = offset + ((spacing * round(values[staggerIndex], 2)) || 0);\n    if (params.modifier) output = params.modifier(output);\n    if (unitMatch) output = `${output}${unitMatch[2]}`;\n    return output;\n  }\n};\n\nexport { Animatable, Draggable, JSAnimation, Scope, ScrollObserver, Spring, TextSplitter, Timeline, Timer, WAAPIAnimation, animate, createAnimatable, createDraggable, createScope, createSpring, createTimeline, createTimer, eases, engine, onScroll, scrollContainers, stagger, svg, text, utils, waapi };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAGA;;AAEA;AACA,MAAMA,SAAS,GAAG,OAAOC,MAAM,KAAK,WAAW;;AAE/C;AACA,MAAMC,GAAG,GAAGF,SAAS,IAAG,yCAAyC,sBAAuBC,MAAM,IAAK,IAAI;;AAEvG;AACA,MAAME,GAAG,GAAGH,SAAS,GAAGI,QAAQ,GAAG,IAAI;;AAEvC;;AAEA;AACA,MAAMC,UAAU,GAAG;EACjBC,MAAM,EAAE,CAAC;EACTC,SAAS,EAAE,CAAC;EACZC,GAAG,EAAE,CAAC;EACNC,SAAS,EAAE,CAAC;EACZC,OAAO,EAAE;AACX,CAAC;;AAED;AACA,MAAMC,UAAU,GAAG;EACjB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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}